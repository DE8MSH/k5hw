//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct struct1 {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_100(void);
int32_t function_102(void);
int32_t function_1030(void);
int32_t function_104(void);
int32_t function_106(void);
int32_t function_108(void);
int32_t function_108c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10a(void);
int32_t function_10a0(void);
int32_t function_10c(void);
int32_t function_10dd868(void);
int32_t function_10ddda0(void);
int32_t function_10ddde0(void);
int32_t function_10e(void);
int32_t function_110(void);
int32_t function_111c280(void);
int32_t function_112(void);
int32_t function_1128(void);
int32_t function_114(void);
int32_t function_116(void);
int32_t function_117c(int32_t a1);
int32_t function_118(void);
int32_t function_11a(void);
int32_t function_11c(void);
int32_t function_11e(void);
int32_t function_120(void);
int32_t function_1223186(void);
int32_t function_128(int32_t a1, int32_t * a2);
int32_t function_1280(int32_t a1, int32_t a2);
int32_t function_12a8(int32_t a1);
int32_t function_12dc27c(void);
int32_t function_1305104(void);
int32_t function_139c(int32_t a1);
int32_t function_1414692(void);
int32_t function_1438(int32_t result, char a2, char a3, uint32_t a4, uint32_t a5, uint32_t a6, uint32_t a7);
int32_t function_143be(void);
int32_t function_1478(uint32_t a1);
int32_t function_14d8(int32_t result);
int32_t function_14d99cc(void);
int32_t function_1514(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_154(void);
int32_t function_1558(int32_t a1, int32_t a2);
int32_t function_1598(int32_t a1, int32_t a2, uint32_t a3, uint32_t result);
int32_t function_1599670(void);
int32_t function_15b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_15f0(int32_t a1);
int32_t function_1624(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_166(int32_t result);
int32_t function_167c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_16e8(void);
int32_t function_178(int32_t * a1, char * a2);
int32_t function_1804(int32_t a1);
int32_t function_1810(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1830(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_18cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_18d2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_18d672e(void);
int32_t function_1928(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_1978(uint32_t a1);
int32_t function_199c(int32_t a1);
int32_t function_19c(int32_t result, int32_t a2, int32_t a3);
int32_t function_1a3b336(void);
int32_t function_1a40(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1a60(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1a74(void);
int32_t function_1aa(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_1ab8(int32_t a1);
int32_t function_1ae(int32_t result, int32_t a2, int32_t a3);
int32_t function_1c0(int32_t a1);
int32_t function_1c65720(void);
int32_t function_1cd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1cdf99a(void);
int32_t function_1ce(int32_t a1);
int32_t function_1d5c38(void);
int32_t function_1d7c(void);
int32_t function_1dc156e(void);
int32_t function_1de0(void);
int32_t function_1e0c(uint32_t a1);
int32_t function_1e3c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_1e4(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_1e64(int32_t a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_1e90(int32_t a1, char a2);
int32_t function_1eb8(char * a1, uint32_t a2);
int32_t function_1f00(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t function_1f3c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1f5e(void);
int32_t function_1f62(void);
int32_t function_1f66(void);
int32_t function_1f6a(void);
int32_t function_1f6e(void);
int32_t function_1f72(int32_t a1, int32_t a2);
int32_t function_1f78(int32_t a1, int32_t * a2);
int32_t function_1f7cc(void);
int32_t function_1fc8(int32_t a1, int32_t * a2);
int32_t function_1fec(void);
int32_t function_20001388(void);
int32_t function_2004(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_202ed3f6(void);
int32_t function_2040(char a1, int32_t a2);
int32_t function_2074(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, uint32_t a5);
int32_t function_2098ac(void);
int32_t function_20a0(void);
int32_t function_20dc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2110(int32_t result);
int32_t function_2140(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_21aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2214(int32_t a1);
int32_t function_2218(void);
int32_t function_221c(void);
int32_t function_2220(void);
int32_t function_2224(void);
int32_t function_222e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2232(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2236(int32_t a1);
int32_t function_223a(int32_t a1);
int32_t function_223e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2242(void);
int32_t function_2246(int32_t a1, int32_t a2);
int32_t function_224a(int32_t a1, int32_t a2);
int32_t function_224e(int32_t a1);
int32_t function_2252(void);
int32_t function_2256(void);
int32_t function_225a(void);
int32_t function_225e(void);
int32_t function_2262(int32_t a1);
int32_t function_2266(int32_t a1);
int32_t function_2270(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2274(void);
int32_t function_227a(int32_t a1, int32_t a2);
int32_t function_228c(int32_t a1, int32_t a2, int32_t result, int32_t a4);
int32_t function_22be(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_22c2(void);
int32_t function_22c6(void);
int32_t function_22f8(char a1, int32_t * a2, int32_t * a3);
int32_t function_2342(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_235a(void);
int32_t function_235e(void);
int32_t function_2361a(void);
int32_t function_2364(void);
int32_t function_23648(void);
int32_t function_236a(void);
int32_t function_2370(void);
int32_t function_2376(void);
int32_t function_237c(void);
int32_t function_2382(void);
int32_t function_2388(void);
int32_t function_238e(void);
int32_t function_2394(void);
int32_t function_239c(void);
int32_t function_239e(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_23a37a(void);
int32_t function_23a6(void);
int32_t function_23b0(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_23c1d6(void);
int32_t function_255c2(void);
int32_t function_255e2(void);
int32_t function_2580(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2660c(void);
int32_t function_2b24(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2c9c(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_2cc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2cca(int32_t a1);
int32_t function_2cd0(int32_t a1, int32_t a2);
int32_t function_2d38(int32_t a1, int32_t a2);
int32_t function_2d94(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2e50(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2e7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2e86(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_2e90(void);
int32_t function_2e94(int32_t result, int32_t a2, int32_t a3);
int32_t function_2e98(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2ea2(int32_t a1, int32_t a2);
int32_t function_2eaa(int32_t a1, int32_t a2, int32_t a3);
int32_t function_2eac(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2ec8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_2f58(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_301c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_31b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_32478(void);
int32_t function_328c4(void);
int32_t function_329c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_32c(int32_t result2, int32_t a2, int32_t a3, int32_t a4);
int32_t function_32c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_32d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_32dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_32e6(void);
int32_t function_32ea(int32_t result, int32_t a2, int32_t a3);
int32_t function_32ee(int32_t a1, int32_t a2, int32_t a3);
int32_t function_32f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3314(int32_t result, int32_t a2);
int32_t function_33ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_348(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3578(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_35f8a6(void);
int32_t function_360100(void);
int32_t function_3604(int32_t result, int32_t a2);
int32_t function_3620(int32_t result, int32_t a2, int32_t a3);
int32_t function_362652(void);
int32_t function_364d5a(void);
int32_t function_3684(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_3764(int32_t result, int32_t a2);
int32_t function_37d4(int32_t a1, int32_t a2);
int32_t function_381c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_3b40(int32_t result, int16_t a2, int32_t a3, int32_t a4);
int32_t function_3bf4a(void);
int32_t function_3cf0(int32_t result, int32_t a2);
int32_t function_3d09a6(void);
int32_t function_3dc8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3ec0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3eec(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3ef6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3f00(void);
int32_t function_3f04(int32_t result, int32_t a2, int32_t a3);
int32_t function_3f08(void);
int32_t function_3f12(void);
int32_t function_3f18(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3f22(int32_t a1, int32_t a2);
int32_t function_3f3a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_3f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_3ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40dc(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_418(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_425c(int32_t result, int32_t a2);
int32_t function_42e8(int32_t result, int32_t a2, int32_t a3);
int32_t function_43dc(int32_t a1, int32_t a2, int32_t a3);
int32_t function_446e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4474(void);
int32_t function_4478(int32_t a1, int32_t a2, int32_t a3);
int32_t function_447a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4480(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4488(void);
int32_t function_448c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_448e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4494(void);
int32_t function_4498(void);
int32_t function_449a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_44c4(int32_t result, int32_t a2);
int32_t function_44df04(void);
int32_t function_458c(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_45d44(void);
int32_t function_4759dc(void);
int32_t function_4908(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4d48(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_508(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_50e4(void);
int32_t function_511c(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_51c0(void);
int32_t function_524(int32_t a1, int32_t a2);
int32_t function_52c8(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_54c8(int32_t a1);
int32_t function_5578(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_560(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5678(int32_t a1);
int32_t function_56b0(int32_t a1, int32_t a2, char a3, int32_t a4);
int32_t function_5710(void);
int32_t function_5748(void);
int32_t function_5808(int32_t a1);
int32_t function_588(int32_t a1, int32_t a2, int32_t * a3, uint32_t a4);
int32_t function_58e4(void);
int32_t function_5924(void);
int32_t function_5960(void);
int32_t function_598c(void);
int32_t function_59d8(int32_t a1, char a2, int32_t a3, int32_t a4);
int32_t function_5b28(uint32_t result, int32_t * a2);
int32_t function_5b58(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5c44(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5cc0(int32_t a1);
int32_t function_5de8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_5e8(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_5f5c(char a1, int32_t a2);
int32_t function_608(uint32_t a1, uint32_t a2, uint32_t a3);
int32_t function_62a(uint32_t a1, int32_t a2, uint32_t a3);
int32_t function_62b4(void);
int32_t function_650(int32_t result, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_66a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_6904(void);
int32_t function_69d0(int32_t * a1);
int32_t function_6b88(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6bc2(void);
int32_t function_6bcc(uint32_t a1, char a2, int32_t a3, char result2);
int32_t function_6caa(void);
int32_t function_6cb0(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6d10(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6eca(void);
int32_t function_6ef4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6f50(int32_t a1, int32_t a2);
int32_t function_6f60(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_6ff8(void);
int32_t function_7020(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_7070(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_710(int32_t a1, int32_t a2);
int32_t function_739c(int32_t result, int32_t a2, int32_t a3);
int32_t function_7408(void);
int32_t function_744c(int32_t a1, int32_t a2);
int32_t function_74d0(int32_t a1);
int32_t function_750(void);
int32_t function_7504(int16_t a1, int32_t a2, int32_t a3);
int32_t function_7588(void);
int32_t function_7690(void);
int32_t function_7714(void);
int32_t function_774(int32_t a1, int32_t a2, int32_t a3);
int32_t function_77a8(char a1, char a2, char a3);
int32_t function_77bc(void);
int32_t function_7820(void);
int32_t function_782c(int32_t a1);
int32_t function_78bc(int32_t a1);
int32_t function_7b0(int32_t result, int32_t a2);
int32_t function_7b74(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_7bc(int32_t result, int32_t a2);
int32_t function_7c8(int32_t result, int32_t a2);
int32_t function_7cb0(void);
int32_t function_7cc4(void);
int32_t function_7ce0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_7d4(int32_t result, int32_t a2);
int32_t function_7dac(void);
int32_t function_7e0(void);
int32_t function_7ea0(void);
int32_t function_7f24(void);
int32_t function_7f4(char * a1);
int32_t function_7fa8(void);
int32_t function_8204(void);
int32_t function_82a8(void);
int32_t function_82f4(void);
int32_t function_830c(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8418(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8478(int32_t a1);
int32_t function_84c8(int32_t a1, char a2, int32_t a3, char a4);
int32_t function_8594(void);
int32_t function_859e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_85bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_85da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_864c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_870c(uint32_t a1, int32_t * a2, int32_t a3, int32_t * a4);
int32_t function_874c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_87d0(int32_t a1, int32_t a2);
int32_t function_87ea(int32_t a1);
int32_t function_87f0(int32_t a1);
int32_t function_87f6(int32_t a1);
int32_t function_87fc(int32_t a1);
int32_t function_8808(void);
int32_t function_8920(int32_t a1);
int32_t function_8934(void);
int32_t function_8af8(void);
int32_t function_8c6e(void);
int32_t function_8c8c(int32_t a1);
int32_t function_8cb4(int32_t a1);
int32_t function_8ccc(int32_t a1, int32_t a2);
int32_t function_8d08(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9440(void);
int32_t function_9532(void);
int32_t function_9540(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9558(int32_t a1, int32_t a2);
int32_t function_956e(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_9590(int32_t a1, int32_t a2, int32_t a3);
int32_t function_95be(void);
int32_t function_95c2(int32_t result);
int32_t function_95d2(void);
int32_t function_95de(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_960e(void);
int32_t function_9610(void);
int32_t function_9616(void);
int32_t function_961e(int32_t result, char * a2, int32_t a3);
int32_t function_9622(void);
int32_t function_962c(void);
int32_t function_9634(int32_t a1);
int32_t function_9644(int32_t a1, int32_t a2);
int32_t function_964a(void);
int32_t function_9650(void);
int32_t function_9660(void);
int32_t function_966a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_968e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_96d0(int32_t a1, int32_t a2);
int32_t function_96e4(void);
int32_t function_96ec(void);
int32_t function_96ee(void);
int32_t function_96f0(void);
int32_t function_96f2(void);
int32_t function_96f4(void);
int32_t function_96f6(void);
int32_t function_96f8(int32_t result, int32_t a2);
int32_t function_96fc(void);
int32_t function_9706(void);
int32_t function_9710(void);
int32_t function_9728(void);
int32_t function_9730(int32_t a1, int32_t a2);
int32_t function_9748(int32_t a1, int32_t a2);
int32_t function_974e(void);
int32_t function_9756(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_9ab4(void);
int32_t function_9b30(int32_t a1);
int32_t function_9b3c(void);
int32_t function_9bf4(int32_t result, int32_t a2);
int32_t function_9c10(void);
int32_t function_9c7b94(void);
int32_t function_9d7c(int32_t * a1, int32_t * a2);
int32_t function_9dbc(void);
int32_t function_9e08(int32_t result, int32_t a2, int32_t a3);
int32_t function_9e4c(int32_t * a1, int32_t * a2);
int32_t function_9eb8(int32_t * a1);
int32_t function_9ee8(void);
int32_t function_9f14(int32_t a1, int32_t a2);
int32_t function_9f7c(int32_t a1);
int32_t function_9f84(int32_t a1);
int32_t function_9f8c(int32_t a1);
int32_t function_9fbc(char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a020(int32_t a1);
int32_t function_a050(int32_t a1);
int32_t function_a06c(char a1);
int32_t function_a07c(int32_t a1);
int32_t function_a088(int32_t a1, int32_t a2);
int32_t function_a098(int32_t a1, int16_t a2, int32_t a3, int32_t a4);
int32_t function_a1ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a278(char a1);
int32_t function_a29c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a2d0(int32_t a1);
int32_t function_a2f0(int16_t a1);
int32_t function_a31a(int32_t a1, int16_t a2, int32_t a3, int32_t * a4);
int32_t function_a34(int32_t a1);
int32_t function_a348(int32_t * a1);
int32_t function_a360(int32_t a1);
int32_t function_a37d3c(void);
int32_t function_a4fc(void);
int32_t function_a50(void);
int32_t function_a518(void);
int32_t function_a550(int32_t a1);
int32_t function_a584(int16_t a1, int16_t a2);
int32_t function_a5d0(char a1);
int32_t function_a5dc(void);
int32_t function_a5f8(int32_t a1);
int32_t function_a600(void);
int32_t function_a61c(void);
int32_t function_a63c(void);
int32_t function_a64(int32_t * a1);
int32_t function_a67c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_a710(int32_t a1);
int32_t function_a71e(int32_t * a1, int32_t a2, char a3, char a4);
int32_t function_a72e(int32_t * a1);
int32_t function_a73e(char a1);
int32_t function_a74e(int32_t * a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t function_a77e(int32_t * a1);
int32_t function_a794(uint32_t a1, int32_t a2);
int32_t function_a7cc(void);
int32_t function_a90(void);
int32_t function_a92c(int32_t a1);
int32_t function_a93540(void);
int32_t function_a9452e(void);
int32_t function_a960(int32_t * a1);
int32_t function_a9b8(char a1, char a2, char a3, char a4, int32_t a5, int32_t a6);
int32_t function_aa10(int32_t a1);
int32_t function_aa48(int32_t a1);
int32_t function_aa78(int32_t a1);
int32_t function_aabc(uint32_t a1);
int32_t function_aad4(int32_t a1, uint32_t a2);
int32_t function_ab0(void);
int32_t function_ab00(int32_t a1);
int32_t function_ab10(void);
int32_t function_ab28(void);
int32_t function_ab40(void);
int32_t function_ab58(void);
int32_t function_abd8(int32_t a1);
int32_t function_ac38(int32_t a1);
int32_t function_ac4(int32_t a1, int32_t a2);
int32_t function_ac98(char a1, int32_t a2);
int32_t function_acdc(void);
int32_t function_acf4(int32_t a1);
int32_t function_ad04(int32_t a1, int32_t a2, int16_t a3, uint16_t a4, int32_t a5, int32_t a6);
int32_t function_ad64(char a1);
int32_t function_ad94(void);
int32_t function_ae4c(void);
int32_t function_ae6c(void);
int32_t function_aedc(void);
int32_t function_af00(int32_t * a1, int32_t a2);
int32_t function_af60(int32_t result);
int32_t function_af80(void);
int32_t function_afa4(int32_t a1, uint32_t a2);
int32_t function_afe0(void);
int32_t function_aff4(uint32_t a1, int32_t * a2, unsigned char a3);
int32_t function_b02a(uint32_t a1, int32_t a2);
int32_t function_b05c(int32_t a1);
int32_t function_b0b8(void);
int32_t function_b10(int32_t a1);
int32_t function_b2a8(void);
int32_t function_b2aa(int32_t * a1, int32_t a2);
int32_t function_b2f8(int32_t a1);
int32_t function_b3f8(int32_t * a1);
int32_t function_b510(void);
int32_t function_b550(void);
int32_t function_b590(int32_t * a1, int32_t a2);
int32_t function_b5b4(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5);
int32_t function_b638(void);
int32_t function_b6b0(void);
int32_t function_b70c(int32_t a1);
int32_t function_b768(void);
int32_t function_b810(void);
int32_t function_b844(int32_t a1, int32_t a2);
int32_t function_b8a8(int32_t * a1);
int32_t function_b8d0(void);
int32_t function_b9b844(void);
int32_t function_ba6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_ba8(int32_t a1);
int32_t function_baa4(void);
int32_t function_bacc(void);
int32_t function_bb0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_bbc8(void);
int32_t function_be44(int32_t * a1, int32_t * a2);
int32_t function_be70(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4);
int32_t function_bf04(char a1);
int32_t function_bf4(void);
int32_t function_bf60d4(void);
int32_t function_bf70(int32_t a1);
int32_t function_bf98(int32_t a1, uint32_t a2);
int32_t function_bfb2(int32_t a1, uint32_t a2);
int32_t function_bfca(int32_t a1, int32_t * a2);
int32_t function_bfe4(int32_t a1, int32_t * a2);
int32_t function_c0(int32_t a1);
int32_t function_c000(int32_t * a1);
int32_t function_c014(uint32_t result, int32_t * a2);
int32_t function_c08c(void);
int32_t function_c0a0(int32_t a1);
int32_t function_c0b0(void);
int32_t function_c0bc(int32_t a1);
int32_t function_c0cc(int32_t a1, int32_t a2);
int32_t function_c0e8(void);
int32_t function_c0f2(void);
int32_t function_c0fc(void);
int32_t function_c106(void);
int32_t function_c110(int32_t a1);
int32_t function_c128(int32_t a1);
int32_t function_c134(void);
int32_t function_c158(int32_t a1);
int32_t function_c22c(void);
int32_t function_c25c(int32_t result);
int32_t function_c268(int32_t a1, int32_t * a2);
int32_t function_c344(int32_t result, int32_t a2);
int32_t function_c360(int32_t result);
int32_t function_c36c(void);
int32_t function_c399(void);
int32_t function_c39a(int32_t a1);
int32_t function_c674(void);
int32_t function_c6b8(void);
int32_t function_c6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_c710(uint32_t a1);
int32_t function_c73e(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_c758(void);
int32_t function_c766(uint32_t a1);
int32_t function_c774(void);
int32_t function_c778(int32_t * a1, int32_t * a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6);
int32_t function_c7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_c8ec(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4);
int32_t function_cfd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_cff8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d024(int32_t result, int32_t * a2);
int32_t function_d02e(int32_t a1);
int32_t function_d04(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d0ec(int32_t a1);
int32_t function_d100(int32_t a1);
int32_t function_d148(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d2ba(void);
int32_t function_d2e4(int32_t a1, int32_t a2);
int32_t function_d316(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d330(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d340(void);
int32_t function_d344(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d50e(int32_t a1);
int32_t function_d54e(uint32_t a1);
int32_t function_d578(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d5d6(void);
int32_t function_d5e2(int32_t a1, int32_t a2);
int32_t function_d654(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d69c(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4);
int32_t function_d6f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d6f2(int32_t a1, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_d784(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d7e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d8(void);
int32_t function_d804(int32_t result);
int32_t function_d854(int32_t a1, int32_t a2, int32_t a3);
int32_t function_d86e(void);
int32_t function_d870(int32_t a1);
int32_t function_d890(int32_t result);
int32_t function_d8b0(int32_t result);
int32_t function_d8c0(void);
int32_t function_d8d0(int32_t result, uint32_t a2);
int32_t function_d904(int32_t a1);
int32_t function_d920(void);
int32_t function_d93c(int32_t result);
int32_t function_d944(int32_t result);
int32_t function_d954(int32_t result);
int32_t function_d970(uint32_t a1);
int32_t function_d9b0(int32_t result);
int32_t function_d9c4(int32_t a1);
int32_t function_d9d2(void);
int32_t function_d9d8(void);
int32_t function_d9e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_d9f0(int32_t result);
int32_t function_d9fe(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_da(void);
int32_t function_da16(int32_t result, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_da40(int32_t a1);
int32_t function_da56(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_da90(int32_t result);
int32_t function_dae2(int32_t a1);
int32_t function_daf0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_db32(uint32_t a1);
int32_t function_db88(int32_t result);
int32_t function_db9a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_dbda(int32_t result, int32_t a2);
int32_t function_dbde(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_dc(void);
int32_t function_dc2e(int32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t function_dc8c(void);
int32_t function_dc94(int32_t result, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_dcfc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_ddd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_de(void);
int32_t function_de2c(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_de40(int32_t a1);
int32_t function_dea8(int32_t a1);
int32_t function_df8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e0(void);
int32_t function_e060(int32_t result, int32_t a2, int32_t a3, uint32_t a4);
int32_t function_e0da(int32_t a1);
int32_t function_e0e4(int32_t result);
int32_t function_e100(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_e1b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e1c6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e1d6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e2(void);
int32_t function_e210(int32_t a1, int32_t a2, int32_t a3);
int32_t function_e22a(void);
int32_t function_e240(int32_t a1);
int32_t function_e264(void);
int32_t function_e278(int32_t a1);
int32_t function_e294(void);
int32_t function_e2a0(void);
int32_t function_e2a8(void);
int32_t function_e2b4(void);
int32_t function_e2c0(uint32_t a1);
int32_t function_e2cc(void);
int32_t function_e2d4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_e30c(int32_t result, int32_t a2);
int32_t function_e32c(int32_t result);
int32_t function_e354(void);
int32_t function_e378(void);
int32_t function_e398(int32_t a1);
int32_t function_e3b8(void);
int32_t function_e3dc(void);
int32_t function_e3f8(int32_t a1);
int32_t function_e4(void);
int32_t function_e414(void);
int32_t function_e500(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e518(void);
int32_t function_e5de(void);
int32_t function_e6(void);
int32_t function_e8(void);
int32_t function_e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_e9d196(void);
int32_t function_ea(void);
int32_t function_ebc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_ec(void);
int32_t function_ee(void);
int32_t function_ee4(int32_t a1);
int32_t function_f0(void);
int32_t function_f2(void);
int32_t function_f4(void);
int32_t function_f6(void);
int32_t function_f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_f8(void);
int32_t function_fa(void);
int32_t function_fc(void);
int32_t function_fe(void);
int32_t function_fe00e3ce(void);
int32_t function_fe43c266(void);
int32_t function_fe8b13b2(void);
int32_t function_fe9804c0(void);
int32_t function_feead194(void);
int32_t function_ff30e4c2(void);
int32_t function_ff3e529a(void);
int32_t function_ff43a262(void);
int32_t unknown_1340494(void);
int32_t unknown_37eeb4(void);
int32_t unknown_4fd722(int32_t a1);
int32_t unknown_dc0480(void);
int32_t unknown_fea3fa4a(void);
int32_t unknown_ff37ff2e(void);
int32_t unknown_ff9fda84(int32_t a1);

// --------------------- Global Variables ---------------------

int16_t * g1 = (int16_t *)-0x2adfffed; // 0x1
char * g2; // 0x10
char * g3; // 0x11
int32_t g4 = -0x1e67e000; // 0x111a
int32_t g5 = 0xe198; // 0x111c
int32_t g6 = 0x4806fcad; // 0x115c
int16_t * g7 = NULL; // 0x12
int32_t g8 = 0xe7fe; // 0x120
char * g9; // 0x13
bool g10 = false; // 0x1388
int16_t * g11 = NULL; // 0x14
char * g12; // 0x15
char g13 = 0; // 0x16
char * g14; // 0x17
int32_t g15 = 0x430b4603; // 0x178
int16_t * g16 = NULL; // 0x18
char * g17; // 0x19
char * g18; // 0x1a
char * g19; // 0x1b
int16_t * g20 = NULL; // 0x1c
char * g21; // 0x1d
int32_t g22 = 0x1e49431a; // 0x1d8
char * g23; // 0x1e
char * g24; // 0x1f
int16_t * g25 = (int16_t *)0xd52000; // 0x2
char * g26; // 0x20
int32_t g27 = 0; // 0x21
bool g28 = false; // 0x22
char g29 = 0; // 0x23
char * g30; // 0x24
int32_t g31 = 0; // 0x25
char * g32; // 0x26
char * g33; // 0x27
int32_t g34 = 0; // 0x28
char g35 = 0; // 0x2a
int32_t g36 = 0xdd00; // 0x2b
char g37 = 0; // 0x2d
int32_t g38 = -0x2345e000; // 0x2d8a
int32_t g39 = -0x2cfdbd61; // 0x2dce
char * g40; // 0x2e
int32_t g41 = 0x70082002; // 0x2ebc
int32_t g42 = 0xbd70; // 0x2ec0
int32_t g43 = 0; // 0x2f
char * g44 = " \xd5"; // 0x3
int32_t g45 = 0; // 0x30
int32_t g46 = 0; // 0x31
int32_t g47 = 0; // 0x32
char * g48; // 0x33
int32_t g49 = 0x70082002; // 0x3308
int32_t g50 = 0xbd70; // 0x330c
int16_t * g51 = NULL; // 0x34
char g52 = 0; // 0x35
int16_t * g53 = (int16_t *)0xdf0000; // 0x36
int32_t g54 = 0xdf00; // 0x37
int32_t g55 = 223; // 0x38
int32_t g56 = 0xc39900; // 0x3b
int32_t g57 = 0x46012000; // 0x3b0
int32_t g58 = 0xc399; // 0x3c
int32_t g59 = -0x1cffff3d; // 0x3d
int32_t g60 = -0x220dba9f; // 0x3e0
int32_t g61 = 0xe300; // 0x3f
int16_t * g62 = (int16_t *)213; // 0x4
int32_t g63 = 227; // 0x40
int32_t g64 = -0x6fff6eff; // 0x400
int32_t g65 = 0xe500; // 0x43
int32_t g66 = 0x46020849; // 0x430
int32_t g67 = 229; // 0x44
int32_t g68 = 0xe700; // 0x47
int32_t g69 = 231; // 0x48
bool g70 = true; // 0x4c
char * g71; // 0x5
int32_t g72 = 235; // 0x50
int16_t g73 = -0x4ffd; // 0x51c
int32_t g74 = 239; // 0x58
int32_t g75 = 241; // 0x5c
int16_t * g76 = (int16_t *)0xd90000; // 0x6
char g77 = -13; // 0x60
int32_t g78 = 245; // 0x64
int32_t g79 = 247; // 0x68
int32_t g80 = 0x200003f8; // 0x68dc
bool g81 = true; // 0x6c
char * g82; // 0x7
int32_t g83 = 251; // 0x70
bool g84 = true; // 0x74
int32_t g85 = 0xff0000; // 0x76
int16_t g86 = -0x1e4c; // 0x76c
int32_t g87 = 255; // 0x78
int32_t g88 = 257; // 0x7c
int32_t g89 = 0xabcd; // 0x7d98
int16_t * g90 = (int16_t *)217; // 0x8
char * g91 = "\x03\x01"; // 0x80
bool g92 = true; // 0x84
int32_t g93 = 263; // 0x88
int32_t g94 = 58; // 0x8ce4
char * g95; // 0x9
int32_t g96 = 271; // 0x98
int16_t * g97 = (int16_t *)0xdb0000; // 0xa
int32_t g98 = 275; // 0xa0
int32_t g99 = 277; // 0xa4
int16_t g100 = 71; // 0xa5f
int16_t g101 = 189; // 0xabcd
char * g102; // 0xb
int32_t g103 = 283; // 0xb0
int32_t g104 = -0x110fffe0; // 0xb017
int32_t g105 = 285; // 0xb4
int16_t * g106 = (int16_t *)219; // 0xc
int32_t g107 = 0x46854803; // 0xc0
char g108 = 0; // 0xc8
int32_t g109 = 0xd149; // 0xcc
int32_t g110 = 0x138800; // 0xcf
char * g111; // 0xd
int32_t g112 = 0x20001388; // 0xd0
int32_t g113 = 0x37d2000; // 0xd2b6
char g114 = 96; // 0xd338
int32_t g115 = 0xf1f3f70; // 0xd518
int32_t g116 = 0x41413e00; // 0xd620
char * g117; // 0xd66d
int32_t g118 = -0x707f800; // 0xd8ac
int32_t g119 = -0x3f1f9000; // 0xda2c
int16_t * g120 = (int16_t *)0x2b5029e; // 0xdf40
char * g121; // 0xe
int32_t g122 = 0xf80818; // 0xe0d8
int32_t g123 = 0xe1e4; // 0xe1b4
int32_t g124 = -0x7a91000; // 0xe1e4
int32_t g125 = 0x6f00047; // 0xe28f
char * g126; // 0xf
char * g127 = "\x8c\x03"; // 0xf54
int32_t g128 = 1308; // 0xf58
int32_t g129 = -0x1180119; // 0xff
int32_t g130;

// ------------------------ Functions -------------------------

// Address range: 0xc0 - 0xcc
int32_t function_c0(int32_t a1) {
    // 0xc0
    function_750();
    int32_t v1; // 0xc0
    return function_d148(0xd149, v1, v1, v1);
}

// Address range: 0xd4 - 0xd8
int32_t entry_point(void) {
    // 0xd4
    return function_c0(193);
}

// Address range: 0xd8 - 0xda
int32_t function_d8(void) {
    // 0xd8
    return function_d8();
}

// Address range: 0xda - 0xdc
int32_t function_da(void) {
    // 0xda
    return function_da();
}

// Address range: 0xdc - 0xde
int32_t function_dc(void) {
    // 0xdc
    return function_dc();
}

// Address range: 0xde - 0xe0
int32_t function_de(void) {
    // 0xde
    return function_de();
}

// Address range: 0xe0 - 0xe2
int32_t function_e0(void) {
    // 0xe0
    return function_e0();
}

// Address range: 0xe2 - 0xe4
int32_t function_e2(void) {
    // 0xe2
    return function_e2();
}

// Address range: 0xe4 - 0xe6
int32_t function_e4(void) {
    // 0xe4
    return function_e4();
}

// Address range: 0xe6 - 0xe8
int32_t function_e6(void) {
    // 0xe6
    return function_e6();
}

// Address range: 0xe8 - 0xea
int32_t function_e8(void) {
    // 0xe8
    return function_e8();
}

// Address range: 0xea - 0xec
int32_t function_ea(void) {
    // 0xea
    return function_ea();
}

// Address range: 0xec - 0xee
int32_t function_ec(void) {
    // 0xec
    return function_ec();
}

// Address range: 0xee - 0xf0
int32_t function_ee(void) {
    // 0xee
    return function_ee();
}

// Address range: 0xf0 - 0xf2
int32_t function_f0(void) {
    // 0xf0
    return function_f0();
}

// Address range: 0xf2 - 0xf4
int32_t function_f2(void) {
    // 0xf2
    return function_f2();
}

// Address range: 0xf4 - 0xf6
int32_t function_f4(void) {
    // 0xf4
    return function_f4();
}

// Address range: 0xf6 - 0xf8
int32_t function_f6(void) {
    // 0xf6
    return function_f6();
}

// Address range: 0xf8 - 0xfa
int32_t function_f8(void) {
    // 0xf8
    return function_f8();
}

// Address range: 0xfa - 0xfc
int32_t function_fa(void) {
    // 0xfa
    return function_fa();
}

// Address range: 0xfc - 0xfe
int32_t function_fc(void) {
    // 0xfc
    return function_fc();
}

// Address range: 0xfe - 0x100
int32_t function_fe(void) {
    // 0xfe
    return function_fe();
}

// Address range: 0x100 - 0x102
int32_t function_100(void) {
    // 0x100
    return function_100();
}

// Address range: 0x102 - 0x104
int32_t function_102(void) {
    // 0x102
    return function_102();
}

// Address range: 0x104 - 0x106
int32_t function_104(void) {
    // 0x104
    return function_104();
}

// Address range: 0x106 - 0x108
int32_t function_106(void) {
    // 0x106
    return function_106();
}

// Address range: 0x108 - 0x10a
int32_t function_108(void) {
    // 0x108
    return function_108();
}

// Address range: 0x10a - 0x10c
int32_t function_10a(void) {
    // 0x10a
    return function_10a();
}

// Address range: 0x10c - 0x10e
int32_t function_10c(void) {
    // 0x10c
    return function_10c();
}

// Address range: 0x10e - 0x110
int32_t function_10e(void) {
    // 0x10e
    return function_10e();
}

// Address range: 0x110 - 0x112
int32_t function_110(void) {
    // 0x110
    return function_110();
}

// Address range: 0x112 - 0x114
int32_t function_112(void) {
    // 0x112
    return function_112();
}

// Address range: 0x114 - 0x116
int32_t function_114(void) {
    // 0x114
    return function_114();
}

// Address range: 0x116 - 0x118
int32_t function_116(void) {
    // 0x116
    return function_116();
}

// Address range: 0x118 - 0x11a
int32_t function_118(void) {
    // 0x118
    return function_118();
}

// Address range: 0x11a - 0x11c
int32_t function_11a(void) {
    // 0x11a
    return function_11a();
}

// Address range: 0x11c - 0x11e
int32_t function_11c(void) {
    // 0x11c
    return function_11c();
}

// Address range: 0x11e - 0x120
int32_t function_11e(void) {
    // 0x11e
    return function_11e();
}

// Address range: 0x120 - 0x122
int32_t function_120(void) {
    // 0x120
    return function_120();
}

// Address range: 0x128 - 0x154
int32_t function_128(int32_t a1, int32_t * a2) {
    // 0x128
    while (true) {
        uint32_t v1 = (int32_t)&g26; // 0x14c
        while (v1 > 0) {
            // 0x136
            v1--;
            if (a1 >> v1 >= (uint32_t)(int32_t)a2) {
                // break -> 0x13e
                break;
            }
        }
        return 0;
    }
    // 0x152
    int32_t result; // 0x128
    return result;
}

// Address range: 0x154 - 0x166
int32_t function_154(void) {
    uint32_t v1 = 0x41c64e6d * *(int32_t *)0x20000480 + 0x3039; // 0x15e
    *(int32_t *)0x20000480 = v1;
    return v1 / 2;
}

// Address range: 0x166 - 0x16c
int32_t function_166(int32_t result) {
    // 0x166
    *(int32_t *)0x20000480 = result;
    return result;
}

// Address range: 0x178 - 0x19c
int32_t function_178(int32_t * a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    int32_t v3 = v2; // 0x17e
    int32_t result = v2; // 0x17e
    int32_t v4 = v1; // 0x17e
    int32_t v5; // 0x178
    int32_t v6; // 0x178
    if ((v1 || v2) << (int32_t)&g23 == 0 && (uint32_t)v6 >= (int32_t)&g62) {
        int32_t v7 = v1 + 4; // 0x182
        int32_t v8; // 0x178
        int32_t v9 = v8 - (int32_t)&g62; // 0x184
        *(int32_t *)v3 = *(int32_t *)v1;
        v3 += 4;
        v8 = v9;
        result = v3;
        v4 = v7;
        v5 = v9;
        while (v9 >= (int32_t)&g62) {
            int32_t v10 = v7;
            v7 = v10 + 4;
            v9 = v8 - (int32_t)&g62;
            *(int32_t *)v3 = *(int32_t *)v10;
            v3 += 4;
            v8 = v9;
            result = v3;
            v4 = v7;
            v5 = v9;
        }
    }
    int32_t v11 = v5; // 0x198
    int32_t v12 = v4; // 0x198
    if (v5 == 0) {
        // 0x19a
        return result;
    }
    int32_t result2 = result; // 0x198
    v11--;
    *(char *)result2 = *(char *)v12;
    result2++;
    v12++;
    while (v11 != 0) {
        // 0x18e
        v11--;
        *(char *)result2 = *(char *)v12;
        result2++;
        v12++;
    }
    // 0x19a
    return result2;
}

// Address range: 0x19c - 0x1aa
int32_t function_19c(int32_t result, int32_t a2, int32_t a3) {
    // 0x19c
    if (a2 == 0) {
        // 0x1a8
        return result;
    }
    int32_t v1 = a2; // 0x1a4
    int32_t result2 = result; // 0x1a2
    v1--;
    *(char *)result2 = (char)a3;
    result2++;
    while (v1 != 0) {
        // 0x1a0
        v1--;
        *(char *)result2 = (char)a3;
        result2++;
    }
    // 0x1a8
    return result2;
}

// Address range: 0x1aa - 0x1ae
int32_t function_1aa(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4) {
    // 0x1aa
    return function_19c((int32_t)a1, (int32_t)a2, 0);
}

// Address range: 0x1ae - 0x1c0
int32_t function_1ae(int32_t result, int32_t a2, int32_t a3) {
    // 0x1ae
    function_19c(result, a3, a2);
    return result;
}

// Address range: 0x1c0 - 0x1ce
int32_t function_1c0(int32_t a1) {
    int32_t v1 = a1; // 0x1c0
    while (*(char *)v1 != 0) {
        // 0x1c2
        v1++;
    }
    // 0x1ca
    return v1 - a1;
}

// Address range: 0x1ce - 0x1e2
int32_t function_1ce(int32_t a1) {
    int32_t v1 = a1 + (int32_t)&g62; // 0x1d0
    int32_t v2 = (int32_t)&g44; // 0x1d0
    v1 -= (int32_t)&g1;
    int32_t v3; // 0x1ce
    int32_t result = v3 << (int32_t)&g90 | (int32_t)*(char *)v1; // 0x1d8
    v2--;
    while (v2 >= 0) {
        // 0x1d2
        v1 -= (int32_t)&g1;
        result = result << (int32_t)&g90 | (int32_t)*(char *)v1;
        v2--;
    }
    // 0x1de
    return result;
}

// Address range: 0x1e4 - 0x32c
int32_t function_1e4(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    float32_t v1 = fabsf((float32_t)a2);
    bool v2 = a1 < a3 | (int32_t)v1 < (int32_t)fabsf((float32_t)a4); // 0x1fe
    int32_t v3 = v2 ? a1 : a3;
    int32_t v4 = v2 ? a2 : a4;
    int32_t result = v2 ? a3 : a1;
    if ((v3 | (int32_t)fabsf((float32_t)v4)) == 0) {
        // 0x2ac
        return result;
    }
    int32_t v5 = (a4 ^ a2) >> (int32_t)&g24; // 0x1ee
    uint32_t v6 = v2 ? a4 : a2;
    int32_t v7 = v6 >> (int32_t)&g11; // 0x216
    int32_t v8 = v7 & 0xffffffff >> (int32_t)&g12; // 0x21e
    int32_t v9 = v8 - (2 * v4 >> (int32_t)&g12); // 0x224
    int32_t v10; // 0x1e4
    int32_t v11; // 0x1e4
    int32_t v12; // 0x1e4
    int32_t v13; // 0x1e4
    if (v9 < (int32_t)&g63) {
        int32_t v14 = v4 & 0xffffffff >> (int32_t)&g106 | 1 << (int32_t)&g11; // 0x234
        int32_t v15 = v3; // 0x23e
        int32_t v16 = v14; // 0x23e
        if (v5 != 0) {
            // 0x240
            v15 = -v3;
            v16 = (int32_t)(v3 != 0) - v14;
        }
        uint32_t v17 = function_5e8(v15, v16, (int32_t)&g63 - v9); // 0x256
        uint32_t v18 = function_62a(v15, v16, v9); // 0x262
        uint32_t v19 = v18 + result; // 0x266
        int32_t v20 = v16 + v6 + (int32_t)(v19 < v18); // 0x268
        v10 = v19;
        v11 = v20;
        v12 = v17;
        v13 = v16;
        if ((v20 >> (int32_t)&g11 ^ v7 || v7 >> (int32_t)&g24) != 0) {
            if (v5 == 0) {
                int32_t v21 = v7 << (int32_t)&g11; // 0x2ee
                uint32_t v22 = v20 - v21 + (1 << (int32_t)&g11); // 0x2f8
                v10 = v22 << (int32_t)&g24 | v19 / 2;
                v11 = v22 / 2 + v21;
                v12 = v17 / 2 | v16 << (int32_t)&g24;
                v13 = v19 << (int32_t)&g24 | v16 / 2;
            } else {
                int32_t v23 = v7 << (int32_t)&g11;
                if (v9 <= 1) {
                    int32_t result2 = function_66a(v19, (1 << (int32_t)&g11) - v23 + v20, v17, v16, 0, v23 & -1 << (int32_t)&g24, v8); // 0x2a8
                    // 0x2ac
                    return result2;
                }
                uint32_t v24 = 2 * v19; // 0x2ca
                int32_t v25 = 2 * v17; // 0x2d8
                v10 = v24 | v16 >> (int32_t)&g24;
                v11 = v23 - 0x200000 + (2 * ((1 << (int32_t)&g11) - v23 + v20) | (int32_t)(v24 < v19));
                v12 = v25;
                v13 = 2 * v16 | (int32_t)(v25 < v17);
            }
        }
    } else {
        int32_t v26 = 2 * v5; // 0x316
        v10 = result - v5;
        v11 = v6 - (v5 >> (int32_t)&g24) + (int32_t)(result < v5);
        v12 = 1 - v26;
        v13 = (int32_t)(v26 != 0) - (v26 >> (int32_t)&g24);
    }
    // 0x2ac
    return function_650(v10, v11, v12, v13);
}

// Address range: 0x32c - 0x344
int32_t function_32c(int32_t result2, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // 0x32c
    bool v2; // 0x32c
    if (v2) {
        v1 = a2 - (int32_t)&g66;
    }
    int32_t v3; // 0x32c
    if (v2) {
        uint32_t v4 = v3 / 0x8000;
        uint32_t v5 = v4 | v3 << (int32_t)&g3; // 0x330
        __asm_smmlar(v5 - a4, v3, v3);
        int32_t v6 = v1; // 0x338
        if (v5 >> (int32_t)&g24 != 0) {
            // .thread5
            v6 = v1 - 1072;
        }
        int32_t result = (v4 | 0x20000 * v3) - v6;
        __asm_smlaldx(v3, 840, result, v3);
        return result;
    }
    __asm_smmlar(result2, v3, v3);
    if (v2) {
        // branch -> .thread4
    }
    // .thread4
    __asm_smlaldx(v3, 840, result2, v3);
    return result2;
}

// Address range: 0x348 - 0x412
int32_t function_348(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-40, 0x34a
    int32_t v2 = a3; // bp-32, 0x34a
    if (((int32_t)fabsf((float32_t)a2) || a1) == 0 || ((int32_t)fabsf((float32_t)a4) || a3) == 0) {
        // 0x3b4
        return 0;
    }
    int32_t v3 = (a4 ^ a2) & -1 << (int32_t)&g24; // 0x360
    uint32_t v4 = 2 * a2; // 0x382
    uint32_t v5 = 2 * a4; // 0x386
    int32_t v6; // bp-56, 0x348
    int32_t v7 = &v6; // 0x3e6
    int32_t v8 = 0; // 0x3ae
    int32_t v9 = 0; // 0x3ae
    int32_t v10 = 0; // 0x3ae
    while (true) {
      lab_0x3bc:;
        int32_t v11 = v8; // 0x3be
        int32_t v12 = v9; // 0x3be
        int32_t v13 = v10; // 0x3be
        int32_t v14 = v8; // 0x3be
        while (true) {
          lab_0x3c2:;
            int32_t v15 = v14;
            int32_t v16 = v11 - v15; // 0x3c4
            int32_t v17 = v13; // 0x3e2
            int32_t v18 = v15; // 0x3e2
            int32_t v19 = v12; // 0x3e2
            int32_t v20 = v16; // 0x3e2
            int32_t v21 = v12; // 0x3e2
            int32_t v22 = v13; // 0x3e2
            if (v16 <= v15) {
                uint16_t v23 = *(int16_t *)(2 * v18 + (int32_t)&v1); // 0x3ce
                uint16_t v24 = *(int16_t *)(2 * v20 + (int32_t)&v2); // 0x3d2
                uint32_t v25 = (int32_t)v24 * (int32_t)v23; // 0x3d4
                int32_t v26 = v25 + v19; // 0x3d8
                int32_t v27 = v17 + (int32_t)(v26 < v25); // 0x3da
                int32_t v28 = v20 + (int32_t)&g1; // 0x3dc
                v17 = v27;
                v18--;
                v19 = v26;
                v20 = v28;
                v21 = v26;
                v22 = v27;
                while (v28 <= v15) {
                    // 0x3ca
                    v23 = *(int16_t *)(2 * v18 + (int32_t)&v1);
                    v24 = *(int16_t *)(2 * v20 + (int32_t)&v2);
                    v25 = (int32_t)v24 * (int32_t)v23;
                    v26 = v25 + v19;
                    v27 = v17 + (int32_t)(v26 < v25);
                    v28 = v20 + (int32_t)&g1;
                    v17 = v27;
                    v18--;
                    v19 = v26;
                    v20 = v28;
                    v21 = v26;
                    v22 = v27;
                }
            }
            // 0x3e4
            *(int16_t *)((v11 << (int32_t)&g1) + v7) = (int16_t)v21;
            v11 += (int32_t)&g1;
            if (v11 >= (int32_t)&g90) {
                // break (via goto) -> 0x3f8
                goto lab_0x3f8;
            }
            // 0x3b8
            v12 = v22 << (int32_t)&g2 | v21 >> (int32_t)&g2;
            v13 = v22 >> (int32_t)&g2;
            v8 = v11;
            v9 = v12;
            v10 = v13;
            v14 = (int32_t)&g44;
            if (v11 < (int32_t)&g44) {
                goto lab_0x3bc;
            } else {
                goto lab_0x3c2;
            }
        }
    }
  lab_0x3f8:;
    // 0x3f8
    int32_t v29; // 0x348
    int32_t result = function_66a(v29, v29, v6, v29, 0, v3, (v4 >> (int32_t)&g12) - 1011 + (v5 >> (int32_t)&g12)); // 0x40c
    // 0x3b4
    return result;
}

// Address range: 0x418 - 0x502
int32_t function_418(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x418
    if (((int32_t)fabsf((float32_t)a2) || a1) == 0 || ((int32_t)fabsf((float32_t)a4) || a3) == 0) {
        // 0x482
        return 0;
    }
    int32_t v1 = (2 * a2 >> (int32_t)&g12) - (2 * a4 >> (int32_t)&g12); // 0x454
    uint32_t v2 = a2 & 0xffffffff >> (int32_t)&g106 & 0x7fffffff | 1 << (int32_t)&g11; // 0x45c
    uint32_t v3 = a4 & 0xffffffff >> (int32_t)&g106 & 0x7fffffff | 1 << (int32_t)&g11; // 0x45e
    int32_t v4 = a1 < a3 ? -2 : 0;
    int32_t v5; // 0x418
    int32_t v6; // 0x418
    int32_t v7; // 0x418
    if (a1 < a3 ? v3 != -1 || v2 < v2 - v3 + v4 : v2 < v3) {
        int32_t v8 = 2 * a1; // 0x474
        v7 = v1 + 1021;
        v5 = v8;
        v6 = 2 * v2 | (int32_t)(v8 < a1);
    } else {
        // 0x46c
        v7 = v1 + 1022;
        v5 = a1;
        v6 = v2;
    }
    // 0x47a
    if (v7 < 0) {
        // 0x482
        return 0;
    }
    int32_t v9 = 0; // 0x4ba
    int32_t v10 = v5; // 0x4ba
    int32_t v11 = v6; // 0x4ba
    int32_t v12 = 0; // 0x4ba
    if (1 << (int32_t)&g11 != 0) {
        int32_t v13 = 0;
        uint32_t v14 = 0;
        uint32_t v15 = 1 << (int32_t)&g11;
        uint32_t v16 = v5;
        uint32_t v17 = v6;
        int32_t v18 = 0;
        int32_t v19 = v17 - v3 + (int32_t)(v16 < a3); // 0x498
        bool v20 = v16 < a3 ? v3 != -1 | v17 < v19 - (int32_t)(v16 < a3) : v17 < v3; // 0x498
        int32_t v21 = v13; // 0x49a
        int32_t v22 = v16; // 0x49a
        int32_t v23 = v17; // 0x49a
        int32_t v24 = v18; // 0x49a
        if (!v20) {
            // 0x49c
            v21 = v13 | v15;
            v22 = v16 - a3;
            v23 = v19;
            v24 = v14 | v18;
        }
        int32_t v25 = v24;
        int32_t v26 = v21;
        int32_t v27 = v15 / 2; // 0x4ae
        int32_t v28 = v14 / 2 | v15 << (int32_t)&g24; // 0x4b0
        int32_t v29 = 2 * v22; // 0x4b2
        int32_t v30 = 2 * v23 | (int32_t)(v29 < v22); // 0x4b4
        v9 = v26;
        v10 = v29;
        v11 = v30;
        v12 = v25;
        while ((v28 || v27) != 0) {
            // 0x492
            v13 = v26;
            v14 = v28;
            v15 = v27;
            v16 = v29;
            v17 = v30;
            v18 = v25;
            v19 = v17 - v3 + (int32_t)(v16 < a3);
            v20 = v16 < a3 ? v3 != -1 | v17 < v19 - (int32_t)(v16 < a3) : v17 < v3;
            v21 = v13;
            v22 = v16;
            v23 = v17;
            v24 = v18;
            if (!v20) {
                // 0x49c
                v21 = v13 | v15;
                v22 = v16 - a3;
                v23 = v19;
                v24 = v14 | v18;
            }
            // 0x4aa
            v25 = v24;
            v26 = v21;
            v27 = v15 / 2;
            v28 = v14 / 2 | v15 << (int32_t)&g24;
            v29 = 2 * v22;
            v30 = 2 * v23 | (int32_t)(v29 < v22);
            v9 = v26;
            v10 = v29;
            v11 = v30;
            v12 = v25;
        }
    }
    uint32_t v31 = v11;
    int32_t v32 = v10; // 0x4c0
    int32_t v33 = v31; // 0x4c0
    if ((v31 || v10) != 0) {
        // 0x4c2
        v32 = 0;
        v33 = 1 << (int32_t)&g24;
        if (v10 == a3 != (v31 == v3)) {
            int32_t v34 = v10 < a3 ? -2 : 0;
            bool v35 = v10 < a3 ? v3 != -1 | v31 < v31 - v3 + v34 : v31 < v3; // 0x4d2
            v32 = v35 ? 1 : -2;
            v33 = !v35;
        }
    }
    int32_t result = function_650(v12, (v7 << (int32_t)&g11) + ((a4 ^ a2) & -1 << (int32_t)&g24) + v9, v32, v33); // 0x4fc
    // 0x482
    return result;
}

// Address range: 0x508 - 0x520
int32_t function_508(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x508
    return function_66a(a1, 0, 0, 0, 0, 0, 1075);
}

// Address range: 0x524 - 0x556
int32_t function_524(int32_t a1, int32_t a2) {
    int32_t v1 = (uint32_t)(2 * a2) >> (uint32_t)(int32_t)&g12; // 0x534
    if (v1 <= 1022) {
        // 0x53a
        return 0;
    }
    if (v1 > 1075) {
        // 0x54e
        return a1 << v1 - 1075;
    }
    int32_t result = function_608(a1, a2 & 0xffffffff >> (int32_t)&g106 | 1 << (int32_t)&g11, 1075 - v1); // 0x548
    return result;
}

// Address range: 0x560 - 0x586
int32_t function_560(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x560
    return a2 < 0 ? a1 : -a1;
}

// Address range: 0x588 - 0x5e8
int32_t function_588(int32_t a1, int32_t a2, int32_t * a3, uint32_t a4) {
    uint32_t v1 = (int32_t)a3;
    while (true) {
        uint32_t v2 = a2;
        int32_t v3 = v2 - a4;
        int32_t v4 = &g63; // 0x5d6
        while (v4 > 0) {
            // 0x59c
            v4--;
            uint32_t v5 = function_608(a1, v2, v4); // 0x5a4
            int32_t v6 = v5 < v1 ? -2 : 0;
            bool v7 = v5 < v1 ? a4 != -1 | v2 < v6 + v3 : v2 < a4; // 0x5ae
            if (!v7) {
                // break -> 0x5b2
                break;
            }
        }
        return 0;
    }
    // 0x5dc
    int32_t result; // 0x588
    return result;
}

// Address range: 0x5e8 - 0x608
int32_t function_5e8(int32_t a1, int32_t a2, uint32_t a3) {
    if ((int32_t)a3 < (int32_t)&g26) {
        // 0x5f8
        return a1 << a3;
    }
    // 0x5ee
    return 0;
}

// Address range: 0x608 - 0x62a
int32_t function_608(uint32_t a1, uint32_t a2, uint32_t a3) {
    if ((int32_t)a3 < (int32_t)&g26) {
        // 0x618
        return a2 << (int32_t)&g26 - a3 | a1 >> a3;
    }
    // 0x60e
    return a2 >> a3 - (int32_t)&g26;
}

// Address range: 0x62a - 0x650
int32_t function_62a(uint32_t a1, int32_t a2, uint32_t a3) {
    int32_t result; // 0x62a
    if ((int32_t)a3 < (int32_t)&g26) {
        // 0x63e
        result = a2 << (int32_t)&g26 - a3 | a1 >> a3;
    } else {
        // 0x630
        result = a2 >> a3 - (int32_t)&g26;
    }
    // 0x64c
    return result;
}

// Address range: 0x650 - 0x66a
int32_t function_650(int32_t result, int32_t a2, uint32_t a3, int32_t a4) {
    if (a4 >= 0) {
        // 0x668
        return result;
    }
    int32_t v1 = result + 1; // 0x658
    uint32_t v2 = 2 * a3; // 0x65c
    return (2 * a4 | v2 | (int32_t)(v2 < a3)) == 0 ? v1 & -2 : v1;
}

// Address range: 0x66a - 0x70e
int32_t function_66a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1; // 0x66a
    if (a2 == 0) {
        int32_t v2 = function_c710(a1); // 0x67e
        v1 = v2 + (int32_t)&g26;
    } else {
        // 0x676
        v1 = function_c710(a2);
    }
    int32_t result = function_5e8(a1, a2, v1); // 0x68c
    int32_t v3 = a4 | a3;
    if ((v3 || a2 || result) == 0) {
        // 0x6ce
        return result;
    }
    int32_t v4 = result; // 0x6a4
    int32_t v5 = a2; // 0x6a4
    if (v3 != 0) {
        int32_t v6 = function_608(a3, a4, (int32_t)&g63 - v1); // 0x6b0
        uint32_t v7 = (int32_t)((function_5e8(a3, a4, v1) | a4) != 0);
        v4 = v6 | result | v7;
        v5 = a4 | a2 | v7 >> (int32_t)&g24;
    }
    uint32_t v8 = a7 - v1 + (int32_t)&g97; // 0x6f0
    int32_t result2 = 0; // 0x6f2
    if (v8 >= 0) {
        uint32_t v9 = v5 << (int32_t)&g12 | v4 >> (int32_t)&g102; // 0x6ec
        uint32_t v10 = v9 + a5; // 0x704
        result2 = function_650(v10, (v8 << (int32_t)&g11) + a6 + (v5 >> (int32_t)&g102) + (int32_t)(v10 < v9), 0, v4 << (int32_t)&g12);
    }
    // 0x6ce
    return result2;
}

// Address range: 0x710 - 0x746
int32_t function_710(int32_t a1, int32_t a2) {
    int32_t v1 = (uint32_t)(2 * a2) >> (uint32_t)(int32_t)&g12; // 0x720
    if (v1 <= 1022) {
        // 0x726
        return 0;
    }
    int32_t v2 = a2 & 0xffffffff >> (int32_t)&g106 | 1 << (int32_t)&g11; // 0x71a
    if (v1 > 1075) {
        // 0x73c
        return function_5e8(a1, v2, v1 - 1075);
    }
    // 0x734
    return function_608(a1, v2, 1075 - v1);
}

// Address range: 0x750 - 0x76c
int32_t function_750(void) {
    // 0x750
    if (&g123 >= &g124) {
        // 0x768
        int32_t result; // 0x750
        return result;
    }
    int32_t v1 = &g123;
    int32_t v2 = v1 + (int32_t)&g2; // 0x762
    while (v2 < (int32_t)&g124) {
        // 0x758
        v1 = v2;
        v2 = v1 + (int32_t)&g2;
    }
    // 0x768
    return *(int32_t *)v1;
}

// Address range: 0x774 - 0x7ae
int32_t function_774(int32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = (int32_t)*(char *)a1; // 0x778
    int32_t v2 = a1 + (int32_t)&g1; // 0x77a
    int32_t v3 = v1 & 0xffffffff >> (int32_t)&g20; // 0x77e
    int32_t v4 = v2; // 0x780
    int32_t v5 = v3; // 0x780
    if (v3 == 0) {
        // 0x782
        v4 = a1 + 2 * (int32_t)&g1;
        v5 = (int32_t)*(char *)v2;
    }
    int32_t v6 = v4;
    int32_t v7 = v1 >> (int32_t)&g62; // 0x786
    int32_t v8 = v6; // 0x788
    int32_t v9 = v7; // 0x788
    if (v7 == 0) {
        // 0x78a
        v8 = v6 + 1;
        v9 = (int32_t)*(char *)v6;
    }
    int32_t v10 = v5 - 1; // 0x798
    int32_t v11 = v10; // 0x79a
    int32_t v12 = v8; // 0x79a
    int32_t v13 = v8; // 0x79a
    int32_t v14 = a2; // 0x79a
    char v15 = v10; // 0x79a
    int32_t v16; // 0x774
    int32_t v17; // 0x774
    int32_t v18; // 0x794
    int32_t v19; // 0x796
    if (v5 != 1) {
        v16 = v11;
        *(char *)a2 = *(char *)v12;
        v18 = v12 + 1;
        v19 = a2 + 1;
        v11 = v16 - 1;
        v17 = v19;
        v12 = v18;
        v13 = v18;
        v14 = v19;
        v15 = 0;
        while (v16 != 1) {
            // 0x790
            v16 = v11;
            *(char *)v17 = *(char *)v12;
            v18 = v12 + 1;
            v19 = v17 + 1;
            v11 = v16 - 1;
            v17 = v19;
            v12 = v18;
            v13 = v18;
            v14 = v19;
            v15 = 0;
        }
    }
    char v20 = v15;
    int32_t v21 = v9; // 0x7a4
    int32_t v22 = v14; // 0x7a4
    int32_t v23 = v14; // 0x7a4
    int32_t v24; // 0x7a2
    int32_t v25; // 0x7a0
    if (v9 != 1) {
        v24 = v21 - 1;
        *(char *)v22 = v20;
        v25 = v22 + 1;
        v21 = v24;
        v22 = v25;
        v23 = v25;
        while (v24 != 1) {
            // 0x79e
            v24 = v21 - 1;
            *(char *)v22 = v20;
            v25 = v22 + 1;
            v21 = v24;
            v22 = v25;
            v23 = v25;
        }
    }
    // 0x7a6
    while (v23 < (uint32_t)(a3 + a2)) {
        int32_t v26 = v13;
        v1 = (int32_t)*(char *)v26;
        v2 = v26 + (int32_t)&g1;
        v3 = v1 & 0xffffffff >> (int32_t)&g20;
        v4 = v2;
        v5 = v3;
        if (v3 == 0) {
            // 0x782
            v4 = v26 + 2 * (int32_t)&g1;
            v5 = (int32_t)*(char *)v2;
        }
        // 0x786
        v6 = v4;
        v7 = v1 >> (int32_t)&g62;
        v8 = v6;
        v9 = v7;
        if (v7 == 0) {
            // 0x78a
            v8 = v6 + 1;
            v9 = (int32_t)*(char *)v6;
        }
        // 0x798
        v10 = v5 - 1;
        v11 = v10;
        v17 = v23;
        v12 = v8;
        v13 = v8;
        v14 = v23;
        v15 = v10;
        if (v5 != 1) {
            v16 = v11;
            *(char *)v17 = *(char *)v12;
            v18 = v12 + 1;
            v19 = v17 + 1;
            v11 = v16 - 1;
            v17 = v19;
            v12 = v18;
            v13 = v18;
            v14 = v19;
            v15 = 0;
            while (v16 != 1) {
                // 0x790
                v16 = v11;
                *(char *)v17 = *(char *)v12;
                v18 = v12 + 1;
                v19 = v17 + 1;
                v11 = v16 - 1;
                v17 = v19;
                v12 = v18;
                v13 = v18;
                v14 = v19;
                v15 = 0;
            }
        }
        // 0x7a2
        v20 = v15;
        v21 = v9;
        v22 = v14;
        v23 = v14;
        if (v9 != 1) {
            v24 = v21 - 1;
            *(char *)v22 = v20;
            v25 = v22 + 1;
            v21 = v24;
            v22 = v25;
            v23 = v25;
            while (v24 != 1) {
                // 0x79e
                v24 = v21 - 1;
                *(char *)v22 = v20;
                v25 = v22 + 1;
                v21 = v24;
                v22 = v25;
                v23 = v25;
            }
        }
    }
    // 0x7aa
    return 0;
}

// Address range: 0x7b0 - 0x7b8
int32_t function_7b0(int32_t result, int32_t a2) {
    // 0x7b0
    return result;
}

// Address range: 0x7bc - 0x7c4
int32_t function_7bc(int32_t result, int32_t a2) {
    // 0x7bc
    return result;
}

// Address range: 0x7c8 - 0x7d0
int32_t function_7c8(int32_t result, int32_t a2) {
    // 0x7c8
    return result;
}

// Address range: 0x7d4 - 0x7dc
int32_t function_7d4(int32_t result, int32_t a2) {
    // 0x7d4
    return result;
}

// Address range: 0x7e0 - 0x7f0
int32_t function_7e0(void) {
    int32_t result = *(int32_t *)0x400ba000 & (1 << (int32_t)&g19 ^ -1); // 0x7e8
    *(int32_t *)0x400ba000 = result;
    return result;
}

// Address range: 0x7f4 - 0xa2a
int32_t function_7f4(char * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = *(int32_t *)((1 << (int32_t)&g23) + (int32_t)&g90); // 0x7fe
    *(int32_t *)(32 * (1 << (int32_t)&g17) + (int32_t)&g90) = v2 | 1 << (int32_t)&g17;
    function_7e0();
    int32_t v3 = function_c674(); // 0x80e
    int32_t v4; // 0x7f4
    *(int32_t *)((int32_t)&g1 << (int32_t)&g23) = v3 & ((int32_t)&g44 << (int32_t)&g97 ^ -1) | v4 % 256 << (int32_t)&g97;
    int32_t v5 = *(int32_t *)0x400ba000; // 0x82c
    uint16_t v6 = *(int16_t *)(v1 + (int32_t)&g25); // 0x832
    unsigned char v7 = *(char *)(v1 + (int32_t)&g62); // 0x83e
    unsigned char v8 = *(char *)(v1 + (int32_t)&g71); // 0x84e
    unsigned char v9 = *(char *)(v1 + (int32_t)&g90); // 0x85e
    unsigned char v10 = *(char *)(v1 + (int32_t)&g76); // 0x86e
    unsigned char v11 = *(char *)(v1 + (int32_t)&g82); // 0x87c
    unsigned char v12 = *(char *)(v1 + (int32_t)&g95); // 0x88c
    unsigned char v13 = *(char *)(v1 + (int32_t)&g97); // 0x89c
    unsigned char v14 = *(char *)(v1 + (int32_t)&g2); // 0x8aa
    *(int32_t *)0x400ba000 = ((((((((v5 & -1 << (int32_t)&g2 | (int32_t)v6) & (64 * ((int32_t)&g44 << (int32_t)&g97) ^ -1) | (int32_t)v7 << (int32_t)&g2) & (1 << (int32_t)&g7 ^ -1) | (int32_t)v8 << (int32_t)&g7) & ((int32_t)&g82 << (int32_t)&g9 ^ -1) | (int32_t)v9 << (int32_t)&g9) & (1 << (int32_t)&g13 ^ -1) | (int32_t)v10 << (int32_t)&g13) & (2 * (1 << (int32_t)&g13) ^ -1) | (int32_t)v11 << (int32_t)&g14) & ((int32_t)&g82 << (int32_t)&g16 ^ -1) | (int32_t)v12 << (int32_t)&g16) & (1 << (int32_t)&g20 ^ -1) | (int32_t)v13 << (int32_t)&g20) & (2 * (1 << (int32_t)&g20) ^ -1) | (int32_t)v14 << (int32_t)&g21;
    uint16_t v15 = *(int16_t *)(v1 + (int32_t)&g106); // 0x8be
    *(int32_t *)0x400ba0b0 = (int32_t)v15;
    char v16 = *(char *)(v1 + (int32_t)&g121); // 0x8c2
    int32_t v17 = *(int32_t *)0x400ba0f0;
    int32_t v18 = v16 == 1 ? v17 | 2 * (1 << (int32_t)&g20) >> (int32_t)&g111 : v17 & (1 << (int32_t)&g2 ^ -1);
    *(int32_t *)0x400ba0f0 = v18;
    char v19 = *(char *)(v1 + (int32_t)&g126); // 0x8ec
    int32_t v20 = *(int32_t *)0x400ba0f4;
    int32_t v21 = v19 == 1 ? v20 | 1 << (int32_t)&g2 : v20 & (1 << (int32_t)&g2 ^ -1);
    *(int32_t *)0x400ba0f4 = v21;
    *(int32_t *)0x400ba00c = -1;
    int32_t v22 = *(int32_t *)((int32_t)&g90 + 0x400ba000); // 0x922
    int32_t v23 = v1 + (int32_t)&g7; // 0x928
    unsigned char v24 = *(char *)v23; // 0x928
    uint16_t v25 = *(int16_t *)v23; // 0x92e
    int32_t v26 = v25; // 0x93a
    unsigned char v27 = *(char *)(v1 + (int32_t)&g12); // 0x9ec
    unsigned char v28 = *(char *)(v1 + (int32_t)&g11); // 0x9fa
    int32_t v29 = (((int32_t)v24 & 0xffffffff >> (int32_t)&g24 | v22 & -1 << (int32_t)&g2 | (int32_t)(v25 & 2) | v26 & (int32_t)&g62 | v26 & (int32_t)&g90 & -1 << (int32_t)&g44 | v26 & (int32_t)&g2 & -1 << (int32_t)&g62 | v26 & (int32_t)&g26 & -32 | v26 & (int32_t)&g63 & -64 | v26 & (int32_t)&g91 & -1 << (int32_t)&g82 | v26 & 2 * (int32_t)&g91 & -1 << (int32_t)&g90 | v26 & 2 * (int32_t)&g91 << 1 & -1 << (int32_t)&g95 | v26 & 2 * (int32_t)&g91 << 1 << 1 & -1 << (int32_t)&g97 | v26 & 2 * (int32_t)&g91 << 1 << 1 << 1 & -1 << (int32_t)&g102 | v26 & 2 * (int32_t)&g91 << 1 << 1 << 1 << 1 & -1 << (int32_t)&g106 | v26 & 2 * (int32_t)&g91 << 1 << 1 << 1 << 1 << 1 & -1 << (int32_t)&g111 | v26 & 2 * (int32_t)&g91 << 1 << 1 << 1 << 1 << 1 << 1 & -1 << (int32_t)&g121 | v26 & 2 * (int32_t)&g91 << 1 << 1 << 1 << 1 << 1 << 1 << 1 & -1 << (int32_t)&g126) & (2 * (int32_t)&g91 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ^ -1) | (int32_t)v27 << (int32_t)&g2) & (2 * (int32_t)&g91 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ^ -1) | (int32_t)v28 << (int32_t)&g3; // 0x9fe
    *(int32_t *)0x400ba008 = v29;
    int32_t result; // 0x7f4
    if (v29 == 0) {
        // 0xa18
        *(int32_t *)-0x1fff1e80 = 1 << (int32_t)&g62;
        int32_t v30 = __asm_nop((int32_t *)&g62, 1 << (int32_t)&g62, -0x1fff1e80, v4); // 0xa24
        int32_t v31 = __asm_nop((int32_t *)v30, 1 << (int32_t)&g62, -0x1fff1e80, v4); // 0xa26
        result = v31;
    } else {
        // 0xa0a
        *(int32_t *)-0x1fff1f00 = 1 << (int32_t)&g62;
        int32_t v32 = __asm_nop((int32_t *)&g62, 1 << (int32_t)&g62, -0x1fff1f00, v4); // 0xa14
        result = v32;
    }
    // 0xa28
    return result;
}

// Address range: 0xa34 - 0xa4c
int32_t function_a34(int32_t a1) {
    int32_t v1 = function_d02e(a1); // 0xa3a
    return *(int32_t *)((v1 << (int32_t)&g44) + 0x400ba010) % 2;
}

// Address range: 0xa50 - 0xa60
int32_t function_a50(void) {
    int32_t result = *(int32_t *)0x400ba000 | 1 << (int32_t)&g19; // 0xa58
    *(int32_t *)0x400ba000 = result;
    return result;
}

// Address range: 0xa64 - 0xa8c
int32_t function_a64(int32_t * a1) {
    uint32_t v1 = function_d02e((int32_t)a1); // 0xa6c
    int32_t v2 = *(int32_t *)((v1 << (int32_t)&g44) + (int32_t)&g62 + 0x400ba010); // 0xa78
    *(int32_t *)0x400ba00c = 1 << v1;
    return v2 & 0xffffffff >> (int32_t)&g11;
}

// Address range: 0xa90 - 0xaaa
int32_t function_a90(void) {
    int32_t v1 = *(int32_t *)0x400ba004; // 0xa92
    int32_t result = v1 & ((int32_t)&g62 ^ -1) | (int32_t)&g62; // 0xaa2
    *(int32_t *)0x400ba004 = result;
    return result;
}

// Address range: 0xab0 - 0xabe
int32_t function_ab0(void) {
    int32_t result = *(int32_t *)0x400ba004 | 1; // 0xab6
    *(int32_t *)0x400ba004 = result;
    return result;
}

// Address range: 0xac4 - 0xb0a
int32_t function_ac4(int32_t a1, int32_t a2) {
    // 0xac4
    *(int32_t *)0x400bd008 = a1;
    *(int32_t *)0x400bd008 = *(int32_t *)(a1 + (int32_t)&g62);
    *(int32_t *)0x400bd008 = *(int32_t *)(a1 + (int32_t)&g90);
    int32_t v1 = *(int32_t *)(a1 + (int32_t)&g106); // 0xad2
    *(int32_t *)0x400bd008 = v1;
    int32_t result = __asm_nop((int32_t *)a1, a2, v1, 0x400bd000); // 0xad6
    int32_t v2 = *(int32_t *)((int32_t)&g62 + 0x400bd000); // 0xada
    while ((v2 & 0xffffffff >> (int32_t)&g24) == 0) {
        // continue -> 0xad8
    }
    // 0xae4
    *(int32_t *)a2 = *(int32_t *)0x400bd00c;
    *(int32_t *)(a2 + (int32_t)&g62) = *(int32_t *)0x400bd00c;
    *(int32_t *)(a2 + (int32_t)&g90) = *(int32_t *)0x400bd00c;
    *(int32_t *)(a2 + (int32_t)&g106) = *(int32_t *)0x400bd00c;
    int32_t v3 = *(int32_t *)0x400bd000; // 0xafe
    *(int32_t *)0x400bd000 = v3 | (int32_t)&g91;
    return result;
}

// Address range: 0xb10 - 0xb88
int32_t function_b10(int32_t a1) {
    // 0xb10
    *(char *)0x20000aae = 0;
    *(char *)0x20000aaf = 0;
    *(char *)0x20000a9c = 0;
    *(char *)0x20000b22 = 0;
    *(int32_t *)0x200003d0 = 0x20000b2c;
    *(char *)0x20000b55 = 0;
    *(int32_t *)0x20000b3c = 0x20000b2c;
    *(int32_t *)0x20000b40 = 0x20000b34;
    *(char *)0x20000b4b = 0;
    *(char *)0x20000b5c = 0;
    *(char *)0x20000b5b = 0;
    *"\xc9\x03" = 0;
    *"f\x03" = 1;
    *(int32_t *)0x20000388 = function_1ce(a1 + (int32_t)&g62);
    function_bf98(0x40060800, 6);
    *(int32_t *)0x20000a84 = function_154();
    *(int32_t *)0x20000a88 = function_154();
    *(int32_t *)0x20000a8c = function_154();
    *(int32_t *)0x20000a90 = function_154();
    return function_1030();
}

// Address range: 0xba8 - 0xbe2
int32_t function_ba8(int32_t a1) {
    // 0xba8
    *(int32_t *)0x20000388 = function_1ce(a1 + (int32_t)&g62);
    *"\x8c\x03" = (char)&g62;
    function_bf98(0x40060800, 6);
    *(int32_t *)0x20000a84 = function_154();
    *(int32_t *)0x20000a88 = function_154();
    *(int32_t *)0x20000a8c = function_154();
    *(int32_t *)0x20000a90 = function_154();
    return function_1030();
}

// Address range: 0xbf4 - 0xc6c
int32_t function_bf4(void) {
    uint16_t v1 = *(int16_t *)0x20000584; // 0xbfa
    int32_t v2 = v1; // 0xbfa
    int32_t v3 = v2 - 1319; // 0xbfc
    if (v1 == 1319) {
        // 0xc5a
        return function_e94(0x20000584, v2, v3, 1319);
    }
    if (v1 > 1319) {
        // 0xc2c
        switch (v1) {
            case 1321: {
                // 0xc60
                return function_ebc(0x20000584, v2, v3, 1319);
            }
            case 1325: {
                // 0xc66
                return function_c7c(0x20000584, v2, v3, 1319);
            }
            case 1327: {
                // 0xc48
                return function_b10(0x20000584);
            }
            case 1501: {
                // 0xc3c
                return function_7b0(0x20000584, v2);
            }
        }
        // 0xc1c
        return 0x20000584;
    }
    int32_t v4 = v2 - 1309; // 0xc06
    if (v1 == 1309) {
        // 0xc4e
        return function_f64(0x20000584, v2, v4, 1309);
    }
    int32_t result; // 0xbf4
    if (v1 > 1309) {
        // 0xc1e
        result = 0x20000584;
        switch (v1) {
            case 1311: {
                // 0xc54
                return function_d04(0x20000584, v2, v4, 1309);
            }
            case 1313: {
                // 0xc26
                result = function_df8(0x20000584, v2, v4, 1309);
                // break -> 0xc1c
                break;
            }
        }
        // 0xc1c
        return result;
    }
    // 0xc0e
    result = 0x20000584;
    switch (v1) {
        case 1300: {
            // 0xc42
            return function_ba8(0x20000584);
        }
        case 1307: {
            // 0xc18
            result = function_ee4(0x20000584);
            // break -> 0xc1c
            break;
        }
    }
    // 0xc1c
    return result;
}

// Address range: 0xc7c - 0xce4
int32_t function_c7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xc7c
    *"\x8c\x03" = (char)&g62;
    int16_t v1 = 1326; // bp-24, 0xc8a
    int32_t v2 = a1 + (int32_t)&g62; // 0xc94
    if (function_15b0((int32_t)&g114, 0x20000a84, v2) != 0) {
        // 0xcb6
        *"\x85\x03" = -122;
    }
    // 0xcc2
    *"\x85\x03" = (char)&g44;
    *"\x84\x03" = 1;
    return function_be70((int32_t *)&v1, (int32_t *)&g90, v2, a4);
}

// Address range: 0xd04 - 0xdec
int32_t function_d04(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd04
    return 102;
}

// Address range: 0xdf8 - 0xe84
int32_t function_df8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xdf8
    return 102;
}

// Address range: 0xe94 - 0xebc
int32_t function_e94(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // bp-12, 0xe9a
    int32_t v2 = 1320; // bp-16, 0xea2
    int32_t v3; // bp-10, 0xe94
    int32_t v4; // bp-9, 0xe94
    function_a74e(&v1, &v3, &v4, a4);
    int32_t result = function_be70(&v2, (int32_t *)&g90, (int32_t)&v4, a4); // 0xeb6
    return result;
}

// Address range: 0xebc - 0xee0
int32_t function_ebc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-8, 0xebc
    int32_t v2 = 0; // bp-12, 0xec2
    int16_t v3 = 1322; // bp-16, 0xec8
    function_9d7c(&v2, &v1);
    return function_be70((int32_t *)&v3, (int32_t *)&g90, a3, a4);
}

// Address range: 0xee4 - 0xf50
int32_t function_ee4(int32_t a1) {
    int32_t v1 = function_1ce(a1 + (int32_t)&g90); // 0xeec
    int32_t result = v1; // 0xef6
    if (v1 == *(int32_t *)0x20000388) {
        // 0xef8
        *"\x8c\x03" = (char)&g62;
        int16_t v2; // bp-152, 0xee4
        int32_t v3; // 0xee4
        function_1aa((int32_t *)&v2, &g93, v3, v3);
        unsigned char v4 = *(char *)(a1 + (int32_t)&g76); // 0xf06
        v2 = &g73;
        unsigned char v5 = *(char *)(a1 + (int32_t)&g62); // 0xf14
        result = function_be70((int32_t *)&v2, (int32_t *)((int32_t)v4 + (int32_t)&g90), (int32_t)v5, v3);
    }
    // 0xf4c
    return result;
}

// Address range: 0xf64 - 0x1012
int32_t function_f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int16_t v1 = a3; // bp-28, 0xf64
    int32_t v2 = function_1ce(a1 + (int32_t)&g90); // 0xf7c
    int32_t result = v2; // 0xf86
    if (v2 == *(int32_t *)0x20000388) {
        // 0xf88
        *"\x8c\x03" = (char)&g62;
        v1 = 1310;
        unsigned char v3 = *(char *)(a1 + (int32_t)&g62); // 0xfa0
        result = function_be70((int32_t *)&v1, (int32_t *)6, (int32_t)v3, a4);
    }
    // 0x1010
    return result;
}

// Address range: 0x1030 - 0x1076
int32_t function_1030(void) {
    int16_t v1 = 1301; // bp-48, 0x1038
    int32_t v2; // bp-44, 0x1030
    function_178(&v2, "k5_2.01.26");
    int32_t v3; // 0x1030
    int32_t result = function_be70((int32_t *)&v1, &g34, (int32_t)&g2, v3); // 0x106e
    return result;
}

// Address range: 0x108c - 0x109e
int32_t function_108c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x108c
    return function_128(a1 - a3, (int32_t *)a2) * a2 + a3;
}

// Address range: 0x10a0 - 0x1114
int32_t function_10a0(void) {
    int32_t v1 = 64 * (int32_t)*(int16_t *)0x2000046a;
    *(int16_t *)&g4 = (int16_t)v1;
    function_aff4(v1 & 0xffc0, &g5, (char)&g63);
    int32_t v2 = function_afa4(3388, 66); // 0x10ba
    *(int16_t *)&g6 = (int16_t)v2;
    int32_t v3 = 0; // 0x10c6
    int32_t v4 = 2 * v3; // 0x10c8
    uint16_t v5 = *(int16_t *)((v4 & 14) + 0xe198) ^ *(int16_t *)(v4 + 3388);
    v3 = v3 + 1 & (int32_t)&g129;
    *(int16_t *)(v4 + (int32_t)&g25 + 3386) = v5;
    while (v3 < (int32_t)&g28) {
        // 0x10c8
        v4 = 2 * v3;
        v5 = *(int16_t *)((v4 & 14) + 0xe198) ^ *(int16_t *)(v4 + 3388);
        v3 = v3 + 1 & (int32_t)&g129;
        *(int16_t *)(v4 + (int32_t)&g25 + 3386) = v5;
    }
    uint16_t v6 = *(int16_t *)0x2000046a + 1;
    *(int16_t *)0x2000046a = v6;
    int32_t v7 = v6; // 0x10ea
    int32_t v8 = v4 + 3386; // 0x10ea
    if (v6 >= 120) {
        // 0x10ec
        *"f\x04" = 2;
        v7 = 2;
        v8 = (int32_t)"f\x04";
    }
    int32_t v9 = v5; // 0x10d6
    function_1cd8(v7, v8, 0xe198, v9);
    function_a67c(3386, v8, 0xe198, v9);
    function_aad4(0, 0);
    function_a794(1, 0);
    *"h\x04" = (char)&g23;
    return (int32_t)&g23;
}

// Address range: 0x1128 - 0x1164
int32_t function_1128(void) {
    // 0x1128
    *"\x83\x03" = 0;
    function_bf98(0x40061000, (int32_t)&g62);
    *"k\x03" = 0;
    if (*(char *)0x20000acd == 1) {
        // 0x1144
        int32_t v1; // 0x1128
        function_6f60(1, (int32_t)&g62, v1, v1);
        function_6ff8();
    }
    // 0x114c
    *(int16_t *)0x200003b6 = (int16_t)&g72;
    function_d0ec(5);
    function_1ab8(1);
    *"\x99\x03" = 0;
    return (int32_t)"\x99\x03";
}

// Address range: 0x117c - 0x124e
int32_t function_117c(int32_t a1) {
    uint16_t v1 = *(int16_t *)0x20000408; // 0x1182
    uint16_t v2 = *(int16_t *)0x2000040a; // 0x1184
    uint16_t v3 = *(int16_t *)0x2000040c; // 0x118a
    uint16_t v4 = *(int16_t *)0x2000040e; // 0x118c
    uint32_t v5 = (int32_t)v2 + (int32_t)v1 + (int32_t)v3 + (int32_t)v4 << (int32_t)&g2 >> (int32_t)&g7; // 0x119a
    uint32_t v6 = (int32_t)*(int16_t *)0x20000cf4; // 0x11a0
    char v7 = 6; // 0x11a4
    uint16_t v8; // 0x1204
    if (v5 <= (int32_t)*(int16_t *)0x20000cf8) {
        // 0x11aa
        v7 = 5;
        if (v5 <= (int32_t)*(int16_t *)0x20000cf6) {
            // 0x11b4
            v7 = (char)&g62;
            if (v5 <= v6) {
                // 0x11bc
                v7 = (char)&g44;
                if (v5 <= (int32_t)*(int16_t *)0x20000cf2) {
                    // 0x11c6
                    v7 = 2;
                    if (v5 <= (int32_t)*(int16_t *)0x20000cf0) {
                        // 0x11d2
                        if (v5 > (int32_t)*(int16_t *)0x20000cee) {
                            // 0x11d8
                            *"z\x03" = 1;
                        } else {
                            // 0x11dc
                            *"z\x03" = 0;
                        }
                        // 0x11de
                        *(int16_t *)0x20000406 = (int16_t)function_128(760 * v5, (int32_t *)v6);
                        v8 = *(int16_t *)0x20000404;
                        *"}\x03" = (char)(v8 != 500 == v8 >= 500);
                        return 122;
                    }
                }
            }
        }
    }
    // 0x11ce
    *"z\x03" = v7;
    // 0x11de
    *(int16_t *)0x20000406 = (int16_t)function_128(760 * v5, (int32_t *)v6);
    v8 = *(int16_t *)0x20000404;
    *"}\x03" = (char)(v8 != 500 == v8 >= 500);
    return 122;
}

// Address range: 0x1280 - 0x12a0
int32_t function_1280(int32_t a1, int32_t a2) {
    uint16_t v1 = *(int16_t *)(2 * a2 + 0xdfa4); // 0x1288
    int32_t v2 = function_a92c(((int32_t)v1 + (1 << (int32_t)&g102)) % 0x10000); // 0x1292
    return a1 == (int32_t)&g44 ? v2 ^ 0x7fffff : v2;
}

// Address range: 0x12a8 - 0x1386
int32_t function_12a8(int32_t a1) {
    int32_t v1 = *(int32_t *)*(int32_t *)(a1 + (int32_t)&g2); // 0x12b0
    uint32_t v2 = function_139c(v1); // 0x12b2
    unsigned char v3 = *(char *)16; // 0x12bc
    int32_t v4 = a1 + (int32_t)&g26; // 0x12ce
    if (v3 == 0) {
        // 0x1374
        *(char *)v4 = 0;
        *(char *)(a1 + (int32_t)&g26 + (int32_t)&g1) = 127;
        *(char *)(a1 + (int32_t)&g26 + (int32_t)&g25) = -1;
        *(char *)(a1 + (int32_t)&g26 + (int32_t)&g44) = 0;
        *(char *)(a1 + (int32_t)&g26 + (int32_t)&g62) = 127;
        *(char *)(a1 + (int32_t)&g26 + (int32_t)&g71) = -1;
    } else {
        int32_t v5 = v2 >= 2 == (v2 != 2) ? (int32_t)&g126 << (int32_t)&g95 : 0x1e60;
        int32_t v6 = v5 + (int32_t)v3; // 0x12d4
        function_aff4(v6, (int32_t *)v4, 1);
        function_aff4(v6 + 16, (int32_t *)(a1 + (int32_t)&g26 + (int32_t)&g44), 1);
        function_aff4(v6 + 32, (int32_t *)(a1 + (int32_t)&g26 + 1), 1);
        int32_t v7 = a1 + (int32_t)&g26 + (int32_t)&g62; // 0x12fe
        function_aff4(v6 + 48, (int32_t *)v7, 1);
        function_aff4(v6 + 64, (int32_t *)(a1 + (int32_t)&g26 + 2), 1);
        function_aff4(v6 + 80, (int32_t *)(a1 + (int32_t)&g26 + 5), 1);
        char * v8 = (char *)(a1 + (int32_t)&g26 + (int32_t)&g1); // 0x131c
        unsigned char v9 = *v8; // 0x131c
        if (v9 != 127 && v9 >= 127) {
            // 0x1322
            *v8 = 127;
        }
        char * v10 = (char *)v7; // 0x1324
        unsigned char v11 = *v10; // 0x1324
        if (v11 != 127 && v11 >= 127) {
            // 0x132a
            *v10 = 127;
        }
    }
    int32_t * v12 = (int32_t *)(a1 + (int32_t)&g11); // 0x132c
    int32_t v13 = function_139c(*(int32_t *)*v12); // 0x1330
    unsigned char v14 = *(char *)(a1 + (int32_t)&g26 + (int32_t)&g82); // 0x1334
    int32_t v15; // bp-28, 0x12a8
    function_aff4((v13 << (int32_t)&g62) + 0x1ed0 + 3 * (int32_t)v14, &v15, (char)&g44);
    int32_t v16 = v13 << (int32_t)&g25; // 0x1352
    int32_t v17 = *(int32_t *)(v16 + 0xe0ac); // 0x1356
    int32_t v18 = *(int32_t *)(v16 + 0xe090); // 0x1358
    int32_t v19 = *(int32_t *)(v16 + (int32_t)"@KL"); // 0x1360
    char v20; // 0x12a8
    int32_t result = function_1438(v15 % 256, v20, v20, v19, v17, v18, *(int32_t *)*v12); // 0x136a
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g90) = (char)result;
    return result;
}

// Address range: 0x139c - 0x13fe
int32_t function_139c(int32_t a1) {
    uint32_t v1 = a1 - 0x4c4b40; // 0x13a2
    if (v1 >= 0x27ac40 != v1 != 0x27ac40) {
        // 0x13fa
        return 0;
    }
    uint32_t v2 = a1 - 0xa4cb80; // 0x13b0
    if (v2 >= 0x2ab976 != v2 != 0x2ab976) {
        // 0x13fa
        return 1;
    }
    uint32_t v3 = a1 - 0xcf8500; // 0x13be
    if (v3 >= 0x39fbb6 != v3 != 0x39fbb6) {
        // 0x13fa
        return 2;
    }
    uint32_t v4 = a1 - 0x10980c0; // 0x13cc
    if (v4 >= 0x10c8df6 != v4 != 0x10c8df6) {
        // 0x13fa
        return (int32_t)&g44;
    }
    uint32_t v5 = a1 - 0x2160ec0; // 0x13da
    if (v5 >= 0x4c4b36 != v5 != 0x4c4b36) {
        // 0x13fa
        return (int32_t)&g62;
    }
    uint32_t v6 = a1 - 0x2625a00; // 0x13e8
    if (v6 == 0x6acfb6 || v6 < 0x6acfb6) {
        // 0x13fa
        return 5;
    }
    uint32_t v7 = a1 - 0x2cd29c0; // 0x13f0
    return v7 >= 0xc65d40 == (v7 != 0xc65d40) ? 5 : 6;
}

// Address range: 0x1438 - 0x1478
int32_t function_1438(int32_t result, char a2, char a3, uint32_t a4, uint32_t a5, uint32_t a6, uint32_t a7) {
    // 0x1438
    if (a7 >= a4 != a7 != a4) {
        // 0x1448
        return result;
    }
    int32_t result2 = a3;
    if (a7 >= a6) {
        // 0x1448
        return result2;
    }
    int32_t v1 = a2;
    if (a7 >= a5 == (a7 != a5)) {
        // 0x1468
        return function_128((a7 - a5) * (result2 - v1), (int32_t *)(a6 - a5)) + v1;
    }
    // 0x1458
    return function_128((a7 - a4) * (v1 - result), (int32_t *)(a5 - a4)) + result;
}

// Address range: 0x1478 - 0x14c6
int32_t function_1478(uint32_t a1) {
    unsigned char v1 = *(char *)(*(int32_t *)0x200003d0 + 46); // 0x1482
    int32_t v2 = (int32_t)v1 << (int32_t)&g44; // 0x1484
    int32_t v3 = 6; // 0x148c
    if ((int32_t)*(int16_t *)(v2 + 0x20000cbc) >= a1) {
        uint16_t v4 = *(int16_t *)(v2 + (int32_t)&g62 + 0x20000cb6); // 0x1492
        v3 = (int32_t)&g62;
        if ((int32_t)v4 >= a1) {
            // 0x149c
            v3 = 2;
            if ((int32_t)*(int16_t *)(v2 + 0x20000cb8) >= a1) {
                // 0x14a6
                v3 = (int32_t)*(int16_t *)(v2 + 0x20000cb6) < a1;
            }
        }
    }
    unsigned char v5 = *(char *)0x20000a9c; // 0x14b6
    char * v6 = (char *)((int32_t)v5 + 0x20000378); // 0x14b8
    unsigned char v7 = *v6; // 0x14b8
    int32_t result = v3; // 0x14bc
    if (v3 != (int32_t)v7) {
        // 0x14be
        *v6 = (char)v3;
        result = function_84c8(v3, v5, 0x20000378, v7);
    }
    // 0x14c4
    return result;
}

// Address range: 0x14d8 - 0x150a
int32_t function_14d8(int32_t result) {
    int32_t v1 = *(int32_t *)(result + (int32_t)&g16); // 0x14de
    int32_t v2 = result; // 0x14d8
    int32_t v3 = 0x1b7740; // 0x14d8
    switch (*(char *)(result + (int32_t)&g24)) {
        case 1: {
            // 0x14f0
            v2 = v1 + result;
        }
        case 0: {
          lab_0x14f6:;
            int32_t v4 = v2;
            v3 = 0x1b7740;
            if (v4 >= 0x1b7740) {
                // 0x14fe
                v3 = v4 < 0x7bfa480 ? v4 : 0x7bfa480;
            }
            // break -> 0x1506
            break;
        }
        case 2: {
            // 0x14f4
            v2 = result - v1;
            // branch (via goto) -> 0x14f6
            goto lab_0x14f6;
        }
    }
    // 0x1506
    *(int32_t *)(result + (int32_t)&g90) = v3;
    return result;
}

// Address range: 0x1514 - 0x154e
int32_t function_1514(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a3; // bp-24, 0x1514
    int32_t v2 = a4; // bp-20, 0x1514
    int32_t v3 = function_22f8(-59, &v2, &v1); // 0x1520
    int32_t result = v3; // 0x1526
    if (v3 == 0) {
        uint32_t v4 = v2 % 256; // 0x152e
        uint32_t v5 = v1 % 256;
        result = function_1598(v4 == 80 | v4 < 80 ? v5 < 80 ? v5 : 80 : v4, a1, v4, v5);
        *(int32_t *)"P\x04" = result;
    }
    // 0x154c
    return result;
}

// Address range: 0x1558 - 0x1590
int32_t function_1558(int32_t a1, int32_t a2) {
    int32_t v1 = (int32_t)*(int16_t *)(a1 + (int32_t)&g20); // 0x1560
    unsigned char v2 = *(char *)(a1 + (int32_t)&g26 + (int32_t)&g121); // 0x1562
    uint32_t v3 = 2 * a2 * v1; // 0x156c
    int32_t v4 = 4 * (int32_t)v2; // 0x1570
    uint32_t v5 = *(int32_t *)(v4 + *(int32_t *)0x200003f4); // 0x1572
    uint32_t result = *(int32_t *)(*(int32_t *)0x200003f8 + v4); // 0x157a
    if (v5 < v3) {
        // 0x158c
        *(int32_t *)a1 = result;
        return result;
    }
    int32_t result2 = v3; // 0x1584
    if (result != v3 && result >= v3) {
        // 0x1586
        result2 = function_108c(v5, v1, result);
    }
    // 0x158c
    *(int32_t *)a1 = result2;
    return result2;
}

// Address range: 0x1598 - 0x15b0
int32_t function_1598(int32_t a1, int32_t a2, uint32_t a3, uint32_t result) {
    uint32_t v1 = (uint32_t)(a2 + a1) % 256; // 0x159a
    if (v1 == 255) {
        // 0x15a6
        return result;
    }
    if (v1 == a3 || v1 > a3) {
        // 0x15a8
        return v1 > result ? a3 : v1;
    }
    // 0x15a6
    return result;
}

// Address range: 0x15b0 - 0x15ee
int32_t function_15b0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // bp-28, 0x15b8
    function_2074(a1, &v1, a2, &v1, 1);
    int32_t v2 = 0; // 0x15d0
    int32_t v3 = v2 << (int32_t)&g25; // 0x15d2
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&v1); // 0x15d4
    int32_t result = 1; // 0x15da
    while (v4 == *(int32_t *)(v3 + a3)) {
        // 0x15e2
        v2 = v2 + 1 & (int32_t)&g129;
        result = 0;
        if (v2 >= (int32_t)&g62) {
            // break -> 0x15de
            break;
        }
        v3 = v2 << (int32_t)&g25;
        v4 = *(int32_t *)(v3 + (int32_t)&v1);
        result = 1;
    }
    // 0x15de
    return result;
}

// Address range: 0x15f0 - 0x161e
int32_t function_15f0(int32_t a1) {
    int32_t result = 255; // 0x15fa
    int32_t v1 = 0; // 0x15fa
    int32_t v2 = &g47;
    uint16_t v3 = *(int16_t *)(2 * v1 + (int32_t)&g120); // 0x15fe
    int32_t v4 = __asm_sxth(a1 - (int32_t)v3); // 0x1602
    int32_t v5 = v4; // 0x1606
    if (v4 < 0) {
        // 0x1608
        v5 = __asm_sxth(-v4);
    }
    int32_t v6 = v5;
    result = v2 > v6 ? v1 : result;
    int32_t v7 = v2 > v6 ? v6 % 0x10000 : v2;
    v1 = v1 + 1 & (int32_t)&g129;
    while (v1 < (int32_t)&g47) {
        // 0x15fc
        v2 = v7;
        v3 = *(int16_t *)(2 * v1 + (int32_t)&g120);
        v4 = __asm_sxth(a1 - (int32_t)v3);
        v5 = v4;
        if (v4 < 0) {
            // 0x1608
            v5 = __asm_sxth(-v4);
        }
        // 0x160c
        v6 = v5;
        result = v2 > v6 ? v1 : result;
        v7 = v2 > v6 ? v6 % 0x10000 : v2;
        v1 = v1 + 1 & (int32_t)&g129;
    }
    // 0x161c
    return result;
}

// Address range: 0x1624 - 0x1678
int32_t function_1624(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    uint32_t v1 = 0; // 0x1628
    int32_t result; // 0x1624
    int32_t v2; // 0x1624
    int32_t v3; // 0x164c
    uint32_t v4; // 0x165a
    if ((a1 & 3584) == 2048) {
        // 0x1634
        v2 = 0;
        if (a1 % 512 == (int32_t)*(int16_t *)(2 * v2 + 0xdfa4)) {
            // 0x1648
            v3 = function_1280(2, v2);
            result = v2;
            if (v3 == a1) {
                return result;
            }
        }
        // 0x1658
        v4 = (v2 + 1) % 256;
        while (v4 < 104) {
            // 0x163c
            v2 = v4;
            if (a1 % 512 == (int32_t)*(int16_t *)(2 * v2 + 0xdfa4)) {
                // 0x1648
                v3 = function_1280(2, v2);
                result = v2;
                if (v3 == a1) {
                    return result;
                }
            }
            // 0x1658
            v4 = (v2 + 1) % 256;
        }
    }
    uint32_t v5 = a1 / 2; // 0x1660
    int32_t v6 = a1 % 2 == 0 ? v5 : v5 | 1 << (int32_t)&g13;
    v1 = (v1 + 1) % 256;
    result = 255;
    while (v1 < 23) {
        uint32_t v7 = v6;
        if ((v7 & 3584) == 2048) {
            // 0x1634
            v2 = 0;
            if (v7 % 512 == (int32_t)*(int16_t *)(2 * v2 + 0xdfa4)) {
                // 0x1648
                v3 = function_1280(2, v2);
                result = v2;
                if (v3 == v7) {
                    return result;
                }
            }
            // 0x1658
            v4 = (v2 + 1) % 256;
            while (v4 < 104) {
                // 0x163c
                v2 = v4;
                if (v7 % 512 == (int32_t)*(int16_t *)(2 * v2 + 0xdfa4)) {
                    // 0x1648
                    v3 = function_1280(2, v2);
                    result = v2;
                    if (v3 == v7) {
                        return result;
                    }
                }
                // 0x1658
                v4 = (v2 + 1) % 256;
            }
        }
        // 0x1660
        v5 = v7 / 2;
        v6 = v7 % 2 == 0 ? v5 : v5 | 1 << (int32_t)&g13;
        v1 = (v1 + 1) % 256;
        result = 255;
    }
  lab_0x1654:
    // 0x1654
    return result;
}

// Address range: 0x167c - 0x16d6
int32_t function_167c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x167c
    if (function_bfb2(0x40061000, 5) == 1) {
        // 0x16c8
        return 0;
    }
    function_b0b8();
    function_d0ec((int32_t)&g11);
    while (function_bfb2(0x40061000, 5) != 1) {
        // 0x1692
        function_b0b8();
        function_d0ec((int32_t)&g11);
    }
    // 0x16c8
    return 0;
}

// Address range: 0x16e8 - 0x17f8
int32_t function_16e8(void) {
    uint32_t v1 = 0; // 0x170c
    int32_t v2 = 8 * v1; // 0x170e
    int32_t v3; // 0x16e8
    int32_t v4 = function_7bc(v2 + 512, v3); // 0x1718
    int32_t v5 = 4 * v1; // 0x171c
    *(int32_t *)(v5 + 0x20000704) = v4;
    int32_t v6 = function_7bc(v2 + 516, v3); // 0x1728
    v1 = (v1 + 1) % 256;
    *(int32_t *)(v5 + (int32_t)&g63 + 0x20000704) = v6;
    v3 = (int32_t)&g63 + 0x20000704;
    int32_t v7 = (int32_t)&g63 + 0x20000704; // 0x1736
    int32_t v8 = 0; // 0x1736
    while (v1 < 10) {
        // 0x170e
        v2 = 8 * v1;
        v4 = function_7bc(v2 + 512, v3);
        v5 = 4 * v1;
        *(int32_t *)(v5 + 0x20000704) = v4;
        v6 = function_7bc(v2 + 516, v3);
        v1 = (v1 + 1) % 256;
        *(int32_t *)(v5 + (int32_t)&g63 + 0x20000704) = v6;
        v3 = (int32_t)&g63 + 0x20000704;
        v7 = (int32_t)&g63 + 0x20000704;
        v8 = 0;
    }
    int32_t v9 = 4 * v8; // 0x173c
    int32_t v10 = function_7bc(v9 + ((int32_t)&g31 << (int32_t)&g62), v7); // 0x1742
    uint32_t v11 = (v8 + 1) % 256; // 0x174a
    *(int32_t *)(v9 + 0x2000072c) = v10;
    v7 = v9 + 0x20000704;
    v8 = v11;
    while (v11 < 6) {
        // 0x173a
        v9 = 4 * v8;
        v10 = function_7bc(v9 + ((int32_t)&g31 << (int32_t)&g62), v7);
        v11 = (v8 + 1) % 256;
        *(int32_t *)(v9 + 0x2000072c) = v10;
        v7 = v9 + 0x20000704;
        v8 = v11;
    }
    // 0x1752
    function_af60((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 40);
    *(int32_t *)((int32_t)&g63 + 0x2000072c) = 0x7f20187d;
    *(int32_t *)((int32_t)&g63 + 0x20000730) = -0x11be2ef2;
    int32_t v12 = *(int32_t *)((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 40); // 0x176c
    *(int32_t *)((int32_t)&g63 + 0x20000734) = v12;
    int32_t v13 = *(int32_t *)((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 48); // 0x1772
    *(int32_t *)((int32_t)&g63 + 0x20000738) = v13;
    *(int32_t *)((int32_t)&g63 + 0x2000073c) = 0x2e294da3;
    *(int32_t *)((int32_t)&g63 + 0x20000740) = 0x71a8f284;
    int32_t v14 = *(int32_t *)((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 44); // 0x1784
    *(int32_t *)((int32_t)&g63 + 0x20000744) = v14;
    int32_t v15 = *(int32_t *)((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 52); // 0x178a
    *(int32_t *)((int32_t)&g63 + 0x20000748) = v15;
    int32_t v16 = 0; // 0x178e
    int32_t v17 = v16 * (int32_t)&g11; // 0x1794
    int32_t v18 = 16 * v16; // 0x1798
    int32_t v19 = *(int32_t *)(v18 + 0x20000704); // 0x179c
    int32_t v20 = *(int32_t *)(v18 + 0x20000708); // 0x179c
    int32_t v21 = *(int32_t *)(v18 + 0x2000070c); // 0x179c
    int32_t v22 = *(int32_t *)(v18 + 0x20000710); // 0x179c
    *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2) = v19;
    *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 4) = v20;
    *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 8) = v21;
    *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 12) = v22;
    int32_t v23 = *(int32_t *)(4 * v16 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 40); // 0x17a4
    v16 = v16 + 1 & (int32_t)&g129;
    *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 16) = v23;
    while (v16 < (int32_t)&g62) {
        // 0x1790
        v17 = v16 * (int32_t)&g11;
        v18 = 16 * v16;
        v19 = *(int32_t *)(v18 + 0x20000704);
        v20 = *(int32_t *)(v18 + 0x20000708);
        v21 = *(int32_t *)(v18 + 0x2000070c);
        v22 = *(int32_t *)(v18 + 0x20000710);
        *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2) = v19;
        *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 4) = v20;
        *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 8) = v21;
        *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 12) = v22;
        v23 = *(int32_t *)(4 * v16 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72 + 40);
        v16 = v16 + 1 & (int32_t)&g129;
        *(int32_t *)(v17 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + 16) = v23;
    }
    // 0x17ae
    function_2074((int32_t)&g63 + 0x2000072c, (int32_t *)((int32_t)&g63 + 0x2000073c), (int32_t)&g63 + 0x2000073c + (int32_t)&g2, (int32_t *)((int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72), 5);
    int32_t v24 = 0; // 0x17c0
    int32_t v25 = v24 << (int32_t)&g25; // 0x17ca
    int32_t v26 = *(int32_t *)(v25 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72); // 0x17cc
    int32_t v27 = *(int32_t *)(4 * ((int32_t)&g9 - v24) + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72); // 0x17ce
    int32_t v28 = v27 ^ v26; // 0x17d0
    *(int32_t *)(v25 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72) = v28;
    int32_t result = 0; // 0x17dc
    char v29 = 0; // 0x17dc
    while (v28 == *(int32_t *)(v25 + (int32_t)&g63 + 0x20000704)) {
        // 0x17e4
        v24 = v24 + 1 & (int32_t)&g129;
        result = 1;
        v29 = 1;
        if (v24 >= (int32_t)&g97) {
            // break -> 0x17ee
            break;
        }
        v25 = v24 << (int32_t)&g25;
        v26 = *(int32_t *)(v25 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72);
        v27 = *(int32_t *)(4 * ((int32_t)&g9 - v24) + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72);
        v28 = v27 ^ v26;
        *(int32_t *)(v25 + (int32_t)&g63 + 0x2000073c + (int32_t)&g2 + (int32_t)&g72 + (int32_t)&g72) = v28;
        result = 0;
        v29 = 0;
    }
    // 0x17ee
    *"t\x03" = v29;
    return result;
}

// Address range: 0x1804 - 0x1810
int32_t function_1804(int32_t a1) {
    // 0x1804
    int32_t v1; // 0x1804
    return function_18cc(v1, v1, v1, v1);
}

// Address range: 0x1810 - 0x1830
int32_t function_1810(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1810
    int32_t result; // 0x1810
    bool v1; // 0x1810
    if (v1) {
        function_bf60d4();
        int32_t v2 = function_b9b844(); // 0x1818
        __asm_cdpmi(12, 2, 4, 15, 14, 1);
        result = v2;
    } else {
        // 0x181c
        result = v1 ? a1 : a3;
    }
    if (v1 || false) {
        int32_t v3; // 0x1810
        if ((v3 & a2 << (int32_t)&g11) >= 0) {
            return result;
        }
        __asm_svcmi(0x2f4d2e);
        return result;
    }
    if (!v1) {
        return result;
    }
    __asm_svcmi(0x2f4d2e);
    return result;
}

// Address range: 0x1830 - 0x18cc
int32_t function_1830(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1830
    int32_t v1; // 0x1830
    uint32_t v2 = v1;
    if (a3 == (int32_t)&g62) {
        uint32_t v3 = a2 - 0xcf8500; // 0x187c
        int32_t v4 = a1; // 0x1880
        if (v3 == 0x39fbb6 || v3 < 0x39fbb6) {
            v4 = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
        }
        uint32_t v5 = a2 - 0x2625a00; // 0x1882
        int32_t result = v4; // 0x1886
        if (v5 == v2 || v5 < v2) {
            result = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
        }
        // 0x1888
        return result;
    }
    uint32_t v6 = a2 - 0xcf8500;
    bool v7 = v6 == 0x39fbb6 | v6 < 0x39fbb6;
    int32_t result2; // 0x1830
    if (a3 == 5) {
        int32_t v8 = a1; // 0x188e
        if (v7) {
            v8 = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
        }
        uint32_t v9 = a2 - 0x2625a00; // 0x1890
        result2 = v8;
        if (v9 == 0x39fbb6 || v9 < 0x39fbb6) {
            int32_t v10 = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x1894
            result2 = v10;
        }
    } else {
        int32_t v11 = a1; // 0x1842
        if (v7) {
            v11 = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
        }
        uint32_t v12 = a2 - 0x2625a00; // 0x18a2
        result2 = v11;
        if (v12 == 0x6acfb6 || v12 < 0x6acfb6) {
            int32_t v13 = function_18cc((int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x18a6
            result2 = v13;
        }
    }
    // 0x1888
    return result2;
}

// Address range: 0x18cc - 0x18d0
int32_t function_18cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x18cc
    return 0;
}

// Address range: 0x18d2 - 0x18e6
int32_t function_18d2(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = a1; // 0x18d2
    bool v1; // 0x18d2
    if (v1) {
        *(int32_t *)a1 = a3;
        result = 0;
    }
    if (v1) {
        // 0x18da
        __asm_svcle(0x40002d);
        return result;
    }
    int32_t result3 = function_1dc156e(); // 0x18de
    int32_t result2; // 0x18d2
    return result2;
    // 0x18da
    __asm_svcle(0x40002d);
    return result3;
}

// Address range: 0x1928 - 0x1970
int32_t function_1928(uint32_t a1, int32_t a2, int32_t a3) {
    if (a1 >= (uint32_t)(int32_t)&g108) {
        // 0x1968
        return 0;
    }
    int32_t v1 = (int32_t)*(char *)(a1 + 0x20000bb4); // 0x1930
    if ((v1 & 0xffffffff >> (int32_t)&g20) >= 7) {
        // 0x1968
        return 0;
    }
    // 0x193a
    if (a2 != 1) {
        // 0x1968
        return 1;
    }
    // 0x193e
    char * v2; // 0x1928
    switch (a3) {
        case 0: {
            if ((v1 & 128) == 0) {
                // 0x1968
                return 0;
            }
            // 0x194e
            v2 = (char *)0x20000ab8;
            if ((int32_t)*(char *)0x20000ab6 == a1) {
                // 0x1968
                return 0;
            }
            // break -> 0x1964
            break;
        }
        case 1: {
            if ((v1 & 64) == 0) {
                // 0x1968
                return 0;
            }
            // 0x195c
            v2 = (char *)0x20000ab9;
            if ((int32_t)*(char *)0x20000ab7 == a1) {
                // 0x1968
                return 0;
            }
            // break -> 0x1964
            break;
        }
        default: {
            // 0x1968
            return 1;
        }
    }
    // 0x1964
    if ((int32_t)*v2 == a1) {
        // 0x1968
        return 0;
    }
    // 0x1968
    return 1;
}

// Address range: 0x1978 - 0x1998
int32_t function_1978(uint32_t a1) {
    int32_t result = 0; // 0x197a
    if (a1 < (int32_t)&g11) {
        // 0x197c
        result = (int32_t)*(int16_t *)(2 * a1 + 0x20000c8e) < 1081;
    }
    // 0x1990
    return result;
}

// Address range: 0x199c - 0x1a3a
int32_t function_199c(int32_t a1) {
    // 0x199c
    int32_t v1; // bp-32, 0x199c
    int32_t v2 = &v1; // 0x19a4
    function_19c(v2, (int32_t)&g90, 255);
    uint32_t v3 = (int32_t)&g17 << (int32_t)&g82; // 0x19b6
    int32_t result; // 0x199c
    uint32_t v4; // 0x199c
    while (true) {
      lab_0x19b8:
        // 0x19b8
        v4 = v3;
        int32_t v5 = v4 - 3808; // 0x19b8
        result = v5;
        if (v5 < 56) {
            goto lab_0x1a30;
        } else {
            int32_t v6 = v4 - 3888; // 0x19c2
            result = v6;
            if (v6 < 32) {
                goto lab_0x1a30;
            } else {
                int32_t v7 = v4 - ((int32_t)&g82 << (int32_t)&g97); // 0x19ce
                result = v7;
                if (v7 >> (int32_t)&g95 == 0) {
                    goto lab_0x1a30;
                } else {
                    int32_t v8 = v4 - 3760; // 0x19da
                    result = v8;
                    if (v8 < 32) {
                        goto lab_0x1a30;
                    } else {
                        int32_t v9 = v4 - 3744; // 0x19e4
                        result = v9;
                        if (v9 < 8) {
                            goto lab_0x1a30;
                        } else {
                            if (a1 == 1) {
                                // 0x1a28
                                result = function_b02a(v4, v2);
                                goto lab_0x1a30;
                            } else {
                                // 0x19f0
                                result = a1;
                                if (v4 < (int32_t)&g17 << (int32_t)&g82) {
                                    goto lab_0x1a30;
                                } else {
                                    int32_t v10 = v4 - 3424; // 0x19f8
                                    result = v10;
                                    if (v10 < 200) {
                                        goto lab_0x1a30;
                                    } else {
                                        int32_t v11 = v4 - 3864; // 0x1a00
                                        result = v11;
                                        if (v11 < 24) {
                                            goto lab_0x1a30;
                                        } else {
                                            int32_t v12 = v4 - 3920; // 0x1a0c
                                            result = v12;
                                            if (v12 < 3248) {
                                                goto lab_0x1a30;
                                            } else {
                                                int32_t v13 = v4 - 3648; // 0x1a18
                                                result = v13;
                                                if (v13 < 48) {
                                                    goto lab_0x1a30;
                                                } else {
                                                    int32_t v14 = v4 - 3720; // 0x1a22
                                                    result = v14;
                                                    if (v14 < 8) {
                                                        goto lab_0x1a30;
                                                    } else {
                                                        // 0x1a28
                                                        result = function_b02a(v4, v2);
                                                        goto lab_0x1a30;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x1a38
    return result;
  lab_0x1a30:
    // 0x1a30
    v3 = (v4 + 8) % 0x10000;
    if (v3 >= (int32_t)&g126 << (int32_t)&g95) {
        return result;
    }
    goto lab_0x19b8;
}

// Address range: 0x1a40 - 0x1a60
int32_t function_1a40(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1a40
    int32_t v1; // 0x1a40
    int32_t v2 = v1;
    bool v3; // 0x1a40
    if (v3) {
        __asm_rscshs(0x1a48, 124, 10);
    }
    bool v4; // 0x1a40
    if (v3) {
        *(char *)v1 = (char)a3;
        v4 = (2 * v1 & 1 << (int32_t)&g24) != 0;
    }
    int32_t v5 = unknown_fea3fa4a(); // 0x1a48
    bool v6; // 0x1a40
    bool v7; // 0x1a40
    bool v8; // 0x1a40
    bool v9; // 0x1a40
    int32_t v10; // 0x1a40
    int32_t v11; // 0x1a40
    if (v3) {
        uint32_t v12 = (v1 >> (int32_t)&g44) - v5; // 0x1a50
        int32_t v13 = v12 - (int32_t)((v1 & 4) == 0); // 0x1a50
        v9 = v12 % 2 != 0;
        v7 = (v1 & 4) == 0;
        v11 = v13;
        v8 = v12 % 2 != 0;
        v6 = (v1 & 4) == 0;
        v10 = v13;
        if (v13 < 0) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_dec_label_pc_unknown_2;
        }
    } else {
        v11 = v5;
        v10 = v5;
        if (v3) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_dec_label_pc_unknown_2;
        }
    }
  lab_dec_label_pc_unknown:
    *(char *)(v4 ? v2 - 1024 : v2) = (char)a2;
    v8 = v9;
    v6 = v7;
    v10 = v11;
    goto lab_dec_label_pc_unknown_2;
  lab_dec_label_pc_unknown_2:;
    int32_t result = unknown_ff9fda84(v10); // 0x1a58
    if (v8 < v6) {
        __asm_rsclt(v1, 100, 24);
    }
    return result;
}

// Address range: 0x1a60 - 0x1a70
int32_t function_1a60(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x1a60
    return function_19c(0x20000c8e, (int32_t)&g34, 255);
}

// Address range: 0x1a74 - 0x1aa0
int32_t function_1a74(void) {
    // 0x1a74
    *"\x8d\x03" = 0;
    *"\x90\x03" = 0;
    *(int16_t *)0x2000038e = 0;
    function_bf98(0x40061000, (int32_t)&g62);
    *"k\x03" = 0;
    int32_t v1; // 0x1a74
    function_a1ac(0, 0, v1, v1);
    *"o\x03" = 1;
    return 1;
}

// Address range: 0x1ab8 - 0x1c82
int32_t function_1ab8(int32_t a1) {
    int32_t v1 = *(int32_t *)0x200003d0; // 0x1abe
    function_bf98(0x40061000, (int32_t)&g62);
    *"k\x03" = 0;
    function_a794(6, 0);
    int32_t v2 = v1 + 32; // 0x1ad8
    function_aa48((int32_t)(*(char *)(v1 + 43) != 0));
    function_a794(5, 0);
    function_aad4(0, 0);
    function_a794(1, 0);
    int32_t v3 = function_a960((int32_t *)&g106); // 0x1b00
    while (v3 << (int32_t)&g24 != 0) {
        // 0x1b0a
        function_af00((int32_t *)2, 0);
        function_d0ec(1);
        if ((v3 + 0xffff) % 0x10000 == 0) {
            // break -> 0x1b20
            break;
        }
        v3 = function_a960((int32_t *)&g106);
    }
    // 0x1b20
    function_af00(&g61, 0);
    function_af00((int32_t *)125, (int32_t)*(char *)0x20000ad6 | 0xe940);
    int32_t v4 = *(int32_t *)*(int32_t *)(v1 + 16); // 0x1b46
    function_aabc(v4);
    unsigned char v5 = *(char *)(v1 + 37); // 0x1b4e
    unsigned char v6 = *(char *)(v1 + 34); // 0x1b50
    char v7 = *(char *)(v1 + 36); // 0x1b56
    char v8 = *(char *)(v1 + 33); // 0x1b58
    char v9 = *(char *)(v1 + 35); // 0x1b5a
    function_a9b8(*(char *)v2, v9, v8, v7, (int32_t)v6, (int32_t)v5);
    function_1e0c(v4);
    function_a794(0, 1);
    char v10 = *(char *)(v1 + 51); // 0x1b70
    function_af00(&g69, 0xb3a8);
    int32_t v11; // 0x1ab8
    if (*(char *)(v1 + 30) < 207) {
        // 0x1b98
        v11 = (int32_t)&g106;
        if (v10 != 1) {
            // 0x1bc2
            function_ab00(function_aa78(670));
            char v12 = *(char *)(v1 + 42); // 0x1bce
            if (v12 == 0) {
                // 0x1c04
                function_a5dc();
                v11 = 1036;
            } else {
                // 0x1bdc
                function_a550((int32_t)(v12 - 1));
                v11 = 1036;
            }
        }
    } else {
        // 0x1b82
        function_aa78(2625);
        v11 = &g109;
    }
    // 0x1c08
    char v13; // 0x1ab8
    int32_t v14; // 0x1ab8
    if (*(char *)(0x20000ae7 - (int32_t)&g63) == 1) {
        int32_t v15 = *(int32_t *)0x200003d4; // 0x1c1e
        if (*(char *)(v15 + 30) < 207) {
            // 0x1c26
            if (*(char *)(v15 + 51) == 1) {
                goto lab_0x1c3a;
            } else {
                int16_t v16 = *(int16_t *)(0x20000afe - (int32_t)&g63); // 0x1c2e
                int16_t v17 = *(int16_t *)(0x20000afc - (int32_t)&g63); // 0x1c30
                v13 = function_a584(v17, v16);
                v14 = v11 | (int32_t)&g45;
                goto lab_0x1c40;
            }
        } else {
            goto lab_0x1c3a;
        }
    } else {
        goto lab_0x1c3a;
    }
  lab_0x1c3a:
    // 0x1c3a
    v13 = function_a600();
    v14 = v11 & ((int32_t)&g45 ^ -1);
    goto lab_0x1c40;
  lab_0x1c40:;
    char v18 = v13; // 0x1c42
    int32_t v19; // 0x1ab8
    if (v10 == 1) {
        goto lab_0x1c52;
    } else {
        // 0x1c44
        v18 = -32;
        if (*(char *)(v1 + 47) == 1) {
            // 0x1c74
            function_a4fc();
            v19 = v14 | 1 << (int32_t)&g102;
            goto lab_0x1c5c;
        } else {
            goto lab_0x1c52;
        }
    }
  lab_0x1c52:
    // 0x1c52
    function_a5d0(v18);
    v19 = v14 & 0xf7ff;
    goto lab_0x1c5c;
  lab_0x1c5c:
    // 0x1c5c
    function_af00(&g61, v19);
    function_6904();
    int32_t result = a1; // 0x1c6a
    if (a1 == 1) {
        // 0x1c6c
        result = function_78bc(0);
    }
    // 0x1c72
    return result;
}

// Address range: 0x1cd8 - 0x1d6c
int32_t function_1cd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = *(int32_t *)0x200003d4; // 0x1cdc
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g11); // 0x1ce6
    unsigned char v3 = *(char *)(v2 + (int32_t)&g62); // 0x1cea
    int32_t v4 = (int32_t)*(char *)(v2 + (int32_t)&g71); // 0x1cec
    int32_t v5 = *(int32_t *)v2; // 0x1cee
    function_bf98(0x40061000, (int32_t)&g62);
    *"k\x03" = 0;
    function_a794(0, 0);
    function_aa48((int32_t)(*(char *)(v1 + 43) != 0));
    function_aabc(v5);
    function_ae4c();
    function_d0ec((int32_t)&g97);
    function_1e0c(v5);
    function_a794(1, 1);
    function_d0ec(5);
    function_aad4((int32_t)*(char *)(v1 + 40), v5);
    int32_t v6 = function_d0ec((int32_t)&g97); // 0x1d3c
    if (v3 == 1) {
        uint16_t v7 = *(int16_t *)(2 * v4 + (int32_t)&g120); // 0x1d56
        return function_aa78((int32_t)v7);
    }
    int32_t v8 = v3; // 0x1cea
    if (v3 == 2 || v8 == (int32_t)&g44) {
        // 0x1d5e
        return function_aa10(function_1280(v8, v4));
    }
    // 0x1d4c
    return function_a5f8(v6);
}

// Address range: 0x1d7c - 0x1dd2
int32_t function_1d7c(void) {
    char v1 = *(char *)0x20000aaf; // 0x1d82
    char v2; // 0x1d7c
    switch (v1) {
        case 2: {
            // 0x1d9a
            *(char *)0x20000a9d = 1;
            v2 = 1;
            goto lab_0x1da0;
        }
        case 1: {
            // 0x1d9e
            *(char *)0x20000a9d = 0;
            v2 = 0;
            goto lab_0x1da0;
        }
        default: {
            // 0x1d8e
            switch (*(char *)0x20000aae) {
                case 2: {
                    // 0x1d9a
                    *(char *)0x20000a9d = 1;
                    v2 = 1;
                    goto lab_0x1da0;
                }
                case 1: {
                    // 0x1d9e
                    *(char *)0x20000a9d = 0;
                    v2 = 0;
                    goto lab_0x1da0;
                }
                default: {
                    // 0x1d8e
                    v2 = *(char *)0x20000a9d;
                    goto lab_0x1da0;
                }
            }
        }
    }
  lab_0x1da0:;
    int32_t v3 = v2; // 0x1da0
    *(int32_t *)0x200003cc = v3 * (int32_t)&g67 + 0x20000b2c;
    int32_t v4 = v1 == 0 ? v3 : (int32_t)(v2 == 0);
    *(char *)0x20000a9c = (char)v4;
    *(int32_t *)0x200003d0 = v4 * (int32_t)&g67 + 0x20000b2c;
    return function_1de0();
}

// Address range: 0x1de0 - 0x1dfe
int32_t function_1de0(void) {
    // 0x1de0
    int32_t result; // 0x1de0
    if (*(char *)0x20000aaf == 0) {
        // 0x1df6
        result = *(int32_t *)0x200003d0;
    } else {
        unsigned char v1 = *(char *)0x20000a9d; // 0x1dea
        result = (int32_t)v1 * (int32_t)&g67 + 0x20000b2c;
    }
    // 0x1dfa
    *(int32_t *)0x200003d4 = result;
    return result;
}

// Address range: 0x1e0c - 0x1e36
int32_t function_1e0c(uint32_t a1) {
    int32_t v1 = 1; // 0x1e12
    if (a1 >= 0x1ab3f00) {
        // 0x1e18
        v1 = 0;
        if (a1 != -1) {
            // 0x1e20
            function_a794((int32_t)&g62, 0);
            return function_a794((int32_t)&g44, 1);
        }
    }
    // 0x1e20
    function_a794((int32_t)&g62, v1);
    return function_a794((int32_t)&g44, 0);
}

// Address range: 0x1e3c - 0x1e64
int32_t function_1e3c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4) {
    uint32_t v1 = 0; // 0x1e44
    int32_t v2 = (int32_t)&g82; // 0x1e44
    int32_t result = function_128(a1, (int32_t *)&g97); // 0x1e48
    *(char *)(v2 + (int32_t)a2) = (char)(a1 - result * (int32_t)&g97);
    v1 = (v1 + 1) % 256;
    v2 = v2 - 1 & (int32_t)&g129;
    while (v1 < 8) {
        int32_t v3 = result;
        result = function_128(v3, (int32_t *)&g97);
        *(char *)(v2 + (int32_t)a2) = (char)(v3 - result * (int32_t)&g97);
        v1 = (v1 + 1) % 256;
        v2 = v2 - 1 & (int32_t)&g129;
    }
    // 0x1e62
    return result;
}

// Address range: 0x1e64 - 0x1e8c
int32_t function_1e64(int32_t a1, int32_t * a2, int32_t a3, int32_t a4) {
    int32_t result = 0x989680; // 0x1e6e
    int32_t v1 = 0; // 0x1e6e
    int32_t v2 = 0; // 0x1e6e
    uint32_t v3 = (int32_t)*(char *)(v1 + a1); // 0x1e70
    while (v3 < (int32_t)&g97) {
        // 0x1e76
        v2 += result * v3;
        result = function_128(result, (int32_t *)&g97);
        v1 = v1 + 1 & (int32_t)&g129;
        if (v1 >= (int32_t)&g90) {
            // break -> 0x1e88
            break;
        }
        v3 = (int32_t)*(char *)(v1 + a1);
    }
    // 0x1e88
    *a2 = v2;
    return result;
}

// Address range: 0x1e90 - 0x1eb4
int32_t function_1e90(int32_t a1, char a2) {
    // 0x1e90
    if (a2 == 0) {
        // 0x1ea8
        return 0;
    }
    int32_t v1 = 0; // 0x1ea6
    int32_t result = 1; // 0x1e9e
    while (*(char *)0x20000b15 != *(char *)(v1 + a1)) {
        // 0x1ea0
        v1 = v1 + 1 & (int32_t)&g129;
        result = 0;
        if (v1 >= (uint32_t)(int32_t)a2) {
            // break -> 0x1ea8
            break;
        }
        result = 1;
    }
    // 0x1ea8
    return result;
}

// Address range: 0x1eb8 - 0x1efe
int32_t function_1eb8(char * a1, uint32_t a2) {
    int32_t v1 = (int32_t)a1;
    if ((char)v1 < 1) {
        // 0x1ee8
        return 0;
    }
    // 0x1ef6
    if (a2 == 0) {
        // 0x1ee8
        return 1;
    }
    int32_t v2 = 0; // 0x1ef8
    char * v3 = (char *)(v2 + v1); // 0x1ec8
    unsigned char v4 = *v3; // 0x1ec8
    while (v4 >= 1) {
        int32_t v5 = v4; // 0x1ec8
        uint32_t v6 = v5 - (int32_t)&g45; // 0x1ed4
        if (v6 != (int32_t)&g95 && v6 >= (int32_t)&g95) {
            uint32_t v7 = v6 - (int32_t)&g3; // 0x1eda
            if (v5 != (int32_t)&g29 && v5 != (int32_t)&g35 && v7 != (int32_t)&g44 && v7 >= (int32_t)&g44) {
                // 0x1ee8
                return 0;
            }
        }
        // 0x1ef2
        v2 = v2 + (int32_t)&g1 & (int32_t)&g129;
        if (v2 >= a2) {
            // 0x1ee8
            return 1;
        }
        v3 = (char *)(v2 + v1);
        v4 = *v3;
    }
    // 0x1eec
    *v3 = 0;
    // 0x1ee8
    return 1;
}

// Address range: 0x1f00 - 0x1f34
int32_t function_1f00(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4) {
    // 0x1f00
    if (a3 == NULL) {
        // 0x1f2c
        return 1;
    }
    int32_t v1 = 0; // 0x1f26
    char v2 = *(char *)(v1 + a1); // 0x1f0e
    if (v2 != *(char *)(v1 + (int32_t)a2)) {
        // 0x1f16
        if (a4 == 1 != (v2 == *(char *)0x20000b15)) {
            // break -> 0x1f2c
            break;
        }
        // 0x1f20
        *"9\x04" = 1;
    }
    // 0x1f24
    v1 = v1 + (int32_t)&g1 & (int32_t)&g129;
    int32_t result = 1; // 0x1f2a
    while (v1 < (int32_t)a3) {
        // 0x1f0e
        v2 = *(char *)(v1 + a1);
        if (v2 != *(char *)(v1 + (int32_t)a2)) {
            // 0x1f16
            result = 0;
            if (a4 == 1 != (v2 == *(char *)0x20000b15)) {
                // break -> 0x1f2c
                break;
            }
            // 0x1f20
            *"9\x04" = 1;
        }
        // 0x1f24
        v1 = v1 + (int32_t)&g1 & (int32_t)&g129;
        result = 1;
    }
    // 0x1f2c
    return result;
}

// Address range: 0x1f3c - 0x1f5e
int32_t function_1f3c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1f3c
    function_c73e(255, a1, a3, a1);
    return 65;
}

// Address range: 0x1f5e - 0x1f62
int32_t function_1f5e(void) {
    // 0x1f5e
    return function_20001388();
}

// Address range: 0x1f62 - 0x1f66
int32_t function_1f62(void) {
    // 0x1f62
    return function_20001388();
}

// Address range: 0x1f66 - 0x1f6a
int32_t function_1f66(void) {
    // 0x1f66
    return function_20001388();
}

// Address range: 0x1f6a - 0x1f6e
int32_t function_1f6a(void) {
    // 0x1f6a
    return function_20001388();
}

// Address range: 0x1f6e - 0x1f72
int32_t function_1f6e(void) {
    // 0x1f6e
    return function_20001388();
}

// Address range: 0x1f72 - 0x1f78
int32_t function_1f72(int32_t a1, int32_t a2) {
    // 0x1f72
    return function_20001388();
}

// Address range: 0x1f78 - 0x1fc8
int32_t function_1f78(int32_t a1, int32_t * a2) {
    // 0x1f78
    int32_t v1; // bp-40, 0x1f78
    int32_t v2 = (int32_t)&v1 + (int32_t)&g90;
    uint32_t v3 = 0; // 0x1f82
    int32_t v4 = function_1fc8(v3, &v1); // 0x1f88
    int32_t result = 0; // 0x1f8e
    while (v4 == 1) {
        int32_t v5 = 0;
        int32_t v6 = v5; // 0x1f9a
        while (*(char *)(v5 + a1) == *(char *)(v2 + v5)) {
            int32_t v7 = v5 + 1 & (int32_t)&g129; // 0x1f9e
            v6 = v7;
            if (v7 >= (int32_t)&g44) {
                // break -> 0x1fa4
                break;
            }
            v5 = v7;
            v6 = v5;
        }
        // 0x1fa4
        if (v6 == (int32_t)&g44) {
            // 0x1fb6
            function_178(a2, (char *)&v1);
            *(char *)((int32_t)a2 + (int32_t)&g90) = 0;
            result = 1;
            return result;
        }
        // 0x1fa8
        v3 = (v3 + 1) % 256;
        result = 0;
        if (v3 >= 16) {
            // break -> 0x1fb2
            break;
        }
        v4 = function_1fc8(v3, &v1);
        result = 0;
    }
  lab_0x1fb2:
    // 0x1fb2
    return result;
}

// Address range: 0x1fc8 - 0x1fec
int32_t function_1fc8(int32_t a1, int32_t * a2) {
    // 0x1fc8
    function_aff4((a1 << (int32_t)&g62) + ((int32_t)&g82 << (int32_t)&g97), a2, (char)&g2);
    int32_t v1; // 0x1fc8
    return (uint32_t)v1 % 256 - (int32_t)&g26 < 95;
}

// Address range: 0x1fec - 0x2004
int32_t function_1fec(void) {
    // 0x1fec
    int32_t v1; // 0x1fec
    function_7b74(v1, v1, v1, v1);
    function_d0ec((int32_t)&g108);
    function_6ff8();
    return function_1ab8(1);
}

// Address range: 0x2004 - 0x2040
int32_t function_2004(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    uint32_t v1 = 0; // 0x200c
    uint32_t v2 = a1;
    int32_t v3 = v2 == 255 ? 199 : v2 < 200 ? v2 : 0;
    int32_t v4 = function_1928(v3, a3, a4); // 0x201e
    int32_t result = v3; // 0x2024
    while (v4 != 1) {
        // 0x2026
        v1 = (v1 + 1) % 256;
        result = 255;
        if (v1 >= 200) {
            // break -> 0x2034
            break;
        }
        v2 = (v3 + a2) % 256;
        v3 = v2 == 255 ? 199 : v2 < 200 ? v2 : 0;
        v4 = function_1928(v3, a3, a4);
        result = v3;
    }
    // 0x2034
    return result;
}

// Address range: 0x2040 - 0x2074
int32_t function_2040(char a1, int32_t a2) {
    uint32_t v1 = 0; // 0x2046
    uint32_t v2 = (int32_t)a1;
    int32_t v3 = v2 < 20 ? v2 : 0;
    int32_t v4 = v2 == 255 ? (int32_t)&g9 : v3;
    int32_t v5 = function_1978(v4); // 0x2054
    int32_t result = v4; // 0x205a
    while (v5 != 1) {
        // 0x205c
        v1 = (v1 + 1) % 256;
        result = 255;
        if (v1 >= 20) {
            // break -> 0x2068
            break;
        }
        v2 = (v4 + a2) % 256;
        v3 = v2 < 20 ? v2 : 0;
        v4 = v2 == 255 ? (int32_t)&g9 : v3;
        v5 = function_1978(v4);
        result = v4;
    }
    // 0x2068
    return result;
}

// Address range: 0x2074 - 0x209e
int32_t function_2074(int32_t a1, int32_t * a2, int32_t a3, int32_t * a4, uint32_t a5) {
    uint32_t v1 = 0; // 0x209a
    int32_t result = function_9e08(0, a1, (int32_t)a2); // 0x209a
    if (a5 == 0) {
        // 0x209c
        return result;
    }
    int32_t v2 = 16 * v1; // 0x208a
    v1 = (v1 + 1) % 256;
    result = function_ac4(v2 + a3, v2 + (int32_t)a4);
    while (v1 < a5) {
        // 0x208a
        v2 = 16 * v1;
        v1 = (v1 + 1) % 256;
        result = function_ac4(v2 + a3, v2 + (int32_t)a4);
    }
    // 0x209c
    return result;
}

// Address range: 0x20a0 - 0x20d4
int32_t function_20a0(void) {
    // 0x20a0
    *(int16_t *)0x20000ac4 = *(int16_t *)0x20000ac0;
    if (*(char *)0x20000ac3 != 1) {
        // 0x20c8
        return 0;
    }
    int32_t v1 = function_2040(*(char *)0x20000ac2, 1); // 0x20b6
    if (v1 == 255) {
        // 0x20cc
        *(char *)0x20000ac3 = 0;
        return -1;
    }
    // 0x20be
    *(char *)0x20000ac2 = (char)v1;
    *(int16_t *)0x20000ac4 = *(int16_t *)(2 * v1 + 0x20000c8e);
    // 0x20c8
    return 0;
}

// Address range: 0x20dc - 0x2106
int32_t function_20dc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x20dc
    return result;
}

// Address range: 0x2110 - 0x2136
int32_t function_2110(int32_t result) {
    // 0x2110
    return result;
}

// Address range: 0x2140 - 0x21aa
int32_t function_2140(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = *(int32_t *)0x200003cc; // 0x2154
    int32_t v2 = function_c73e(0x20000a94, v1, v1 + 32, 197); // 0x2166
    *(char *)17 = 20;
    int32_t v3 = (int32_t)*(char *)33; // 0x2176
    *(char *)((int32_t)&g30 + 0x20000450) = 16;
    uint16_t v4 = *(int16_t *)74; // 0x2182
    *(char *)(v3 + (int32_t)&g97) = -59;
    int32_t v5 = __asm_adr(648); // 0x2188
    int32_t v6 = *(int32_t *)(v5 + v3); // 0x2190
    int32_t v7; // bp+652, 0x2140
    unsigned char v8 = *(char *)(v5 + (int32_t)&v7); // 0x2192
    *(int32_t *)((int32_t)v4 + (int32_t)&g67) = v3;
    *(char *)((int32_t)v8 + (int32_t)&g18) = (char)v4;
    int32_t v9; // bp+636, 0x2140
    *(int32_t *)(v6 + (int32_t)&v9) = *(int32_t *)0x20000454;
    char v10 = *(char *)(v2 + (int32_t)&g2); // 0x21a6
    int32_t result = function_22be(v10, v5, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x21a8
    return result;
}

// Address range: 0x21aa - 0x2214
int32_t function_21aa(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x21aa
    int32_t v1; // 0x21aa
    int32_t v2 = (int32_t)*(int64_t *)&v1;
    v1 = v2 + a1;
    int32_t v3; // 0x21aa
    if ((0x20000000 * a1 & 1 << (int32_t)&g24) != 0) {
        *(int32_t *)(a2 - (int32_t)&g26) = a1;
        *(int32_t *)(a2 - (int32_t)&g16) = (a1 << (int32_t)&g23) + a4;
        *(int32_t *)(a2 - (int32_t)&g90) = (int32_t)&v3;
    }
    int32_t v4 = a1; // 0x21ba
    bool v5; // 0x21aa
    int32_t v6; // 0x21aa
    if (!v5) {
        // .critedge
        __asm_stcvc(1, 13, *(int32_t *)(a1 - 152));
        v4 = function_ff43a262();
        __asm_svcvc(0x40e07c);
        __asm_mcrvc(0, 4, v6, 0, 10, 3);
        __asm_mcrvc(0, 6, v6, 0, 8, 3);
        __asm_stcvc(0, 14, *(int32_t *)(v4 + (int32_t)&g22));
        __asm_mcrrvc(0, 7, v6, v4, 4);
        *(int32_t *)(v2 - (int32_t)&g20) = a2;
        *(int32_t *)(v2 - (int32_t)&g16) = v4;
        *(int32_t *)(v2 - (int32_t)&g11) = v4;
        *(int32_t *)(v2 - (int32_t)&g2) = a4;
        *(int32_t *)(v2 - (int32_t)&g106) = (int32_t)&v3;
        *(int32_t *)(v2 - (int32_t)&g62) = 0x21f0;
    }
    bool v7 = v5 | false; // 0x21ee
    if (v7) {
        __asm_mrsle(v6);
    }
    int32_t v8 = v4; // 0x21f2
    if (!v5) {
        v8 = function_23c1d6();
    }
    // 0x21f6
    if (v7) {
        __asm_mrsle(v6);
    }
    int32_t v9 = v8; // 0x2202
    if (!v5) {
        v9 = function_23a37a();
    }
    // 0x2206
    if (v9 != 1) {
        int32_t result = function_22be(0, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x220c
        return result;
    }
    char v10 = *(char *)(a2 + (int32_t)&g111); // 0x220e
    int32_t result2 = function_22be(v10 + 1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2212
    return result2;
}

// Address range: 0x2214 - 0x2218
int32_t function_2214(int32_t a1) {
    char v1 = *(char *)(a1 + (int32_t)&g12); // 0x2214
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2216
    return result;
}

// Address range: 0x2218 - 0x221c
int32_t function_2218(void) {
    // 0x2218
    int32_t v1; // 0x2218
    char v2 = *(char *)(v1 + (int32_t)&g121); // 0x2218
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x221a
    return result;
}

// Address range: 0x221c - 0x2220
int32_t function_221c(void) {
    // 0x221c
    int32_t v1; // 0x221c
    char v2 = *(char *)(v1 + (int32_t)&g25); // 0x221c
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x221e
    return result;
}

// Address range: 0x2220 - 0x2224
int32_t function_2220(void) {
    // 0x2220
    int32_t v1; // 0x2220
    char v2 = *(char *)(v1 + (int32_t)&g44); // 0x2220
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2222
    return result;
}

// Address range: 0x2224 - 0x222e
int32_t function_2224(void) {
    // 0x2224
    int32_t v1; // 0x2224
    uint16_t v2 = *(int16_t *)(v1 + (int32_t)&g62); // 0x2224
    int32_t v3 = function_128((int32_t)v2, (int32_t *)&g97); // 0x2228
    int32_t result = function_22be((char)v3, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x222c
    return result;
}

// Address range: 0x222e - 0x2232
int32_t function_222e(int32_t a1, int32_t a2, int32_t a3) {
    char v1 = *(char *)(a3 + (int32_t)&g2); // 0x222e
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2230
    return result;
}

// Address range: 0x2232 - 0x2236
int32_t function_2232(int32_t a1, int32_t a2, int32_t a3) {
    char v1 = *(char *)(a3 + (int32_t)&g126); // 0x2232
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2234
    return result;
}

// Address range: 0x2236 - 0x223a
int32_t function_2236(int32_t a1) {
    char v1 = *(char *)(a1 + (int32_t)&g23); // 0x2236
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2238
    return result;
}

// Address range: 0x223a - 0x223e
int32_t function_223a(int32_t a1) {
    char v1 = *(char *)(a1 + (int32_t)&g14); // 0x223a
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x223c
    return result;
}

// Address range: 0x223e - 0x2242
int32_t function_223e(int32_t a1, int32_t a2, int32_t a3) {
    char v1 = *(char *)(a3 + (int32_t)&g3); // 0x223e
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2240
    return result;
}

// Address range: 0x2242 - 0x2246
int32_t function_2242(void) {
    // 0x2242
    int32_t v1; // 0x2242
    char v2 = *(char *)(v1 + (int32_t)&g16); // 0x2242
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2244
    return result;
}

// Address range: 0x2246 - 0x224a
int32_t function_2246(int32_t a1, int32_t a2) {
    char v1 = *(char *)(a2 + (int32_t)&g24); // 0x2246
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2248
    return result;
}

// Address range: 0x224a - 0x224e
int32_t function_224a(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a2 + (int32_t)&g16); // 0x224a
    int32_t result = function_22be((char)v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x224c
    return result;
}

// Address range: 0x224e - 0x2252
int32_t function_224e(int32_t a1) {
    char v1 = *(char *)(a1 + (int32_t)&g16); // 0x224e
    int32_t result = function_22be(v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2250
    return result;
}

// Address range: 0x2252 - 0x2256
int32_t function_2252(void) {
    // 0x2252
    int32_t v1; // 0x2252
    char v2 = *(char *)(v1 + (int32_t)&g17); // 0x2252
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2254
    return result;
}

// Address range: 0x2256 - 0x225a
int32_t function_2256(void) {
    // 0x2256
    int32_t v1; // 0x2256
    char v2 = *(char *)(v1 + (int32_t)&g18); // 0x2256
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2258
    return result;
}

// Address range: 0x225a - 0x225e
int32_t function_225a(void) {
    // 0x225a
    int32_t v1; // 0x225a
    char v2 = *(char *)(v1 + (int32_t)&g19); // 0x225a
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x225c
    return result;
}

// Address range: 0x225e - 0x2262
int32_t function_225e(void) {
    // 0x225e
    int32_t v1; // 0x225e
    char v2 = *(char *)(v1 + (int32_t)&g20); // 0x225e
    int32_t result = function_22be(v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2260
    return result;
}

// Address range: 0x2262 - 0x2266
int32_t function_2262(int32_t a1) {
    int32_t result = function_22be((char)a1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2264
    return result;
}

// Address range: 0x2266 - 0x2270
int32_t function_2266(int32_t a1) {
    // 0x2266
    return function_2274();
}

// Address range: 0x2270 - 0x2274
int32_t function_2270(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2270
    return result;
}

// Address range: 0x2274 - 0x227a
int32_t function_2274(void) {
    // 0x2274
    int32_t v1; // 0x2274
    int32_t v2 = function_2004(v1, v1, v1, v1); // 0x2274
    int32_t result = function_22be((char)v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2278
    return result;
}

// Address range: 0x227a - 0x2286
int32_t function_227a(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2282
    bool v1; // 0x227a
    if (!v1) {
        result = function_fe43c266();
    }
    // 0x2286
    return result;
}

// Address range: 0x228c - 0x22bc
int32_t function_228c(int32_t a1, int32_t a2, int32_t result, int32_t a4) {
    // 0x228c
    int32_t v1; // 0x228c
    int32_t v2 = result << v1 & a1; // 0x2290
    bool v3; // 0x228c
    if (!v3) {
        *(int32_t *)a1 = a2;
        *(int32_t *)(a1 - (int32_t)&g62) = v2;
    }
    int32_t v4 = v1 & a1 >> v1; // 0x228c
    if (v4 < 0) {
        return result;
    }
    if (!v3) {
        *(int32_t *)a1 = a1;
        *(int32_t *)(a1 - (int32_t)&g106) = 0x22b0;
    }
    if ((0x8000 * a1 & 1 << (int32_t)&g24) == 0 || v4 == 0) {
        *(int32_t *)a2 = a1;
        *(int32_t *)(a2 - (int32_t)&g62) = a2;
        *(int32_t *)(a2 - (int32_t)&g90) = result;
        int32_t v5; // 0x228c
        *(int32_t *)(a2 - (int32_t)&g106) = (int32_t)&v5;
        *(int32_t *)(a2 - (int32_t)&g11) = 0x22b4;
    }
    *(int32_t *)(v1 + (a1 >> (int32_t)&g24)) = v2 & a1 >> (int32_t)&g3;
    return v1 * a1;
}

// Address range: 0x22be - 0x22c2
int32_t function_22be(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t result = a1;
    int32_t v1; // 0x22be
    *(int32_t *)v1 = result;
    return result;
}

// Address range: 0x22c2 - 0x22c6
int32_t function_22c2(void) {
    // 0x22c2
    return 0x200003de;
}

// Address range: 0x22c6 - 0x22ca
int32_t function_22c6(void) {
    // 0x22c6
    return 0x200003df;
}

// Address range: 0x22f8 - 0x2342
int32_t function_22f8(char a1, int32_t * a2, int32_t * a3) {
    // 0x22f8
    int32_t v1; // 0x22f8
    uint32_t v2 = v1;
    int32_t v3 = v1;
    int32_t v4 = (int32_t)a3;
    int32_t v5 = a1;
    function_c73e(v5, (int32_t)a2, v4, v5);
    *(int16_t *)(v1 + v3) = (int16_t)v3;
    int32_t v6 = (v4 >> v2) + v2; // 0x230c
    int32_t v7 = 2 * v1; // 0x2320
    *(int16_t *)(v7 + v2) = (int16_t)v6 + (int16_t)((int32_t)&g37 + (int32_t)&g47 + (int32_t)&g47);
    *(int16_t *)(v6 + (int32_t)&g37 + (int32_t)&g47 + (int32_t)&g47 + 0x7005) = (int16_t)a1;
    *(int16_t *)(v7 + 0x7005) = 0x7005;
    int32_t result = function_239e((int32_t *)&g95, v1, v6 + (int32_t)&g37 + (int32_t)&g47 + (int32_t)&g47 + (int32_t)&g56 + (int32_t)&g47 + (int32_t)&g67 + (int32_t)&g47 + (int32_t)&g47, 0); // 0x2340
    return result;
}

// Address range: 0x2342 - 0x235a
int32_t function_2342(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2342
    int32_t v1; // 0x2342
    bool v2; // 0x2342
    if (v2) {
        *(int32_t *)a1 = a2;
        *(int32_t *)(a1 - (int32_t)&g62) = a4;
        v1 = a1;
    } else {
        // .critedge
        v1 = function_fe00e3ce();
    }
    // 0x234a
    if (v1 == 1) {
        // 0x2354
        return function_239e((int32_t *)6, a2, a3, 0);
    }
    // 0x234e
    return function_239e((int32_t *)5, a2, a3, 0);
}

// Address range: 0x235a - 0x235e
int32_t function_235a(void) {
    // 0x235a
    return function_239c();
}

// Address range: 0x235e - 0x2364
int32_t function_235e(void) {
    // 0x235e
    int32_t v1; // 0x235e
    return function_239e((int32_t *)&g62, v1, v1, 0);
}

// Address range: 0x2364 - 0x236a
int32_t function_2364(void) {
    // 0x2364
    int32_t v1; // 0x2364
    return function_239e((int32_t *)1, v1, v1, 0);
}

// Address range: 0x236a - 0x2370
int32_t function_236a(void) {
    // 0x236a
    int32_t v1; // 0x236a
    return function_239e(&g112, v1, v1, 0);
}

// Address range: 0x2370 - 0x2376
int32_t function_2370(void) {
    // 0x2370
    int32_t v1; // 0x2370
    return function_239e(&g47, v1, v1, 0);
}

// Address range: 0x2376 - 0x237c
int32_t function_2376(void) {
    // 0x2376
    int32_t v1; // 0x2376
    return function_239e((int32_t *)&g44, v1, v1, 0);
}

// Address range: 0x237c - 0x2382
int32_t function_237c(void) {
    // 0x237c
    int32_t v1; // 0x237c
    return function_239e((int32_t *)99, v1, v1, (int32_t)&g44);
}

// Address range: 0x2382 - 0x2388
int32_t function_2382(void) {
    // 0x2382
    int32_t v1; // 0x2382
    return function_239e((int32_t *)&g97, v1, v1, 0);
}

// Address range: 0x2388 - 0x238e
int32_t function_2388(void) {
    // 0x2388
    int32_t v1; // 0x2388
    return function_239e((int32_t *)199, v1, v1, 0);
}

// Address range: 0x238e - 0x2394
int32_t function_238e(void) {
    // 0x238e
    int32_t v1; // 0x238e
    return function_239e(&g58, v1, v1, 5);
}

// Address range: 0x2394 - 0x239a
int32_t function_2394(void) {
    // 0x2394
    int32_t v1; // 0x2394
    return function_239e((int32_t *)&g2, v1, v1, 1);
}

// Address range: 0x239c - 0x239e
int32_t function_239c(void) {
    // 0x239c
    return 2;
}

// Address range: 0x239e - 0x23a6
int32_t function_239e(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x239e
    *(char *)a2 = (char)a4;
    *(char *)a3 = (char)(int32_t)a1;
    return 0;
}

// Address range: 0x23a6 - 0x23ac
int32_t function_23a6(void) {
    // 0x23a6
    return function_20001388();
}

// Address range: 0x23b0 - 0x2522
int32_t function_23b0(char a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = function_a960((int32_t *)&g106); // 0x23be
    if (v1 << (int32_t)&g24 == 0) {
        // 0x2520
        return 0;
    }
    function_af00((int32_t *)2, 0);
    int32_t v2 = function_a960((int32_t *)2); // 0x23d0
    unsigned char v3; // 0x23f2
    int32_t v4; // 0x23f8
    int32_t v5; // 0x2402
    if (v2 << (int32_t)&g11 < 0) {
        // 0x23da
        *"\xaa\x03" = 1;
        *"B\x04" = 5;
        v4 = 0;
        v3 = *(char *)(v4 + 3341);
        *(char *)(v4 + 3340) = v3;
        v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
        while (v4 < (int32_t)&g126) {
            // 0x23f0
            v3 = *(char *)(v4 + 3341);
            *(char *)(v4 + 3340) = v3;
            v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
        }
        // 0x23fe
        *"/\x04" = (char)&g126;
        v5 = function_a72e((int32_t *)&g126);
        *(char *)3387 = (char)function_1f3c(v5, 3340, (int32_t)v3);
        *"/\x04" = 48;
    }
    if (v2 << (int32_t)&g12 < 0) {
        // 0x2426
        *"\xae\x03" = 1;
    }
    if (v2 << (int32_t)&g14 < 0) {
        // 0x242e
        *"\xab\x03" = 1;
        *"\xac\x03" = (char)function_a710((int32_t)"\xab\x03");
    }
    if (v2 << (int32_t)&g13 < 0) {
        // 0x243e
        *"\xab\x03" = 0;
    }
    if (v2 << (int32_t)&g17 < 0 || v2 << (int32_t)&g16 < 0) {
        *"\xad\x03" = (char)(v2 << (int32_t)&g16 >= 0);
    }
    if (v2 << (int32_t)&g19 < 0) {
        // 0x245a
        *"\xaf\x03" = 1;
        *(int16_t *)0x200003b8 = (int16_t)&g97;
    }
    if (v2 << (int32_t)&g18 < 0) {
        // 0x24b0
        *"\xaf\x03" = 0;
        *(int16_t *)0x200003b8 = 0;
    }
    if (v2 << (int32_t)&g21 < 0) {
        // 0x24c2
        *"\xb0\x03" = 1;
        function_a794(6, 1);
    }
    if (v2 << (int32_t)&g20 < 0) {
        // 0x24d2
        *"\xb0\x03" = 0;
        function_a794(6, 0);
    }
    while (function_a960((int32_t *)&g106) << (int32_t)&g24 != 0) {
        // 0x23c6
        function_af00((int32_t *)2, 0);
        v2 = function_a960((int32_t *)2);
        if (v2 << (int32_t)&g11 < 0) {
            // 0x23da
            *"\xaa\x03" = 1;
            *"B\x04" = 5;
            v4 = 0;
            v3 = *(char *)(v4 + 3341);
            *(char *)(v4 + 3340) = v3;
            v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
            while (v4 < (int32_t)&g126) {
                // 0x23f0
                v3 = *(char *)(v4 + 3341);
                *(char *)(v4 + 3340) = v3;
                v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
            }
            // 0x23fe
            *"/\x04" = (char)&g126;
            v5 = function_a72e((int32_t *)&g126);
            *(char *)3387 = (char)function_1f3c(v5, 3340, (int32_t)v3);
            *"/\x04" = 48;
        }
        if (v2 << (int32_t)&g12 < 0) {
            // 0x2426
            *"\xae\x03" = 1;
        }
        if (v2 << (int32_t)&g14 < 0) {
            // 0x242e
            *"\xab\x03" = 1;
            *"\xac\x03" = (char)function_a710((int32_t)"\xab\x03");
        }
        if (v2 << (int32_t)&g13 < 0) {
            // 0x243e
            *"\xab\x03" = 0;
        }
        if (v2 << (int32_t)&g17 < 0 || v2 << (int32_t)&g16 < 0) {
            *"\xad\x03" = (char)(v2 << (int32_t)&g16 >= 0);
        }
        if (v2 << (int32_t)&g19 < 0) {
            // 0x245a
            *"\xaf\x03" = 1;
            *(int16_t *)0x200003b8 = (int16_t)&g97;
        }
        if (v2 << (int32_t)&g18 < 0) {
            // 0x24b0
            *"\xaf\x03" = 0;
            *(int16_t *)0x200003b8 = 0;
        }
        if (v2 << (int32_t)&g21 < 0) {
            // 0x24c2
            *"\xb0\x03" = 1;
            function_a794(6, 1);
        }
        if (v2 << (int32_t)&g20 < 0) {
            // 0x24d2
            *"\xb0\x03" = 0;
            function_a794(6, 0);
        }
    }
    // 0x2520
    return 0;
}

// Address range: 0x2580 - 0x2ae8
int32_t function_2580(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    unsigned char v1 = *(char *)(*(int32_t *)0x200003cc + 30); // 0x258c
    *(int16_t *)0x2000032e = 1000;
    int32_t v2 = 0x2000032e; // 0x25b4
    if (*(char *)0x20000acc == 1) {
        // 0x25b6
        *"l\x03" = (char)&g23;
        v2 = (int32_t)"l\x03";
    }
    char v3; // 0x2580
    int32_t v4; // 0x2580
    int32_t v5; // 0x2580
    if (a2 == 0) {
        // 0x25da
        int32_t v6; // 0x2580
        function_6b88(-91, v2, a3, v6);
        *"\xa5\x03" = 0;
        function_6d10(-90, v2, a3, v6);
        *"\xa6\x03" = 0;
        function_6cb0(-88, v2, a3, v6);
        *"\xa8\x03" = 0;
        int32_t v7 = *(int32_t *)0x200003cc; // 0x2618
        function_6bcc((int32_t)v1, *(char *)0x20000a9d, v7, -89);
        *"\xa7\x03" = 0;
        function_5f5c(*(char *)0x20000a9d, 1);
        function_1ab8(1);
        function_782c(0);
        v3 = 1;
        v4 = v7;
        v5 = 167;
    } else {
        if (a1 != (int32_t *)&g12) {
            // 0x25c6
            *"\x93\x03" = (char)&g2;
        }
        // 0x25cc
        function_5960();
        v3 = -63;
        v4 = a3;
    }
    char v8 = *(char *)(0x20000ac6 - (int32_t)&g26); // 0x2656
    if (a1 == (int32_t *)&g12 || v8 != 1) {
        goto lab_0x269a;
    } else {
        if (a1 == (int32_t *)&g126) {
            if (a3 == 1) {
                // 0x2696
                if (a2 != 1) {
                    // 0x268e
                    return 216;
                }
                goto lab_0x269a;
            } else {
                goto lab_0x2674;
            }
        } else {
            if (a1 == (int32_t *)&g14 || a1 == (int32_t *)&g13) {
                goto lab_0x269a;
            } else {
                goto lab_0x2674;
            }
        }
    }
  lab_0x269a:;
    int32_t result; // 0x2580
    if (a1 != (int32_t *)&g121 && a1 != (int32_t *)&g111 && a1 != (int32_t *)&g106 && a1 != (int32_t *)&g12 && a1 != (int32_t *)&g102) {
        // 0x26d6
        result = 128;
        if (a2 == 1 == a3 == 0) {
            // 0x26de
            result = function_59d8(2, v3, v4, v5);
        }
        // 0x268e
        return result;
    }
    int32_t v9; // 0x2580
    int32_t v10; // 0x2580
    int32_t v11; // 0x2580
    if (a1 == (int32_t *)&g14 || a1 == (int32_t *)&g13) {
        // 0x2870
        function_43dc((int32_t)a1, a2, a3);
        v9 = a2;
        v10 = a3;
        v11 = v5;
    } else {
        int32_t v12 = function_c73e(217, 103, v4, 217); // 0x2782
        *(int16_t *)(v12 + (int32_t)&g16) = (int16_t)a2;
        v9 = (int32_t)*(int16_t *)163;
        v10 = v4;
        v11 = a4;
        if (a2 == 1 == a3 == 0) {
            // 0x279e
            function_1128();
            char v13 = *(char *)((int32_t)&g20 + 0x20000ab4); // 0x27a4
            if (v13 == 0) {
                // 0x27b4
                function_78bc(0);
            } else {
                // 0x27aa
                *"m\x03" = v13 * (char)&g97;
            }
            int32_t v14 = a1 == (int32_t *)&g12 ? (int32_t)"\x95\x03" : (int32_t)"\x94\x03";
            *(char *)v14 = 1;
            v9 = v14;
            v10 = v4;
            v11 = a4;
        }
    }
    // 0x28ce
    function_59d8(150, (char)v9, v10, v11);
    *"\x96\x03" = 0;
    if (a3 == 0) {
        // 0x29fc
        function_6d10(-98, v9, v10, v11);
        *"\x9e\x03" = 0;
        *"o\x03" = 1;
        function_6cb0(-97, (int32_t)"o\x03", v10, v11);
        *"\x9f\x03" = 0;
        function_6b88(-100, (int32_t)"o\x03", v10, v11);
        *"\x9c\x03" = 0;
        int32_t v15 = *(int32_t *)0x200003cc; // 0x2a02
        unsigned char v16 = *(char *)(v15 + 30); // 0x2a04
        function_6bcc((int32_t)v16, *(char *)0x20000a9d, v15, -99);
        *"\x9a\x03" = 1;
    } else {
        // 0x2948
        *"\xa6\x03" = 1;
        *"\x9e\x03" = 0;
        *"o\x03" = 1;
        *"\xa8\x03" = -97;
        *"\x9f\x03" = 0;
        *"\xa5\x03" = 1;
        *"\x9c\x03" = 0;
        *"\xa7\x03" = -99;
    }
    // 0x2a1c
    *"\x9d\x03" = 0;
    function_5f5c(*(char *)0x20000a9d, 154);
    *"\x98\x03" = 1;
    *"\x9a\x03" = 0;
    *"\x9b\x03" = 0;
    function_1d7c();
    function_7690();
    function_1ab8(1);
    *"\xc2\x03" = 0;
    *"\xbc\x03" = 0;
    *"\xc3\x03" = 0;
    *"\xbd\x03" = 0;
    *"x\x03" = 0;
    *(char *)((int32_t)"x\x03" + 1) = 0;
    *"\x98\x03" = 0;
    function_5cc0(0);
    *"\x97\x03" = -1;
    int32_t result2 = function_782c(153); // 0x2ae0
    *"\x99\x03" = -1;
    // 0x268e
    return result2;
  lab_0x2674:
    // 0x2674
    result = 216;
    if (a2 == 1 == a3 == 0) {
        // 0x267c
        function_59d8(2, v3, v4, v5);
        *"\xa9\x03" = (char)&g62;
        *(char *)0x20000370 = 1;
        result = 1;
    }
    // 0x268e
    return result;
}

// Address range: 0x2b24 - 0x2c6a
int32_t function_2b24(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2b24
    if (function_bfb2(0x40061000, 5) == 0) {
        // 0x2b5c
        *".\x04" = 47;
        *"-\x04" = 1;
        function_2580((int32_t *)&g12, 1, 0, (int32_t)&g130);
    } else {
        // 0x2b58
        *".\x04" = 0;
    }
    int32_t v1 = function_b0b8(); // 0x2bae
    uint16_t v2; // 0x2b24
    switch (v1) {
        case 145: {
            int16_t v3 = *(int16_t *)0x2000042a; // 0x2bc0
            v2 = v3 + 1;
            *(int16_t *)0x2000042a = v2;
            switch (v3) {
                case 1: {
                    // 0x2c02
                    *"\x92\x03" = -111;
                    int32_t result = function_2580((int32_t *)145, 1, 0, (int32_t)&g130); // 0x2bea
                    *",\x04" = 0;
                    // 0x2c04
                    return result;
                }
                case 127: {
                    int32_t result2 = 0x2000042a; // 0x2c08
                    if ((int32_t)&g106 == 145 || (int32_t)&g102 == 145 || (int32_t)&g14 == 145 || (int32_t)&g13 == 145 || (int32_t)&g121 == 145 || (int32_t)&g126 == 145) {
                        // 0x2c1e
                        *",\x04" = 1;
                        result2 = function_2580((int32_t *)145, 1, 1, (int32_t)&g130);
                    }
                    // 0x2c04
                    return result2;
                }
            }
            // break -> 0x2bd0
            break;
        }
        case 255: {
            // 0x2c60
            *"\x91\x03" = (char)v1;
            *(int16_t *)0x2000042a = 0;
            return 0x2000042a;
        }
        default: {
            // 0x2c56
            function_2580((int32_t *)146, 0, 44, (int32_t)&g130);
            // 0x2c60
            *"\x91\x03" = (char)v1;
            *(int16_t *)0x2000042a = 0;
            return 0x2000042a;
        }
    }
    // 0x2bd0
    if (v2 < 128) {
        // 0x2c04
        return 0x2000042a;
    }
    int16_t result3 = v2; // 0x2bd6
    if ((int32_t)&g102 == 145 || (int32_t)&g106 == 145) {
        // 0x2c2e
        *",\x04" = 1;
        if (v2 % 16 == 0) {
            // 0x2c36
            function_2580((int32_t *)145, 1, 1, (int32_t)&g130);
        }
        // 0x2c40
        result3 = *(int16_t *)0x2000042a;
    }
    // 0x2c40
    if (result3 != -1) {
        // 0x2c04
        return result3;
    }
    // 0x2c48
    *(int16_t *)0x2000042a = (int16_t)&g91;
    return (int32_t)&g91;
}

// Address range: 0x2c9c - 0x2cc0
int32_t function_2c9c(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x2c9c
    function_c73e(a1, a2, a3, a1);
    int32_t result = function_2d38(a2 >> (uint32_t)(int32_t)&g2, (uint32_t)(a3 >> (uint32_t)(int32_t)&g90 >> (uint32_t)(int32_t)&g90 >> (uint32_t)(int32_t)&g90 >> (uint32_t)(int32_t)&g90) >> (uint32_t)(int32_t)&g26); // 0x2cba
    return result;
}

// Address range: 0x2cc0 - 0x2cca
int32_t function_2cc0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2cc0
    int32_t v1; // 0x2cc0
    return function_2cd0(v1, a3);
}

// Address range: 0x2cca - 0x2cd0
int32_t function_2cca(int32_t a1) {
    // 0x2cca
    int32_t v1; // 0x2cca
    return function_2d94(v1, v1, v1, v1);
}

// Address range: 0x2cd0 - 0x2d16
int32_t function_2cd0(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2cd4
    if (a1 == 1 == a2 == 0) {
        // 0x2cda
        *"\xe6\x03" = -27;
        *(char *)0x200004cc = (char)&g97;
        *"\x99\x03" = (char)&g62;
        result = (int32_t)&g62;
    }
    // 0x2d14
    return result;
}

// Address range: 0x2d38 - 0x2d74
int32_t function_2d38(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x2d3c
    if (a1 == 1 == a2 == 0) {
        // 0x2d42
        *"g\x04" = 0;
        *(int16_t *)0x2000046a = 0;
        *"\xe6\x03" = 0;
        *"e\x04" = 1;
        *(int16_t *)3386 = (int16_t)&g101;
        *(int16_t *)&g38 = 0;
        *(int16_t *)&g39 = (int16_t)"_DCS";
        function_87d0(function_10a0(), (int32_t)"_DCS");
        *"f\x04" = 1;
        result = (int32_t)"f\x04";
    }
    // 0x2d72
    return result;
}

// Address range: 0x2d94 - 0x2e30
int32_t function_2d94(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-24, 0x2d94
    if (a2 == 1 != (a3 == 0)) {
        // 0x2dea
        return result;
    }
    // 0x2da0
    function_2110(result);
    *"\x99\x03" = (char)&g62;
    *"\xe6\x03" = 0;
    function_1e64(0x200003e7, &v1, 0, a4);
    uint32_t v2 = v1; // 0x2dc4
    int32_t v3 = 0;
    int32_t v4 = 4 * v3; // 0x2dca
    int32_t v5; // 0x2e04
    int32_t v6; // 0x2e08
    uint32_t v7; // 0x2dd2
    int32_t v8; // 0x2dfc
    if (*(int32_t *)(v4 + *(int32_t *)0x200003f4) >= v2) {
        // 0x2dd2
        v7 = *(int32_t *)(v4 + *(int32_t *)0x200003f8);
        if (v7 == v2 || v7 < v2) {
            // 0x2dec
            *"\x97\x03" = (char)result;
            *(char *)(*(int32_t *)0x200003d0 + 46) = (char)v3;
            v8 = v2 + 75;
            v1 = v8;
            v5 = function_108c(v8, (int32_t)*(int16_t *)(*(int32_t *)0x200003d0 + 28), 0);
            v6 = *(int32_t *)0x200003d0;
            *(int32_t *)v6 = v5;
            *(int32_t *)(v6 + 8) = v5;
            function_12a8(v6);
            *(int32_t *)0x200003d4 = *(int32_t *)0x200003d0;
            function_1ab8(1);
            function_a518();
            return function_a61c();
        }
    }
    uint32_t v9 = (v3 + 1) % 256; // 0x2dda
    while (v9 < 7) {
        // 0x2dca
        v3 = v9;
        v4 = 4 * v3;
        if (*(int32_t *)(v4 + *(int32_t *)0x200003f4) >= v2) {
            // 0x2dd2
            v7 = *(int32_t *)(v4 + *(int32_t *)0x200003f8);
            if (v7 == v2 || v7 < v2) {
                // 0x2dec
                *"\x97\x03" = (char)result;
                *(char *)(*(int32_t *)0x200003d0 + 46) = (char)v3;
                v8 = v2 + 75;
                v1 = v8;
                v5 = function_108c(v8, (int32_t)*(int16_t *)(*(int32_t *)0x200003d0 + 28), 0);
                v6 = *(int32_t *)0x200003d0;
                *(int32_t *)v6 = v5;
                *(int32_t *)(v6 + 8) = v5;
                function_12a8(v6);
                *(int32_t *)0x200003d4 = *(int32_t *)0x200003d0;
                function_1ab8(1);
                function_a518();
                return function_a61c();
            }
        }
        // 0x2dd8
        v9 = (v3 + 1) % 256;
    }
    // 0x2de6
    *"\x99\x03" = (char)&g62;
    // 0x2dea
    return (int32_t)"\x99\x03";
}

// Address range: 0x2e50 - 0x2e7c
int32_t function_2e50(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2e50
    function_c73e(a1, a2, a3, a1);
    return function_3b40(a2, (int16_t)a2, a1, a1);
}

// Address range: 0x2e7c - 0x2e86
int32_t function_2e7c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x2e7c
    int32_t v1; // 0x2e7c
    return function_2f58(v1, a3, a3, v1);
}

// Address range: 0x2e86 - 0x2e90
int32_t function_2e86(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x2e86
    int32_t v1; // 0x2e86
    return function_2ec8(v1, a3, a3, v1);
}

// Address range: 0x2e90 - 0x2e94
int32_t function_2e90(void) {
    int32_t result = function_2e98((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x2e92
    return result;
}

// Address range: 0x2e94 - 0x2e98
int32_t function_2e94(int32_t result, int32_t a2, int32_t a3) {
    // 0x2e94
    bool v1; // 0x2e94
    if (v1) {
        __asm_bicsmi(a3, a2, a3);
    }
    return result;
}

// Address range: 0x2e98 - 0x2ea2
int32_t function_2e98(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2e98
    int32_t v1; // 0x2e98
    return function_31b4(v1, v1, v1, v1);
}

// Address range: 0x2ea2 - 0x2eaa
int32_t function_2ea2(int32_t a1, int32_t a2) {
    // 0x2ea2
    bool v1; // 0x2ea2
    if (v1) {
        __asm_qadd16mi(a1, a2);
    }
    return unknown_37eeb4();
}

// Address range: 0x2eaa - 0x2eac
int32_t function_2eaa(int32_t a1, int32_t a2, int32_t a3) {
    // 0x2eaa
    int32_t result; // 0x2eaa
    return result;
}

// Address range: 0x2eac - 0x2ec8
int32_t function_2eac(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x2eac
    int32_t v1; // 0x2eac
    uint32_t v2 = v1;
    __asm_rfeia(1);
    int32_t v3 = a1; // 0x2eb0
    bool v4; // 0x2eac
    if (v4) {
        v3 = function_32478();
        *(int32_t *)(a2 - (int32_t)&g34) = a3;
        *(int32_t *)(a2 - (int32_t)&g30) = a4;
        *(int32_t *)(a2 - (int32_t)&g62) = (int32_t)&g41;
    }
    uint32_t v5 = v3;
    if (v4) {
        *(int32_t *)(a3 - (int32_t)&g34) = a2;
        *(int32_t *)(a3 - (int32_t)&g30) = a4;
        *(int32_t *)(a3 - (int32_t)&g62) = (int32_t)&g42;
    }
    bool v6; // 0x2eac
    if (v4) {
        v6 = (v5 >> v2 | v5 << 32 - v2) < 0;
    }
    return v6 ? v1 * a4 : v5;
}

// Address range: 0x2ec8 - 0x2f38
int32_t function_2ec8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x2ecc
    if (a1 == 1 == a2 == 0) {
        // 0x2ed2
        *"\x96\x03" = 1;
        function_77bc();
        *"\x97\x03" = (char)&g2;
        *"\x99\x03" = 1;
        result = (int32_t)&g2;
    }
    // 0x2f16
    return result;
}

// Address range: 0x2f58 - 0x2fea
int32_t function_2f58(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x2f5c
    if (a1 == 1 == a2 == 0) {
        // 0x2f62
        *"\x96\x03" = 2;
        *"\x99\x03" = 1;
        *"\xe6\x03" = 0;
        result = (int32_t)"\xe6\x03";
    }
    // 0x2fce
    return result;
}

// Address range: 0x301c - 0x3176
int32_t function_301c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    if (a2 == 1 != (a3 == 0)) {
        // 0x308a
        return result;
    }
    // 0x3028
    *"\x96\x03" = 2;
    return (int32_t)"\x96\x03";
}

// Address range: 0x31b4 - 0x3274
int32_t function_31b4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x31c8
    if (a1 == 1 == a2 == 0) {
        // 0x31f8
        *"\x96\x03" = 2;
        result = 2;
    }
    // 0x31fc
    return result;
}

// Address range: 0x329c - 0x32c8
int32_t function_329c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x329c
    function_c73e(a1, a2, a3, a1);
    return function_3b40((int32_t)&g24, (int16_t)&g24, a3, a1);
}

// Address range: 0x32c8 - 0x32d2
int32_t function_32c8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x32c8
    int32_t v1; // 0x32c8
    return function_33ac(v1, a3, a3, v1);
}

// Address range: 0x32d2 - 0x32dc
int32_t function_32d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x32d2
    int32_t v1; // 0x32d2
    return function_3314(v1, a3);
}

// Address range: 0x32dc - 0x32e6
int32_t function_32dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x32dc
    int32_t v1; // 0x32dc
    return function_3604(v1, a3);
}

// Address range: 0x32e6 - 0x32ea
int32_t function_32e6(void) {
    int32_t result = function_32ee((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x32e8
    return result;
}

// Address range: 0x32ea - 0x32ee
int32_t function_32ea(int32_t result, int32_t a2, int32_t a3) {
    // 0x32ea
    bool v1; // 0x32ea
    if (v1) {
        __asm_bicsmi(a3, a2, a3);
    }
    return result;
}

// Address range: 0x32ee - 0x32f8
int32_t function_32ee(int32_t a1, int32_t a2, int32_t a3) {
    // 0x32ee
    int32_t v1; // 0x32ee
    return function_3620(v1, v1, v1);
}

// Address range: 0x32f8 - 0x3314
int32_t function_32f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x32f8
    int32_t v1; // 0x32f8
    uint32_t v2 = v1;
    __asm_rfedb(4);
    int32_t v3 = a1; // 0x32fc
    bool v4; // 0x32f8
    if (v4) {
        v3 = function_328c4();
        *(int32_t *)(a2 - (int32_t)&g34) = a3;
        *(int32_t *)(a2 - (int32_t)&g30) = a4;
        *(int32_t *)(a2 - (int32_t)&g62) = (int32_t)&g49;
    }
    uint32_t v5 = v3;
    if (v4) {
        *(int32_t *)(a3 - (int32_t)&g34) = a2;
        *(int32_t *)(a3 - (int32_t)&g30) = a4;
        *(int32_t *)(a3 - (int32_t)&g62) = (int32_t)&g50;
    }
    bool v6; // 0x32f8
    if (v4) {
        v6 = (v5 >> v2 | v5 << 32 - v2) < 0;
    }
    return v6 ? v1 * a4 : v5;
}

// Address range: 0x3314 - 0x337a
int32_t function_3314(int32_t result, int32_t a2) {
    if (result == 1 == a2 == 0) {
        // 0x331e
        *"\x96\x03" = 1;
    }
    // 0x3360
    return result;
}

// Address range: 0x33ac - 0x3530
int32_t function_33ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x33ba
    if (a1 == 1 == a2 == 0) {
        // 0x33da
        *"\x96\x03" = 1;
        result = (int32_t)"a\x04";
    }
    // 0x3408
    return result;
}

// Address range: 0x3578 - 0x35e4
int32_t function_3578(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x357e
    if (a2 == 1 == a3 == 0) {
        // 0x3584
        *"\x96\x03" = 2;
        result = 97;
    }
    // 0x35c8
    return result;
}

// Address range: 0x3604 - 0x3616
int32_t function_3604(int32_t result, int32_t a2) {
    if (result == 1 == a2 == 0) {
        // 0x360c
        *"\x96\x03" = 1;
        *"\xa1\x03" = 1;
    }
    // 0x3614
    return result;
}

// Address range: 0x3620 - 0x366c
int32_t function_3620(int32_t result, int32_t a2, int32_t a3) {
    if (a2 != 0) {
        // 0x362a
        if (result != 1) {
            // 0x366a
            return result;
        }
        // 0x3636
        *"\x96\x03" = 2;
        // 0x366a
        return 2;
    }
    // 0x363a
    if (result != 1) {
        // 0x366a
        return result;
    }
    // 0x363e
    *"\x96\x03" = 1;
    *"\xe6\x03" = 0;
    // 0x3636
    *"\x96\x03" = 2;
    // 0x366a
    return 2;
}

// Address range: 0x3684 - 0x3750
int32_t function_3684(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x3684
    int32_t result; // 0x36f6
    if (a2 == 1 != (a3 == 0)) {
        // 0x36d6
        function_c73e(186, a2, a3, a1);
        result = function_3b40(a2 >> (int32_t)&g26, (int16_t)a2, a1, (int32_t)&g83 + 63);
        return result;
    }
    int32_t v1 = function_1f3c(a1, 1, 0); // 0x36ba
    if (v1 == 255) {
        // 0x36d6
        function_c73e(255, a2, a3, a1);
        result = function_3b40(a2 >> (int32_t)&g26, (int16_t)a2, a1, (int32_t)&g83 + 63);
        return result;
    }
    // 0x36c2
    *"\x96\x03" = 1;
    function_20dc(v1, 1, 0, a4);
    *"\x99\x03" = 0;
    *"\x94\x03" = 1;
    return (int32_t)"\x94\x03";
}

// Address range: 0x3764 - 0x37b6
int32_t function_3764(int32_t result, int32_t a2) {
    if (result == 1 != (a2 == 0)) {
        // 0x3794
        return result;
    }
    // 0x376e
    *"\x96\x03" = 1;
    function_7714();
    *"\x97\x03" = (char)&g2;
    *"\x99\x03" = 0;
    return (int32_t)&g2;
}

// Address range: 0x37d4 - 0x3806
int32_t function_37d4(int32_t a1, int32_t a2) {
    int32_t result = a1; // 0x37d8
    if (a1 == 1 == a2 == 0) {
        // 0x37de
        *"\x96\x03" = 1;
        *"\xe6\x03" = 0;
        *"\x99\x03" = 0;
        result = 0;
    }
    // 0x37f4
    return result;
}

// Address range: 0x381c - 0x3ae8
int32_t function_381c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = a4; // bp-24, 0x381c
    if (a2 == 1 != (a3 == 0)) {
        // 0x3962
        return 0x20000a94;
    }
    unsigned char v2 = *(char *)0x20000a9d; // 0x382a
    *"\x96\x03" = 1;
    function_2110(a1);
    *"\x99\x03" = 0;
    if (*(char *)(*(int32_t *)0x200003cc + (int32_t)&g23) >= 207) {
        // 0x3a06
        *"\x97\x03" = (char)a1;
        return (int32_t)"\x97\x03";
    }
    int32_t v3 = v2; // 0x382a
    *"\xe6\x03" = 0;
    function_1e64((int32_t)"\xe7\x03", &v1, 0, a4);
    int32_t v4 = *(int32_t *)0x200003f8; // 0x3a3e
    uint32_t v5 = v1; // 0x3a42
    int32_t v6 = 0;
    int32_t v7 = 4 * v6; // 0x3a44
    int32_t v8; // 0x381c
    int32_t v9; // 0x381c
    int32_t v10; // 0x381c
    uint32_t v11; // 0x3a4e
    int32_t v12; // 0x3a70
    char * v13; // 0x3a74
    int32_t v14; // 0x3a74
    char v15; // 0x3a7a
    char v16; // 0x3a80
    int32_t v17; // 0x3a80
    if (*(int32_t *)(v7 + *(int32_t *)0x200003f4) >= v5) {
        // 0x3a4c
        v11 = *(int32_t *)(v7 + v4);
        if (v11 == v5 || v11 < v5) {
            // 0x3a6a
            *"\x97\x03" = (char)a1;
            v12 = *(int32_t *)0x200003cc;
            v13 = (char *)(v12 + 46);
            v14 = (int32_t)*v13;
            v8 = v4;
            v10 = v12;
            v9 = v5;
            if (v6 == v14) {
                goto lab_0x3a92;
            } else {
                // 0x3a7a
                v15 = v6;
                *v13 = v15;
                v16 = v15 - 56;
                v17 = v3 + 0x20000a94;
                *(char *)v17 = v16;
                *(char *)(v3 + 0x20000a96) = v16;
                function_6b88(v16, v17, v14, v11);
                function_5f5c(v2, 2);
                v8 = *(int32_t *)0x200003f8;
                v10 = *(int32_t *)0x200003cc;
                v9 = v1;
                goto lab_0x3a92;
            }
        }
    }
    uint32_t v18 = (v6 + 1) % 256; // 0x3a56
    while (v18 < 7) {
        // 0x3a44
        v6 = v18;
        v7 = 4 * v6;
        if (*(int32_t *)(v7 + *(int32_t *)0x200003f4) >= v5) {
            // 0x3a4c
            v11 = *(int32_t *)(v7 + v4);
            if (v11 == v5 || v11 < v5) {
                // 0x3a6a
                *"\x97\x03" = (char)a1;
                v12 = *(int32_t *)0x200003cc;
                v13 = (char *)(v12 + 46);
                v14 = (int32_t)*v13;
                v8 = v4;
                v10 = v12;
                v9 = v5;
                if (v6 == v14) {
                    goto lab_0x3a92;
                } else {
                    // 0x3a7a
                    v15 = v6;
                    *v13 = v15;
                    v16 = v15 - 56;
                    v17 = v3 + 0x20000a94;
                    *(char *)v17 = v16;
                    *(char *)(v3 + 0x20000a96) = v16;
                    function_6b88(v16, v17, v14, v11);
                    function_5f5c(v2, 2);
                    v8 = *(int32_t *)0x200003f8;
                    v10 = *(int32_t *)0x200003cc;
                    v9 = v1;
                    goto lab_0x3a92;
                }
            }
        }
        // 0x3a54
        v18 = (v6 + 1) % 256;
    }
    // 0x3a62
    *"\x99\x03" = 0;
    *"\x96\x03" = 2;
    return (int32_t)"\x96\x03";
  lab_0x3a92:;
    int32_t v19 = v9 + 75; // 0x3a96
    v1 = v19;
    unsigned char v20 = *(char *)(v10 + (int32_t)&g40); // 0x3a9c
    int32_t v21 = *(int32_t *)(4 * (int32_t)v20 + v8); // 0x3aa6
    int32_t v22 = function_108c(v19, (int32_t)*(int16_t *)(v10 + 28), v21); // 0x3aa8
    *(int32_t *)*(int32_t *)0x200003cc = v22;
    *(char *)0x2000039d = 1;
    return 1;
}

// Address range: 0x3b40 - 0x3c78
int32_t function_3b40(int32_t result, int16_t a2, int32_t a3, int32_t a4) {
    // 0x3b40
    *"\xe6\x03" = 0;
    if (result != 1) {
        // 0x3b9e
        return result;
    }
    // 0x3b68
    function_7714();
    *"\x99\x03" = 0;
    *"-\x04" = 0;
    *".\x04" = 0;
    return (int32_t)".\x04";
}

// Address range: 0x3cf0 - 0x3d86
int32_t function_3cf0(int32_t result, int32_t a2) {
    if (result == 1 == a2 == 0) {
        // 0x3d0c
        *"\x96\x03" = 2;
    }
    // 0x3d0e
    return result;
}

// Address range: 0x3dc8 - 0x3e96
int32_t function_3dc8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 == 1 != (a2 == 0)) {
        // 0x3e08
        return *(int32_t *)0x200003cc;
    }
    // 0x3e10
    *"\x96\x03" = 2;
    return 2;
}

// Address range: 0x3ec0 - 0x3eec
int32_t function_3ec0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3ec0
    function_c73e(a1, a2, a3, a1);
    int32_t v1 = a3 >> (uint32_t)(int32_t)&g26; // 0x3ed6
    function_3b40(a2, (int16_t)a2, v1, v1);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3eea
    return result;
}

// Address range: 0x3eec - 0x3ef6
int32_t function_3eec(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3eec
    int32_t v1; // 0x3eec
    function_3ffc(v1, a3, a3, v1);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3ef4
    return result;
}

// Address range: 0x3ef6 - 0x3f00
int32_t function_3ef6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3ef6
    int32_t v1; // 0x3ef6
    function_3f64(v1, a3, a3, v1);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3efe
    return result;
}

// Address range: 0x3f00 - 0x3f04
int32_t function_3f00(void) {
    // 0x3f00
    return function_3f08();
}

// Address range: 0x3f04 - 0x3f08
int32_t function_3f04(int32_t result, int32_t a2, int32_t a3) {
    // 0x3f04
    bool v1; // 0x3f04
    if (v1) {
        __asm_bicsmi(a3, a2, a3);
    }
    return result;
}

// Address range: 0x3f08 - 0x3f12
int32_t function_3f08(void) {
    // 0x3f08
    int32_t v1; // 0x3f08
    function_42e8(v1, v1, v1);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3f10
    return result;
}

// Address range: 0x3f12 - 0x3f18
int32_t function_3f12(void) {
    // 0x3f12
    int32_t v1; // 0x3f12
    function_40dc(v1, v1, v1, v1);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3f16
    return result;
}

// Address range: 0x3f18 - 0x3f22
int32_t function_3f18(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3f18
    int32_t v1; // 0x3f18
    function_425c(v1, a3);
    int32_t result = function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x3f20
    return result;
}

// Address range: 0x3f22 - 0x3f3a
int32_t function_3f22(int32_t a1, int32_t a2) {
    // 0x3f22
    bool v1; // 0x3f22
    if (v1) {
        int32_t v2; // 0x3f22
        __asm_qadd16mi(v2, a2);
    }
    unknown_ff37ff2e();
    if (v1) {
        function_3bf4a();
    }
    if (!v1) {
        function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
    }
    if (a2 != 1) {
        function_3f3a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130);
    }
    // 0x3f34
    *"\x96\x03" = 2;
    return 2;
}

// Address range: 0x3f3a - 0x3f52
int32_t function_3f3a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x3f3a
    return 217;
}

// Address range: 0x3f64 - 0x3fd4
int32_t function_3f64(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x3f68
    if (a1 == 1 == a2 == 0) {
        // 0x3f6e
        *"\x96\x03" = 1;
        function_77a8(-127, 0, (char)a3);
        *"\x97\x03" = (char)&g2;
        *"\x99\x03" = 2;
        *"\x94\x03" = 1;
        result = (int32_t)"\x94\x03";
    }
    // 0x3fa2
    return result;
}

// Address range: 0x3ffc - 0x40b0
int32_t function_3ffc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = a1; // 0x4000
    if (a1 == 1 == a2 == 0) {
        // 0x4006
        *"\x96\x03" = 1;
        *"\x99\x03" = 2;
        *"\xa3\x03" = 1;
        *"\xc6\x03" = 0;
        *"\x81\x03" = 0;
        *"\x97\x03" = (char)&g46;
        *"\xe6\x03" = 0;
        result = (int32_t)"\xe6\x03";
    }
    // 0x40ae
    return result;
}

// Address range: 0x40dc - 0x4230
int32_t function_40dc(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a3; // bp-28, 0x40dc
    int32_t v2 = a4; // bp-24, 0x40dc
    if (a2 == 1 != (a3 == 0)) {
        // 0x4168
        return result;
    }
    // 0x40ea
    *"\x96\x03" = 1;
    function_2110(result);
    *"\x99\x03" = 2;
    if (function_22f8(-59, &v2, &v1) != 0) {
        // 0x4128
        *"\xe6\x03" = 0;
        // 0x4224
        *"\x96\x03" = 2;
        // 0x4168
        return 2;
    }
    uint32_t v3 = v1 % 256; // 0x41ce
    if (v3 >= (int32_t)&g78 == (int32_t)&g44 == 230) {
        // 0x421e
        *"\xe6\x03" = 0;
    }
    if (v3 == 0 || v3 != 0) {
        // 0x422a
        *(int32_t *)0x20000450 = 0;
        return 0x20000450;
    }
    // 0x4224
    *"\x96\x03" = 2;
    // 0x4168
    return 2;
}

// Address range: 0x425c - 0x42ca
int32_t function_425c(int32_t result, int32_t a2) {
    // 0x425c
    if (result == 1 != (a2 == 0)) {
        // 0x4294
        return result;
    }
    // 0x4266
    *"\x96\x03" = 1;
    function_1d7c();
    int32_t result2 = *(int32_t *)0x200003d0; // 0x4274
    if (*(char *)(result2 + 30) >= 207) {
        // 0x4292
        *"\x96\x03" = 2;
        // 0x4294
        return result2;
    }
    // 0x427c
    if (*(char *)(result2 + 51) != 1) {
        // 0x42ac
        *"\x94\x03" = 1;
        return (int32_t)"\x94\x03";
    }
    // 0x4292
    *"\x96\x03" = 2;
    // 0x4294
    return 1;
}

// Address range: 0x42e8 - 0x43aa
int32_t function_42e8(int32_t result, int32_t a2, int32_t a3) {
    if (a2 == 0) {
        // 0x4308
        if (result != 1) {
            // 0x4348
            return result;
        }
        // 0x430c
        *"\x96\x03" = 1;
        *"\xe6\x03" = 0;
    } else {
        // 0x42f2
        if (result != 1) {
            // 0x4348
            return result;
        }
    }
    // 0x42fe
    function_74d0(a3);
    *"\x94\x03" = 1;
    *"\x99\x03" = 2;
    // 0x4348
    return 2;
}

// Address range: 0x43dc - 0x446e
int32_t function_43dc(int32_t a1, int32_t a2, int32_t a3) {
    char * v1 = a1 == (int32_t)&g14 ? (char *)0x20000ad1 : (char *)0x20000ad3;
    int32_t result = (int32_t)*v1;
    if (a2 == 1 == a3 == 0) {
        // 0x446a
        *"\x96\x03" = 1;
        return result;
    }
    // 0x4446
    int32_t v2; // 0x43dc
    if ((a3 || a2) == 0) {
        // 0x4456
        v2 = result;
        // 0x4428
        return function_c73e(v2, a2, a3, v2);
    }
    char * v3 = a1 == (int32_t)&g14 ? (char *)0x20000ad2 : (char *)0x20000ad4;
    if (a2 == 1 != (a3 == 1)) {
        // 0x4428
        return result;
    }
    // 0x4456
    v2 = (int32_t)*v3;
    // 0x4428
    return function_c73e(v2, a2, a3, v2);
}

// Address range: 0x446e - 0x4474
int32_t function_446e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x446e
    return function_5710();
}

// Address range: 0x4474 - 0x4478
int32_t function_4474(void) {
    // 0x4474
    return unknown_dc0480();
}

// Address range: 0x4478 - 0x447a
int32_t function_4478(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4478
    int32_t result; // 0x4478
    return result;
}

// Address range: 0x447a - 0x4480
int32_t function_447a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x447a
    return function_5748();
}

// Address range: 0x4480 - 0x4488
int32_t function_4480(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4480
    return function_5808(1);
}

// Address range: 0x4488 - 0x448c
int32_t function_4488(void) {
    // 0x4488
    return unknown_1340494();
}

// Address range: 0x448c - 0x448e
int32_t function_448c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x448c
    int32_t result; // 0x448c
    return result;
}

// Address range: 0x448e - 0x4494
int32_t function_448e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x448e
    int32_t v1; // 0x448e
    return function_56b0(v1, v1, (char)v1, v1);
}

// Address range: 0x4494 - 0x4498
int32_t function_4494(void) {
    int32_t result = function_449a((int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x4496
    return result;
}

// Address range: 0x4498 - 0x449a
int32_t function_4498(void) {
    // 0x4498
    return 1;
}

// Address range: 0x449a - 0x44a0
int32_t function_449a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x449a
    int32_t v1; // 0x449a
    return function_5678(v1);
}

// Address range: 0x44c4 - 0x4560
int32_t function_44c4(int32_t result, int32_t a2) {
    if (result == 1 == a2 == 0) {
        // 0x44da
        *"\x96\x03" = 2;
    }
    // 0x44dc
    return result;
}

// Address range: 0x458c - 0x4880
int32_t function_458c(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x458c
    *(int16_t *)0x200003e4 = *(int16_t *)0x200003e4 + 1;
    if (function_bbc8() == 1) {
        // 0x459e
        __asm_cpsid(1);
        __asm_cpsie(function_bf4());
    }
    // 0x45a6
    function_23b0(-40, a2, a3, a4);
    return 140;
}

// Address range: 0x4908 - 0x4c76
int32_t function_4908(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4908
    *"\xa9\x03" = (char)(0xffffffff >> (uint32_t)(int32_t)&g16 & 168);
    if ((0xffffffff >> (int32_t)&g16 & 168) == 0) {
        // 0x492e
        *"p\x03" = 1;
    }
    // 0x4930
    *"\x8c\x03" = -117;
    return 139;
}

// Address range: 0x4d48 - 0x504e
int32_t function_4d48(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4d48
    function_50e4();
    return 140;
}

// Address range: 0x50e4 - 0x5114
int32_t function_50e4(void) {
    // 0x50e4
    return 216;
}

// Address range: 0x511c - 0x5190
int32_t function_511c(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x511c
    return 176;
}

// Address range: 0x51c0 - 0x5284
int32_t function_51c0(void) {
    // 0x51c0
    if (*(char *)(*(int32_t *)0x200003d0 + 30) < 207 || *(int16_t *)0x20000354 == 0) {
        // 0x51e6
        return 0;
    }
    // 0x5230
    *(int16_t *)0x20000354 = 0;
    function_7fa8();
    return function_69d0((int32_t *)&g62);
}

// Address range: 0x52c8 - 0x5468
int32_t function_52c8(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x52c8
    *"R\x03" = 0;
    return (int32_t)"R\x03";
}

// Address range: 0x54c8 - 0x554e
int32_t function_54c8(int32_t a1) {
    int32_t v1 = 0; // 0x54c8
    switch (a1) {
        case 1: {
            // 0x54dc
            *"\xc5\x03" = (char)&g48;
            *(int32_t *)0x20000450 = 219;
            function_782c(2);
            *"L\x04" = 57;
            *"h\x03" = 1;
            return (int32_t)"h\x03";
        }
        case 2: {
            // 0x54fc
            *(char *)0x20000aae = 0;
            *(char *)0x20000ab0 = 0;
            *(char *)0x20000aa7 = 0;
            *(char *)0x20000aaf = 0;
            *(char *)0x20000acc = 0;
            *(char *)0x20000ad1 = 0;
            *(char *)0x20000ad2 = 0;
            *(char *)0x20000ad3 = 0;
            *(char *)0x20000ad4 = 0;
            function_7020(*(int32_t *)0x200003d0, 205, 5, 0x271a604);
            int32_t v2 = *(int32_t *)0x200003d0; // 0x5524
            *(char *)(v2 + 43) = 1;
            *(char *)(v2 + 39) = 0;
            function_12a8(v2);
            *(int32_t *)0x200003d4 = *(int32_t *)0x200003d0;
            function_1ab8(1);
            function_a518();
            function_a61c();
            *"f\x04" = 0;
            v1 = (int32_t)&g62;
            // break -> 0x54d6
            break;
        }
    }
    // 0x54d6
    return function_782c(v1);
}

// Address range: 0x5578 - 0x5652
int32_t function_5578(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x5578
    *"p\x03" = 1;
    function_19c(0x200003e7, (int32_t)&g90, (int32_t)&g97);
    while (true) {
        // continue -> 0x5590
    }
}

// Address range: 0x5678 - 0x569c
int32_t function_5678(int32_t a1) {
    // 0x5678
    *"\xe6\x03" = 0;
    *"\x83\x03" = a1 == 1 ? (char)&g44 : 1;
    *(int16_t *)0x20000422 = 0;
    *"\xa0\x03" = 1;
    *"\x99\x03" = 0;
    return (int32_t)"\x99\x03";
}

// Address range: 0x56b0 - 0x56f6
int32_t function_56b0(int32_t a1, int32_t a2, char a3, int32_t a4) {
    // 0x56b0
    function_1d7c();
    function_1ab8(1);
    int32_t result = function_598c(); // 0x56d8
    *"\xe6\x03" = 0;
    *"\x99\x03" = 1;
    return result;
}

// Address range: 0x5710 - 0x573e
int32_t function_5710(void) {
    // 0x5710
    *"\xb3\x03" = 0;
    return function_bf98(0x40061000, (int32_t)&g44);
}

// Address range: 0x5748 - 0x57d0
int32_t function_5748(void) {
    // 0x5748
    function_1d7c();
    function_1ab8(1);
    return function_69d0((int32_t *)2);
}

// Address range: 0x5808 - 0x58ba
int32_t function_5808(int32_t a1) {
    // 0x5808
    function_1d7c();
    unsigned char result = *(char *)(*(int32_t *)0x200003d0 + 30); // 0x5828
    if (result >= 207) {
        // 0x5858
        return result;
    }
    // 0x582e
    function_782c(0);
    int32_t result2 = function_7714(); // 0x583c
    *"\x97\x03" = (char)&g2;
    return result2;
}

// Address range: 0x58e4 - 0x590e
int32_t function_58e4(void) {
    char * v1 = (char *)(*(int32_t *)0x200003cc + 39); // 0x58ea
    unsigned char v2 = *v1 + 1;
    *v1 = v2 == 2 | v2 < 2 ? v2 : 0;
    *"\x9d\x03" = 1;
    *"\x97\x03" = (char)&g13;
    *"\x99\x03" = -39;
    return 217;
}

// Address range: 0x5924 - 0x594a
int32_t function_5924(void) {
    // 0x5924
    *(char *)0x20000aa7 = (char)(*(char *)0x20000aa7 == 0);
    *"\x9e\x03" = 1;
    *"\x98\x03" = 1;
    *"\x97\x03" = (char)&g23;
    *"o\x03" = 1;
    return 1;
}

// Address range: 0x5960 - 0x597e
int32_t function_5960(void) {
    int32_t result = 0; // 0x5968
    if (*(char *)0x20000ab1 != 0) {
        // 0x596a
        function_bfe4(0x40060800, (int32_t *)6);
        result = 2 * (int32_t)*(char *)((int32_t)&g21 + 0x20000a94) | 1;
        *"j\x03" = (char)result;
    }
    // 0x597c
    return result;
}

// Address range: 0x598c - 0x59ba
int32_t function_598c(void) {
    // 0x598c
    *"\x8d\x03" = 1;
    *"\x90\x03" = 0;
    *(int16_t *)0x2000038e = 0;
    int32_t v1; // 0x598c
    function_a1ac((int32_t)*(int16_t *)0x20000ac4, 1, v1, v1);
    function_bfe4(0x40061000, (int32_t *)&g62);
    *"k\x03" = 1;
    *"o\x03" = 1;
    return (int32_t)"o\x03";
}

// Address range: 0x59d8 - 0x5b08
int32_t function_59d8(int32_t a1, char a2, int32_t a3, int32_t a4) {
    if (a1 != (int32_t)&g62 && a1 != (int32_t)&g44) {
        // 0x59e4
        if (*(char *)0x20000aaa == 0) {
            // 0x5b06
            return 0;
        }
    }
    int32_t v1 = function_a960((int32_t *)113); // 0x5a02
    function_bf98(0x40061000, (int32_t)&g62);
    function_d0ec((int32_t)&g11);
    int32_t v2 = 1000; // 0x5a36
    if (a1 != 1) {
        // 0x5a38
        v2 = a1 == 2 | a1 == (int32_t)&g62 ? 500 : 440;
    }
    // 0x5a46
    function_9f14(v2, 1);
    function_d0ec(2);
    function_bfe4(0x40061000, (int32_t *)&g62);
    int32_t v3 = function_d0ec((int32_t)&g58); // 0x5a5a
    int32_t v4 = v3; // 0x5a60
    int32_t v5; // 0x59d8
    if (a1 == 1) {
        goto lab_0x5ac2;
    } else {
        // 0x5a62
        function_9f7c(v3);
        v5 = 500;
        if (a1 == 2 || a1 == (int32_t)&g62) {
            int32_t v6 = function_d0ec((int32_t)&g58); // 0x5ad2
            function_9f84(v6);
            v4 = function_d0ec((int32_t)&g11);
            goto lab_0x5ac2;
        } else {
            goto lab_0x5a72;
        }
    }
  lab_0x5ac2:
    // 0x5ac2
    function_9f7c(v4);
    v5 = &g58;
    goto lab_0x5a72;
  lab_0x5a72:
    // 0x5a72
    function_9f84(function_d0ec(v5));
    function_d0ec((int32_t)&g11);
    function_bf98(0x40061000, (int32_t)&g62);
    *(int16_t *)0x200003b6 = (int16_t)&g72;
    function_d0ec(5);
    function_9ee8();
    function_d0ec(5);
    function_af00((int32_t *)113, v1);
    // 0x5b06
    return 216;
}

// Address range: 0x5b28 - 0x5b4a
int32_t function_5b28(uint32_t result, int32_t * a2) {
    if (result == 0) {
        // 0x5b40
        *"\xb1\x03" = 0;
        *"\xb2\x03" = 0;
    } else {
        // 0x5b30
        if (result >= (int32_t)&g90) {
            // 0x5b3e
            return result;
        }
    }
    // 0x5b34
    *(char *)(result + 0x20000430) = (char)(int32_t)a2;
    *"\xb1\x03" = -78;
    // 0x5b3e
    return 178;
}

// Address range: 0x5b58 - 0x5c0c
int32_t function_5b58(char a1, int32_t a2, int32_t a3, int32_t a4) {
    unsigned char v1 = *(char *)0x200004e2; // 0x5b70
    int32_t v2 = v1; // 0x5b70
    int32_t v3; // 0x5b58
    char v4; // 0x5b58
    switch (*(char *)0x20000aa9) {
        case 0: {
            // 0x5be8
            *(int16_t *)0x200003b6 = (int16_t)&g72;
            *"\xb1\x03" = 0;
            *"\xb2\x03" = 0;
            return (int32_t)"\xb1\x03";
        }
        case 1: {
            if (v1 >= 58) {
                // 0x5b96
                *"\xb2\x03" = -77;
                // 0x5be8
                *(int16_t *)0x200003b6 = (int16_t)&g72;
                *"\xb1\x03" = 0;
                *"\xb2\x03" = 0;
                return (int32_t)"\xb1\x03";
            }
            // 0x5b8c
            v3 = v2 | 0xe100;
            v4 = v1 + 16;
            // break -> 0x5bf6
            break;
        }
        default: {
            if (v1 >= 76) {
                // 0x5b96
                *"\xb2\x03" = -77;
                // 0x5be8
                *(int16_t *)0x200003b6 = (int16_t)&g72;
                *"\xb1\x03" = 0;
                *"\xb2\x03" = 0;
                return (int32_t)"\xb1\x03";
            }
            // 0x5b7e
            v3 = v2 + 0xe13a;
            v4 = v1 + 96;
            // break -> 0x5bf6
            break;
        }
    }
    // 0x5bf6
    *"\xb2\x03" = -77;
    function_bf04(v4);
    *(int16_t *)0x20000348 = (int16_t)*(char *)v3;
    *"J\x03" = 0;
    *(int16_t *)0x200003b6 = 2000;
    return 0x200003b6;
}

// Address range: 0x5c44 - 0x5cb2
int32_t function_5c44(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    if (a1 == 0) {
        // 0x5c50
        *"\xb1\x03" = 0;
        *"\xb2\x03" = 0;
    }
    // 0x5c56
    function_128(a2, (int32_t *)1000);
    uint32_t v1 = function_128(1000, &g78); // 0x5c6c
    *(char *)0x200004e1 = (char)v1;
    *"\xb1\x03" = -78;
    int32_t v2 = 1000 - v1 % 256 * (int32_t)&g78 & 0xfffc; // 0x5c82
    uint32_t v3 = function_128(v2, (int32_t *)&g97); // 0x5c8e
    *"\xb1\x03" = -78;
    *(char *)0x200004e1 = (char)(v2 - v3 % 256 * (int32_t)&g97);
    *"\xb1\x03" = -78;
    return 3;
}

// Address range: 0x5cc0 - 0x5dae
int32_t function_5cc0(int32_t a1) {
    char * v1 = (char *)0xe130; // 0x5cc0
    char v2 = 64; // 0x5cc0
    unsigned char v3; // 0x5cc0
    switch (*(char *)0x20000aa9) {
        case 0: {
            // 0x5ce4
            *"\xb2\x03" = 0;
            *"\xb1\x03" = 0;
            return 48;
        }
        default: {
            // 0x5cf6
            v1 = (char *)0xe16a;
            v2 = -112;
        }
        case 1: {
            // 0x5cfc
            v3 = *v1;
            function_bfe4(0x40061000, (int32_t *)&g62);
            *(int16_t *)0x200003b6 = 2000;
            function_d0ec(5);
            function_bf04(v2);
            if (a1 == 1) {
                // 0x5d56
                function_d0ec((int32_t)v3 * (int32_t)&g97);
                *"\xb1\x03" = 0;
                *"\xb2\x03" = 0;
                *(int16_t *)0x200003b6 = (int16_t)&g72;
                return 0x200003b6;
            }
            // break -> 0x5d48
            break;
        }
    }
    // 0x5d48
    *"\xb2\x03" = 1;
    *(int16_t *)0x20000348 = (int16_t)v3;
    *"J\x03" = 0;
    return (int32_t)"J\x03";
}

// Address range: 0x5de8 - 0x5f36
int32_t function_5de8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int16_t * v1 = (int16_t *)a2; // bp-24, 0x5de8
    int32_t v2 = a3; // bp-20, 0x5de8
    function_aff4(0x1ec0, (int32_t *)"\xce\f", (char)&g90);
    function_178((int32_t *)((int32_t)"\xce\f" + 8), "\xce\f");
    function_178((int32_t *)((int32_t)"\xce\f" + 16), "\xce\f");
    function_178((int32_t *)((int32_t)"\xce\f" + 24), "\xce\f");
    function_aff4(0x1ec8, (int32_t *)((int32_t)"\xce\f" - 24), (char)&g90);
    function_178((int32_t *)((int32_t)"\xce\f" - 24 + (int32_t)&g90), (char *)((int32_t)"\xce\f" - 24));
    function_178((int32_t *)((int32_t)"\xce\f" - 8), (char *)((int32_t)"\xce\f" - 24));
    function_aff4(0x1f40, (int32_t *)0x20000cee, (char)&g106);
    uint32_t v3 = (int32_t)*(int16_t *)0x20000cee; // 0x5e52
    if (v3 != (int32_t)&g10 && v3 >= (int32_t)&g10) {
        // 0x5e58
        *(int16_t *)0x20000cee = (int16_t)&g86;
        *(int16_t *)0x20000cf0 = 2000;
    }
    // 0x5e62
    *(int16_t *)0x20000cf8 = 2300;
    int32_t v4 = 2 * (int32_t)*(char *)0x20000aa8 & 254; // 0x5e70
    function_aff4(v4 + 0x1f50, (int32_t *)0x20000abc, 2);
    function_aff4(v4 + 0x1f68, (int32_t *)0x20000abe, 2);
    unsigned char v5 = *(char *)0x20000ad5; // 0x5e94
    function_aff4((int32_t)v5 + ((int32_t)&g61 << (int32_t)&g82), (int32_t *)&v1, 1);
    uint32_t v6 = (int32_t)v1 % 256; // 0x5ea4
    int16_t * v7 = v1; // 0x5ea8
    if (v6 != (int32_t)&g24 && v6 >= (int32_t)&g24) {
        // 0x5eaa
        v1 = (int16_t *)(int32_t)(char)&g126;
        v7 = (int16_t *)(int32_t)(char)&g126;
    }
    // 0x5eb0
    *(char *)0x20000ad6 = (char)(int32_t)v7;
    function_aff4(0x1f88, &v2, (char)&g90);
    int32_t v8 = 0x10000 * v2 >> 16; // 0x5ec6
    int16_t v9 = v8 + 1000 < (int32_t)&g86 + 101 ? (int16_t)v8 : 0;
    *(int16_t *)0x20000b24 = v9;
    int16_t v10; // 0x5de8
    *(int16_t *)0x20000470 = v10 & (int16_t)(0xffffffff >> (int32_t)&g14);
    *(int16_t *)0x20000472 = (int16_t)a4 & (int16_t)(0xffffffff >> (int32_t)&g14 & 0xffff);
    char v11; // 0x5de8
    uint32_t v12 = (int32_t)v11; // 0x5efa
    char v13 = v12 == (int32_t)&g61 | v12 < (int32_t)&g61 ? v11 : 58; // 0x5f0c
    *(char *)0x20000b27 = v13;
    uint32_t v14 = (int32_t)v11; // 0x5f10
    int16_t * v15 = v14 == (int32_t)&g126 | v14 < (int32_t)&g126 ? (int16_t *)(int32_t)v11 : (int16_t *)(int32_t)(char)&g90;
    v1 = v15;
    *(char *)0x20000b28 = (char)(int32_t)v15;
    return function_af00(&g56, (int32_t)(*(int16_t *)0x20000b24 + 0x5880));
}

// Address range: 0x5f5c - 0x6274
int32_t function_5f5c(char a1, int32_t a2) {
    int32_t v1 = a1;
    char v2; // 0x5f5c
    char v3 = v2;
    int32_t v4 = v1 * (int32_t)&g67; // 0x5f64
    int32_t v5 = v4 + (int32_t)&g96 + 0x20000a94; // 0x5f74
    char * v6 = (char *)(v1 + 0x20000a94); // 0x5f8e
    unsigned char v7 = *v6; // 0x5f8e
    int32_t v8 = 205; // 0x5f92
    if (v7 < 217) {
        int32_t v9 = v7; // 0x5f8e
        if (v7 >= 207) {
            int32_t v10 = *(int32_t *)((v9 - (int32_t)&g110 << (int32_t)&g16) / 0x400000 + (int32_t)&g122); // 0x5fa8
            function_7020(v5, v9, 2, v10);
            int32_t result = 0x20000a94; // 0x5fb8
            if (*(char *)0x20000aaf != 0) {
                // 0x5fba
                *(char *)0x20000aaf = 0;
                *"o\x03" = 1;
                result = 1;
            }
            // 0x5fc4
            return result;
        }
        // 0x5fc8
        v8 = v9;
        if (v7 < 200) {
            int32_t v11 = function_2004(v9, 1, 0, 0); // 0x5fd4
            if (v11 == 255) {
                unsigned char v12 = *(char *)(v1 + 0x20000a96); // 0x6018
                *v6 = v12;
                v8 = v12;
            } else {
                char v13 = v11; // 0x5fe0
                *v6 = v13;
                *(char *)(v1 + 0x20000a98) = v13;
                v8 = v11;
            }
        }
    }
    unsigned char v14 = *(char *)(v8 + 0x20000bb4); // 0x5fe6
    if (v14 == -1) {
        int32_t v15 = v8; // 0x6020
        if (v8 < (int32_t)&g108) {
            unsigned char v16 = *(char *)(v1 + 0x20000a96); // 0x6024
            *v6 = v16;
            v15 = v16;
        }
        uint32_t v17 = (v15 - (int32_t)&g108) % 256; // 0x602c
        int32_t v18 = *(int32_t *)(4 * v17 + *(int32_t *)0x200003f8); // 0x6034
        // 0x5fc4
        return function_7020(v5, v15, v17, v18);
    }
    char v19; // 0x5f5c
    int16_t * v20; // 0x5f5c
    if (v8 < (int32_t)&g108) {
        uint32_t v21 = (int32_t)v14 & 0xffffffff >> (int32_t)&g20; // 0x5fee
        int16_t * v22 = v21 == 6 | v21 < 6 ? (int16_t *)v21 : (int16_t *)5;
        *(char *)(v4 + 0x20000b5a) = (char)(int32_t)v22;
        *(char *)(v4 + 0x20000b58) = v14 / 128;
        v20 = v22;
        v19 = v14 / 64 % 2;
    } else {
        uint32_t v23 = v8 - (int32_t)&g108; // 0x6042
        *(char *)(v4 + 0x20000b5a) = (char)v23;
        *(char *)(v4 + 0x20000b58) = 1;
        v20 = (int16_t *)(v23 % 256);
        v19 = 1;
    }
    // 0x604e
    *(char *)(v4 + 0x20000b59) = v19;
    *(char *)(v4 + (int32_t)&g96 + 0x20000ab2) = (char)v8;
    int32_t * v24; // 0x5f5c
    int32_t v25; // 0x5f5c
    if (v8 < (int32_t)&g108) {
        // 0x6064
        v25 = v8 << (int32_t)&g62;
        if (a2 == 2) {
            goto lab_0x6070;
        } else {
            // 0x6064
            v24 = (int32_t *)v5;
            goto lab_0x6174;
        }
    } else {
        int32_t v26 = a1 == 0 ? (int32_t)&g17 << (int32_t)&g82 : 3184;
        v25 = (32 * v8 - v26) % 0x10000;
        goto lab_0x6070;
    }
  lab_0x6070:;
    // 0x6070
    int32_t v27; // bp-48, 0x5f5c
    function_aff4((v25 + 8) % 0x10000, &v27, (char)&g90);
    int32_t v28 = v2; // 0x6080
    uint32_t v29 = v28 & 0xffffffff >> (int32_t)&g20; // 0x6084
    char v30 = v29 == 2 | v29 < 2 ? (char)v29 : 0; // 0x608c
    *(char *)(v4 + (int32_t)&g96 + 0x20000ab3) = v30;
    *(char *)(v4 + 0x20000b5e) = (char)(v28 << (int32_t)&g19 >> (int32_t)&g24);
    uint32_t v31 = (int32_t)v2; // 0x609a
    int32_t v32 = v31 < (int32_t)&g82 ? v31 : 5;
    *(char *)(v4 + 0x20000b52) = (char)v32;
    int16_t v33 = *(int16_t *)(2 * v32 + 0xe0c8); // 0x60a8
    *(int16_t *)(v4 + (int32_t)&g96 + 0x20000ab0) = v33;
    uint32_t v34 = (int32_t)v2; // 0x60ae
    char v35 = v34 == (int32_t)&g97 | v34 < (int32_t)&g97 ? v2 : 0; // 0x60b6
    *(char *)(v4 + 0x20000b56) = v35;
    char * v36 = (char *)(v4 + (int32_t)&g96 + 0x20000a98); // 0x60c0
    *v36 = v2 & (char)(0xffffffff >> (int32_t)&g20);
    char * v37 = (char *)(v4 + (int32_t)&g96 + 0x20000aa0); // 0x60c8
    *v37 = (char)((int32_t)v2 >> (int32_t)&g62);
    char v38 = *v36; // 0x60cc
    uint32_t v39 = v27 % 256; // 0x60ce
    char v40; // 0x5f5c
    if (v38 == 1) {
        // 0x60ee
        v40 = v27;
        if (v39 < (int32_t)&g47) {
            goto lab_0x60fa;
        } else {
            // 0x60f8
            v40 = 0;
            goto lab_0x60fa;
        }
    } else {
        if ((v38 || 1) == 3) {
            // 0x60f4
            v40 = v27;
            if (v39 < (int32_t)&g79) {
                goto lab_0x60fa;
            } else {
                // 0x60f8
                v40 = 0;
                goto lab_0x60fa;
            }
        } else {
            // 0x60dc
            *v36 = 0;
            // 0x60f8
            v40 = 0;
            goto lab_0x60fa;
        }
    }
  lab_0x6174:;
    uint16_t v41 = *(int16_t *)(v4 + (int32_t)&g96 + 0x20000a94 + (int32_t)&g20); // 0x6174
    int32_t v42 = v41; // 0x6174
    int32_t v43 = 4 * (int32_t)v20; // 0x617e
    uint32_t v44 = *v24; // 0x6180
    uint32_t v45 = *(int32_t *)(*(int32_t *)0x200003f8 + v43); // 0x6182
    int32_t v46 = v45; // 0x6186
    if (v45 >= v44 != v45 != v44) {
        uint32_t v47 = *(int32_t *)(*(int32_t *)0x200003f4 + v43); // 0x618c
        v46 = v47 < v44 ? v45 : v44;
        if (v8 >= (int32_t)&g108 && v47 >= v44) {
            // 0x61b0
            v46 = function_108c(v44, v42, v45);
        }
    }
    // 0x61b6
    *v24 = v46;
    uint32_t v48 = v46 - 0xa4cb80; // 0x61ba
    if (v48 >= 0x2ab976 == (v48 != 0x2ab976)) {
        if (v8 >= (int32_t)&g108) {
            int32_t * v49 = (int32_t *)(v4 + (int32_t)&g96 + 0x20000aac); // 0x61ce
            *v49 = function_108c(*v49, v42, 0);
        }
    } else {
        // 0x61c2
        *(char *)(v4 + (int32_t)&g96 + 0x20000ab3) = 0;
    }
    // 0x61d8
    function_14d8(v5);
    int32_t * v50 = (int32_t *)(v4 + (int32_t)&g96 + 0x20000ac8); // 0x61e0
    *v50 = 0;
    int32_t * v51 = (int32_t *)(v4 + (int32_t)&g96 + 0x20000acc); // 0x61e2
    *v51 = 0;
    *(int32_t *)(v4 + (int32_t)&g96 + 0x20000ad0) = 0;
    *(int32_t *)(v4 + (int32_t)&g96 + 0x20000ad4) = 0;
    if (v8 < (int32_t)&g108) {
        int32_t v52 = v8 << (int32_t)&g62; // 0x61ee
        function_aff4(v52 + 3920, &v27, (char)&g90);
        *v51 = (int32_t)v3;
        *v50 = v27;
        function_aff4(v52 + (int32_t)&g128, &v27, (char)&g90);
        *(int16_t *)(v4 + 0x20000b68) = (int16_t)v27;
    }
    int32_t v53 = v4 + 0x20000b34; // 0x6220
    if (*(char *)(v4 + 0x20000b55) == 1) {
        // 0x6234
        *(int32_t *)(v4 + (int32_t)&g96 + 0x20000aa8) = v5;
        *(int32_t *)(v4 + (int32_t)&g96 + 0x20000aa4) = v53;
    } else {
        // 0x6226
        *(int32_t *)(v4 + (int32_t)&g96 + 0x20000aa4) = v5;
        *(int32_t *)(v4 + (int32_t)&g96 + 0x20000aa8) = v53;
    }
    // 0x624c
    if (*(char *)(v4 + 0x20000b5a) == 1) {
        // 0x6252
        if (*(char *)(v4 + 0x20000b5e) != 1) {
            // 0x6258
            *(char *)(v4 + 0x20000b5f) = 0;
            // 0x5fc4
            return function_12a8(v5);
        }
        // 0x6264
        *(char *)(v4 + 0x20000b5f) = 1;
        *(char *)(v4 + 0x20000b56) = 0;
        *(char *)(v4 + 0x20000b5b) = 0;
        *(char *)(v4 + (int32_t)&g96 + 0x20000a98) = 0;
        *(char *)(v4 + (int32_t)&g96 + 0x20000aa0) = 0;
        // 0x5fc4
        return function_12a8(v5);
    }
    // 0x6258
    *(char *)(v4 + 0x20000b5f) = 0;
    // 0x5fc4
    return function_12a8(v5);
  lab_0x60fa:
    // 0x60fa
    *(char *)(v4 + (int32_t)&g96 + 0x20000a99) = v40;
    char v54 = *v37; // 0x60fe
    uint32_t v55 = (int32_t)v2; // 0x6100
    char v56; // 0x5f5c
    if (v54 == 1) {
        if (v55 < (int32_t)&g47) {
            goto lab_0x6120;
        } else {
            // 0x611e
            v56 = 0;
            goto lab_0x6120;
        }
    } else {
        if ((v54 || 1) == 3) {
            if (v55 < (int32_t)&g79) {
                goto lab_0x6120;
            } else {
                // 0x611e
                v56 = 0;
                goto lab_0x6120;
            }
        } else {
            // 0x610e
            *v37 = 0;
            // 0x611e
            v56 = 0;
            goto lab_0x6120;
        }
    }
  lab_0x6120:
    // 0x6120
    *(char *)(v4 + (int32_t)&g96 + 0x20000aa1) = v56;
    if (v3 == -1) {
        // 0x6196
        *(char *)(v4 + 0x20000b55) = 0;
        *(char *)(v4 + 0x20000b57) = 0;
        *(char *)(v4 + 0x20000b53) = 2;
        *(char *)(v4 + 0x20000b5d) = 0;
    } else {
        int32_t v57 = v3; // 0x6124
        *(char *)(v4 + 0x20000b55) = v3 & (char)(0xffffffff >> (int32_t)&g24);
        *(char *)(v4 + 0x20000b57) = (char)(v57 << (int32_t)&g23 >> (int32_t)&g24);
        *(char *)(v4 + 0x20000b53) = (char)(v57 << (int32_t)&g20 >> (int32_t)&g23);
        *(char *)(v4 + 0x20000b5d) = (char)(v57 << (int32_t)&g19 >> (int32_t)&g24);
    }
    if (v2 == -1) {
        // 0x61a4
        *(char *)(v4 + 0x20000b5b) = 0;
        *(char *)(v4 + 0x20000b5c) = 0;
    } else {
        // 0x614a
        *(char *)(v4 + 0x20000b5b) = v2 & (char)(0xffffffff >> (int32_t)&g24);
        *(char *)(v4 + 0x20000b5c) = (char)((int32_t)v2 << (int32_t)&g21 >> (int32_t)&g23);
    }
    // 0x6156
    function_aff4(v25, &v27, (char)&g90);
    int32_t * v58 = (int32_t *)v5;
    *v58 = v27;
    int32_t v59 = v3 > -1 ? (int32_t)v3 : 0xf4240;
    *(int32_t *)(v4 + (int32_t)&g96 + 0x20000aac) = v59;
    v24 = v58;
    goto lab_0x6174;
}

// Address range: 0x62b4 - 0x68b2
int32_t function_62b4(void) {
    // 0x62b4
    char v1; // 0x62b4
    unsigned char v2 = v1;
    unsigned char v3 = v1;
    unsigned char v4 = v1;
    char v5 = v1;
    unsigned char v6 = v1;
    unsigned char v7 = v1;
    unsigned char v8 = v1;
    int32_t v9; // bp-48, 0x62b4
    int32_t v10; // 0x62b4
    function_1aa(&v9, (int32_t *)&g11, v10, v10);
    function_aff4(3696, &v9, (char)&g90);
    uint32_t v11 = v9; // 0x62ce
    char v12 = v11 % 256 < (int32_t)&g108 ? (char)v11 : 0;
    *(char *)((int32_t)"\xd4\n" + 3) = v12;
    uint32_t v13 = (int32_t)v8; // 0x62e4
    char v14 = v13 == (int32_t)&g95 | v13 < (int32_t)&g95 ? v8 : (char)&g62;
    *(char *)((int32_t)"\xd4\n" - 48) = v14;
    uint32_t v15 = (int32_t)v7; // 0x62f2
    char v16 = v15 == (int32_t)&g97 | v15 < (int32_t)&g97 ? v7 : 2;
    *(char *)((int32_t)"\xd4\n" - 47) = v16;
    bool v17 = v6 == 1 | v6 == 0; // 0x630c
    *(char *)((int32_t)"\xd4\n" + 82) = v17 ? v6 : 1;
    *(char *)((int32_t)"\xd4\n" - 46) = v5 == 1 | v5 == 0 ? v5 : 0;
    *(char *)((int32_t)"\xd4\n" - 45) = v4 == 1 | v4 == 0 ? v4 : 0;
    uint32_t v18 = (int32_t)v3; // 0x6332
    char v19 = v18 == (int32_t)&g95 | v18 < (int32_t)&g95 ? v3 : 5; // 0x633a
    *(char *)((int32_t)"\xd4\n" - 44) = v19;
    uint32_t v20 = (int32_t)v2; // 0x633e
    char v21 = v20 == (int32_t)&g62 | v20 < (int32_t)&g62 ? v2 : 2;
    *(char *)((int32_t)"\xd4\n" + 1) = v21;
    function_aff4(3704, &v9, (char)&g90);
    *(char *)((int32_t)"\xd4\n" - 41) = v8 == 2 | v8 < 2 ? v8 : 0;
    *(char *)((int32_t)"\xd4\n" - 37) = v7 == 2 | v7 < 2 ? v7 : 0;
    uint32_t v22 = (int32_t)v6; // 0x6376
    char v23 = v22 == (int32_t)&g62 | v22 < (int32_t)&g62 ? v6 : (char)&g62; // 0x637e
    *(char *)((int32_t)"\xd4\n" - 36) = v23;
    *(char *)((int32_t)"\xd4\n" - 38) = v5 == 2 | v5 < 2 ? v5 : 1;
    *(char *)((int32_t)"\xd4\n" - 35) = v4 == 5 | v4 < 5 ? v4 : 5;
    bool v24 = v3 == 1 | v3 == 0; // 0x63a0
    *(char *)((int32_t)"\xd4\n" - 40) = v24 ? v3 : 1;
    *(char *)((int32_t)"\xd4\n" - 39) = v2 == 1 | v2 == 0 ? v2 : 1;
    function_aff4((int32_t)&g21 << (int32_t)&g82, &v9, (char)&g90);
    uint32_t v25 = v9; // 0x63c4
    char v26 = v25 % 256 < 217 ? (char)v25 : -51;
    *(char *)((int32_t)"\xd4\n" - 64) = v26;
    *(char *)((int32_t)"\xd4\n" - 63) = v6 < 217 ? v6 : -51;
    char v27; // bp-47, 0x62b4
    unsigned char v28 = v27; // 0x63e2
    uint32_t v29 = (int32_t)v28;
    char v30 = v29 < (int32_t)&g108 ? v28 : 0;
    *(char *)((int32_t)"\xd4\n" - 60) = v30;
    uint32_t v31 = (int32_t)v5; // 0x63f0
    char v32 = v31 < (int32_t)&g108 ? v5 : 0;
    *(char *)((int32_t)"\xd4\n" - 59) = v32;
    char v33; // bp-46, 0x62b4
    uint32_t v34 = (int32_t)v33;
    char v35 = v34 - (int32_t)&g108 < (int32_t)&g82 ? v33 : -51;
    *(char *)((int32_t)"\xd4\n" - 62) = v35;
    int32_t v36 = v4; // 0x6410
    char v37 = v36 - (int32_t)&g108 < (int32_t)&g82 ? v4 : -51;
    *(char *)((int32_t)"\xd4\n" - 61) = v37;
    *(char *)((int32_t)"\xd4\n" - 58) = v18 < 217 ? v3 : -49;
    *(char *)((int32_t)"\xd4\n" - 57) = v20 < 217 ? v2 : -49;
    function_aff4(3720, &v9, (char)&g90);
    *(int16_t *)((int32_t)"\xd4\n" - 12) = 760;
    *(int16_t *)((int32_t)"\xd4\n" - 10) = 1080;
    uint32_t v38 = v9 % 0x10000; // 0x6464
    int16_t v39; // 0x62b4
    if (v38 >= 1080 == (v38 != 1080)) {
        // 0x646e
        v39 = 760;
        goto lab_0x6472;
    } else {
        // 0x646a
        v39 = v9;
        if (v38 < 760) {
            // 0x646e
            v39 = 760;
            goto lab_0x6472;
        } else {
            goto lab_0x6472;
        }
    }
  lab_0x6472:
    // 0x6472
    *(int16_t *)((int32_t)"\xd4\n" - 20) = v39;
    *(char *)((int32_t)"\xd4\n" - 18) = v33;
    *(char *)((int32_t)"\xd4\n" - 17) = v17 ? v6 : 0;
    function_aff4(3648, (int32_t *)0x20000c8e, (char)&g34);
    function_20a0();
    function_aff4(3728, &v9, (char)&g90);
    uint32_t v40 = v9 % 256; // 0x64b2
    char v41 = v40 == 1 | v40 == 0 ? (char)v9 : 1;
    *(char *)((int32_t)"\xd4\n" - 42) = v41;
    char v42 = v29 == (int32_t)&g90 | v29 < (int32_t)&g90 ? v28 : (char)&g44; // 0x64d0
    *(char *)((int32_t)"\xd4\n" - 3) = v42;
    char v43 = v34 == (int32_t)&g90 | v34 < (int32_t)&g90 ? v33 : (char)&g90; // 0x64dc
    *(char *)((int32_t)"\xd4\n" - 2) = v43;
    char v44 = v22 == (int32_t)&g90 | v22 < (int32_t)&g90 ? v6 : 1;
    *(char *)((int32_t)"\xd4\n" - 1) = v44;
    char v45 = v31 == (int32_t)&g90 | v31 < (int32_t)&g90 ? v5 : 6;
    *"\xd4\n" = v45;
    *(char *)((int32_t)"\xd4\n" - 34) = v4 == 2 | v4 < 2 ? v4 : 1;
    *(char *)((int32_t)"\xd4\n" - 8) = v24 ? v3 : 0;
    *(char *)((int32_t)"\xd4\n" - 6) = v2 == 2 | v2 < 2 ? v2 : 1;
    function_aff4(3736, &v9, (char)&g90);
    *(int32_t *)((int32_t)"\xd4\n" - 52) = v9;
    function_aff4(3744, &v9, (char)&g90);
    uint32_t v46 = v9 % 256; // 0x6554
    char v47 = v46 == 2 | v46 < 2 ? (char)v9 : 1;
    *(char *)((int32_t)"\xd4\n" - 43) = v47;
    function_aff4(3752, &v9, (char)&g90);
    uint32_t v48 = v9 % 256; // 0x6576
    char v49 = v48 == 1 | v48 == 0 ? (char)v9 : 1;
    *(char *)((int32_t)"\xd4\n" - 7) = v49;
    *(char *)((int32_t)"\xd4\n" - 5) = v28 == 2 | v28 < 2 ? v28 : 0;
    char v50 = v34 == (int32_t)&g97 | v34 < (int32_t)&g97 ? v33 : 0;
    *(char *)((int32_t)"\xd4\n" - 4) = v50;
    *(char *)((int32_t)"\xd4\n" - 55) = v6 < 2 ? v6 : 0;
    function_aff4(3792, &v9, (char)&g90);
    uint32_t v51 = v9 % 256; // 0x65c2
    char v52 = v51 == 1 | v51 == 0 ? (char)v9 : 1;
    *(char *)((int32_t)"\xd4\n" + 78) = v52;
    int32_t v53 = function_1eb8(&v27, 1); // 0x65d4
    char v54 = v53 == 1 ? v27 : (char)&g35;
    *(char *)((int32_t)"\xd4\n" + 64) = v54;
    int32_t v55 = function_1eb8(&v33, 1); // 0x65ec
    char v56 = v55 == 1 ? v33 : (char)&g29;
    *(char *)((int32_t)"\xd4\n" + 65) = v56;
    char v57 = v22 == (int32_t)&g44 | v22 < (int32_t)&g44 ? v6 : 0;
    *(char *)((int32_t)"\xd4\n" + 66) = v57;
    char v58 = v31 - 5 < (int32_t)&g55 ? v5 : 5;
    *(char *)((int32_t)"\xd4\n" + 67) = v58;
    int32_t v59 = v36 - (int32_t)&g44 < 98 ? v36 * (int32_t)&g97 : 300;
    *(int16_t *)((int32_t)"\xd4\n" + 68) = (int16_t)v59;
    int16_t v60 = v18 - (int32_t)&g44 < 98 ? (int16_t)v3 * (int16_t)&g97 : (int16_t)&g78;
    *(int16_t *)((int32_t)"\xd4\n" + 70) = v60;
    int16_t v61 = v20 - (int32_t)&g44 < 98 ? (int16_t)v2 * (int16_t)&g97 : (int16_t)&g78;
    *(int16_t *)((int32_t)"\xd4\n" + 72) = v61;
    function_aff4(3800, &v9, (char)&g90);
    uint32_t v62 = v9 % 256; // 0x6668
    int16_t v63 = v62 - (int32_t)&g44 < 98 ? (int16_t)v62 * (int16_t)&g97 : (int16_t)&g78;
    *(int16_t *)((int32_t)"\xd4\n" + 74) = v63;
    unsigned char v64 = v27; // 0x667c
    int16_t v65 = (int32_t)v64 - (int32_t)&g44 < 98 ? (int16_t)v64 * (int16_t)&g97 : (int16_t)&g78;
    *(int16_t *)((int32_t)"\xd4\n" + 76) = v65;
    char v66 = v33; // 0x6690
    *(char *)((int32_t)"\xd4\n" + 79) = v66 == 1 | v66 == 0 ? v66 : 0;
    function_aff4(3808, &v9, (char)&g90);
    if (function_1eb8((char *)&v9, (int32_t)&g90) == 1) {
        // 0x66d4
        *(int32_t *)((int32_t)"\x94\n" + 72) = (int32_t)v5;
        *(int32_t *)((int32_t)"\x94\n" + 68) = v9;
    } else {
        // 0x66b4
        function_178((int32_t *)((int32_t)"\xd4\n" + 4), "123");
    }
    // 0x66de
    function_aff4(3816, &v9, (char)&g90);
    if (function_1eb8((char *)&v9, (int32_t)&g90) == 1) {
        // 0x6702
        *(int32_t *)((int32_t)"\x94\n" + 80) = (int32_t)v5;
        *(int32_t *)((int32_t)"\x94\n" + 76) = v9;
    } else {
        // 0x66f4
        function_178((int32_t *)((int32_t)"\x94\n" + 76), "ABCD9");
    }
    // 0x670c
    function_aff4(3824, &v9, (char)&g90);
    if (function_1eb8((char *)&v9, (int32_t)&g90) == 1) {
        // 0x6732
        *(int32_t *)((int32_t)"\x94\n" + 88) = (int32_t)v5;
        *(int32_t *)((int32_t)"\x94\n" + 84) = v9;
    } else {
        // 0x6724
        function_178((int32_t *)((int32_t)"\x94\n" + 84), "9DCBA");
    }
    // 0x673c
    function_aff4(3832, &v9, (char)&g2);
    if (function_1eb8((char *)&v9, (int32_t)&g2) == 1) {
        // 0x6762
        *(int32_t *)((int32_t)"\x94\n" + 92) = v9;
        *(int32_t *)((int32_t)"\x94\n" + 96) = (int32_t)v5;
    } else {
        // 0x6754
        function_178((int32_t *)((int32_t)"\x94\n" + 92), "12345");
    }
    // 0x676c
    function_aff4(3848, &v9, (char)&g2);
    int32_t v67 = function_1eb8((char *)&v9, (int32_t)&g2); // 0x677c
    int32_t v68 = &v9;
    int32_t v69 = v67 == 1 ? v68 : (int32_t)"54321";
    function_178((int32_t *)((int32_t)"\x94\n" + 110), (char *)v69);
    function_aff4(3864, &v9, (char)&g90);
    int32_t v70 = v9; // 0x67a6
    int32_t v71 = (v70 & 254) == 0 ? v70 : 0;
    *(char *)((int32_t)"\x94\n" + 31) = (char)v71;
    char v72 = v70;
    while (true) {
        // 0x67b6
        *(char *)((int32_t)"\x94\n" + 32) = v72 == 1 | v72 == 0 ? v72 : 0;
        *(char *)((int32_t)"\x94\n" + 34) = *(char *)(v68 | 1);
        char v73 = *(char *)(v68 + (int32_t)&g25); // 0x67de
        *(char *)((int32_t)"\x94\n" + 36) = v73;
    }
}

// Address range: 0x6904 - 0x697e
int32_t function_6904(void) {
    unsigned char v1 = *(char *)(*(int32_t *)0x200003d0 + 30); // 0x690e
    unsigned char v2 = v1 < 207 ? -127 : v1;
    *"\xfc\x03" = v1 < 207 ? 28 : 1;
    *"\xaa\x03" = 0;
    *"/\x04" = 0;
    int32_t v3; // 0x6904
    function_1aa((int32_t *)3340, (int32_t *)&g2, (int32_t)v2, v3);
    *"\xae\x03" = 0;
    *"\xab\x03" = 0;
    *"\xad\x03" = 0;
    *"\xaf\x03" = 0;
    *"\xb0\x03" = 0;
    *(int16_t *)0x20000342 = 0;
    *"D\x03" = 0;
    *"u\x03" = 0;
    *"v\x03" = 0;
    *"E\x03" = 0;
    *"F\x03" = 0;
    *"w\x03" = 0;
    *(int16_t *)0x20000354 = 0;
    return 0x20000354;
}

// Address range: 0x69d0 - 0x6b24
int32_t function_69d0(int32_t * a1) {
    // 0x69d0
    *(char *)((int32_t)(*(char *)0x20000a9c == 0) | 0x20000378) = 0;
    function_bfe4(0x40061000, (int32_t *)&g62);
    *"k\x03" = 1;
    function_5960();
    char v1 = *(char *)0x20000ab2; // 0x6a16
    if (v1 != 0 == v1 < 3) {
        // 0x6a42
        *(int16_t *)0x20000336 = 0;
        *"8\x03" = 0;
    }
    // 0x6a46
    *"\x13\x04" = 1;
    *"\x81\x03" = 2;
    if (*(char *)(*(int32_t *)0x200003d0 + 51) == 1) {
        // 0x6ae6
        function_af00(&g69, 0xb3a8);
        *"t\x04" = 0;
    } else {
        unsigned char v2 = *(char *)0x20000b27; // 0x6ac6
        unsigned char v3 = *(char *)0x20000b28; // 0x6acc
        function_af00(&g69, 16 * (int32_t)v2 + ((int32_t)&g102 << (int32_t)&g106) | (int32_t)v3);
    }
    // 0x6afe
    function_78bc((int32_t)a1);
    if (a1 == (int32_t *)2) {
        // 0x6b1c
        return function_782c(0);
    }
    // 0x6b12
    *"p\x03" = 1;
    return (int32_t)"p\x03";
}

// Address range: 0x6b88 - 0x6bc0
int32_t function_6b88(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x6b88
    __asm_adr(48);
    function_c08c();
    int32_t v1 = -108; // bp-16, 0x6b98
    int32_t result = function_b02a((int32_t)&g21 << (int32_t)&g82, (int32_t)&v1); // 0x6bba
    return result;
}

// Address range: 0x6bc2 - 0x6bc6
int32_t function_6bc2(void) {
    // 0x6bc2
    int32_t result; // 0x6bc2
    bool v1; // 0x6bc2
    if (v1) {
        result = function_364d5a();
    }
    // 0x6bc6
    return result;
}

// Address range: 0x6bcc - 0x6ca8
int32_t function_6bcc(uint32_t a1, char a2, int32_t a3, char result2) {
    // 0x6bcc
    __asm_adr(204);
    int32_t result = function_c08c(); // 0x6be0
    if (a1 >= 207) {
        // 0x6ca4
        return result;
    }
    int32_t v1 = a1 << (int32_t)&g62; // 0x6be2
    int32_t v2; // 0x6bcc
    if (a1 < (int32_t)&g108) {
        // 0x6c00
        v2 = v1;
        if (result2 != 2) {
            // 0x6ca4
            return result2;
        }
    } else {
        int32_t v3 = a2 == 0 ? (int32_t)&g17 << (int32_t)&g82 : 3184;
        v2 = (32 * a1 - v3) % 0x10000;
    }
    int32_t v4 = a3; // bp-56, 0x6c0c
    int32_t v5 = &v4; // 0x6c12
    function_b02a(v2, v5);
    v4 = (int32_t)*(char *)(a3 + (int32_t)&g71);
    unsigned char v6 = *(char *)(a3 + (int32_t)&g26 + (int32_t)&g102); // 0x6c4c
    function_b02a((v2 + 8) % 0x10000, v5);
    result = function_6ef4(a1, a3, 1, 2 * (int32_t)v6);
    if (a1 < (int32_t)&g108) {
        // 0x6c82
        function_19c(v5, (int32_t)&g90, 255);
        function_b02a(v1 + 3920, v5);
        result = function_b02a(v1 + 3928, v5);
    }
    // 0x6ca4
    return result;
}

// Address range: 0x6caa - 0x6cae
int32_t function_6caa(void) {
    // 0x6caa
    int32_t result; // 0x6caa
    bool v1; // 0x6caa
    if (v1) {
        result = function_362652();
    }
    // 0x6cae
    return result;
}

// Address range: 0x6cb0 - 0x6cfa
int32_t function_6cb0(char a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a3; // bp-24, 0x6cb0
    __asm_adr(68);
    function_c08c();
    int32_t v2 = &v1; // 0x6cbe
    function_19c(v2, (int32_t)&g90, 255);
    v1 = (int32_t)*(int16_t *)0x20000ac0;
    function_b02a(3720, v2);
    uint32_t v3 = 0; // 0x6ce4
    int32_t v4 = 8 * v3; // 0x6ce6
    int32_t result = function_b02a(v4 + 3648, v4 + 0x20000c8e); // 0x6cec
    v3 = (v3 + 1) % 256;
    while (v3 < 5) {
        // 0x6ce6
        v4 = 8 * v3;
        result = function_b02a(v4 + 3648, v4 + 0x20000c8e);
        v3 = (v3 + 1) % 256;
    }
    // 0x6cf8
    return result;
}

// Address range: 0x6d10 - 0x6ec8
int32_t function_6d10(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x6d10
    __asm_adr(432);
    function_c08c();
    int32_t v1; // bp-32, 0x6d10
    int32_t v2 = &v1; // 0x6d1c
    v1 = (int32_t)*(char *)0x20000ad7;
    function_b02a(3696, v2);
    v1 = -1;
    function_b02a(3704, v2);
    v1 = (int32_t)*(char *)(0x20000aea - (int32_t)&g63);
    function_b02a(3728, v2);
    function_19c(v2, (int32_t)&g90, 255);
    v1 = *(int32_t *)(0x20000ae0 - (int32_t)&g63);
    function_b02a(3736, v2);
    function_19c(v2, (int32_t)&g90, 255);
    v1 = (int32_t)*(char *)(0x20000ae9 - (int32_t)&g63);
    function_b02a(3744, v2);
    char v3 = *(char *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g26 + 25); // 0x6dd4
    v1 = v3;
    function_b02a(3752, v2);
    char v4 = *(char *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + 14); // 0x6dee
    v1 = v4;
    uint16_t v5 = *(int16_t *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + (int32_t)&g62); // 0x6e04
    function_128((int32_t)v5, (int32_t *)&g97);
    uint16_t v6 = *(int16_t *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + 6); // 0x6e10
    function_128((int32_t)v6, (int32_t *)&g97);
    uint16_t v7 = *(int16_t *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + (int32_t)&g90); // 0x6e1c
    function_128((int32_t)v7, (int32_t *)&g97);
    function_b02a(3792, v2);
    function_19c(v2, (int32_t)&g90, 255);
    uint16_t v8 = *(int16_t *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + (int32_t)&g97); // 0x6e3a
    v1 = 0x1000000 * function_128((int32_t)v8, (int32_t *)&g97) >> 24;
    uint16_t v9 = *(int16_t *)(0x20000ad4 - (int32_t)&g63 + (int32_t)&g91 + (int32_t)&g106); // 0x6e46
    function_128((int32_t)v9, (int32_t *)&g97);
    function_b02a(3800, v2);
    v1 = (int32_t)*(char *)(0x20000af3 - (int32_t)&g63);
    function_b02a(3864, v2);
    function_19c(v2, (int32_t)&g90, 255);
    v1 = 105;
    return function_b02a(3904, v2);
}

// Address range: 0x6eca - 0x6ece
int32_t function_6eca(void) {
    // 0x6eca
    int32_t result; // 0x6eca
    bool v1; // 0x6eca
    if (v1) {
        result = function_35f8a6();
    }
    // 0x6ece
    return result;
}

// Address range: 0x6ef4 - 0x6f50
int32_t function_6ef4(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2; // bp-32, 0x6ef4
    __asm_adr(80);
    int32_t result = function_c08c(); // 0x6f06
    if (a1 >= 207) {
        // 0x6f34
        return result;
    }
    int32_t v2 = (a1 & -1 << (int32_t)&g44) + 3424; // 0x6f10
    function_aff4(v2, &v1, (char)&g90);
    int32_t result2 = a1 & 0xffffffff >> (int32_t)&g21; // 0x6f1e
    int32_t v3 = &v1; // 0x6f20
    char * v4; // 0x6ef4
    char v5; // 0x6ef4
    if (a3 == 1) {
        unsigned char v6 = *(char *)(a2 + (int32_t)&g26 + (int32_t)&g106); // 0x6f38
        unsigned char v7 = *(char *)(a2 + (int32_t)&g26 + (int32_t)&g111); // 0x6f3a
        unsigned char v8 = *(char *)(a2 + (int32_t)&g26 + (int32_t)&g121); // 0x6f42
        int32_t v9 = (64 * (int32_t)v7 | (int32_t)v6 << (int32_t)&g82) % 256 | (int32_t)v8; // 0x6f46
        char * v10 = (char *)(result2 + v3);
        v4 = v10;
        v5 = v9;
        if (v9 == (int32_t)*v10) {
            // 0x6f34
            return result2;
        }
    } else {
        // 0x6f08
        v4 = (char *)(result2 + v3);
        v5 = -1;
    }
    // 0x6f28
    *v4 = v5;
    function_b02a(v2, v3);
    *(char *)(a1 + 0x20000bb4) = v5;
    // 0x6f34
    return 0x20000bb4;
}

// Address range: 0x6f50 - 0x6f5c
int32_t function_6f50(int32_t a1, int32_t a2) {
    // 0x6f50
    bool v1; // 0x6f50
    if (v1) {
        __asm_stclvs(6, 7, a2, -460);
    }
    int32_t result = a1; // 0x6f54
    if (v1) {
        result = function_360100();
    }
    // 0x6f58
    return result;
}

// Address range: 0x6f60 - 0x6fe2
int32_t function_6f60(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x6f60
    switch (*(char *)0x20000acf) {
        case 1: {
            // 0x6f70
            function_ae6c();
            // break -> 0x6fda
            break;
        }
        case 2: {
            // 0x6f76
            function_ad94();
            // break -> 0x6fda
            break;
        }
    }
    // 0x6fda
    return function_9f8c(1);
}

// Address range: 0x6ff8 - 0x701c
int32_t function_6ff8(void) {
    int32_t v1 = *(int32_t *)(*(int32_t *)0x200003d4 + (int32_t)&g11); // 0x6ffe
    unsigned char v2 = *(char *)(v1 + (int32_t)&g62); // 0x7000
    if (v2 == 2 || (int32_t)v2 == (int32_t)&g44) {
        // 0x7016
        function_ab10();
    } else {
        // 0x700a
        function_ab28();
    }
    // 0x700e
    return function_d0ec((int32_t)&g108);
}

// Address range: 0x7020 - 0x7066
int32_t function_7020(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = (int32_t *)a1; // 0x702c
    function_1aa(v1, &g67, a3, a4);
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g121) = (char)a3;
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g106) = 1;
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g111) = 1;
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g76) = 5;
    *(int16_t *)(a1 + (int32_t)&g20) = 2500;
    *(char *)(a1 + (int32_t)&g23) = (char)a2;
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g95) = 0;
    *(char *)(a1 + (int32_t)&g26 + (int32_t)&g82) = 2;
    *v1 = a4;
    int32_t v2 = a1 + (int32_t)&g90; // 0x7050
    *(int32_t *)v2 = a4;
    *(int32_t *)(a1 + (int32_t)&g2) = a1;
    *(int32_t *)(a1 + (int32_t)&g16) = 0xf4240;
    *(int32_t *)(a1 + (int32_t)&g11) = v2;
    return function_12a8(a1);
}

// Address range: 0x7070 - 0x739c
int32_t function_7070(char a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x7070
    int32_t v1; // bp-40, 0x7070
    int32_t v2; // bp-44, 0x7070
    if (function_22f8(-59, &v1, &v2) == 0) {
        uint32_t v3 = v1 % 256; // 0x708c
        uint32_t v4 = *(int32_t *)0x20000450; // 0x708e
        if (v4 < v3) {
            // 0x709c
            *(int32_t *)0x20000450 = v3;
            goto lab_0x709e;
        } else {
            uint32_t v5 = v2 % 256; // 0x7096
            if (v4 == v5 || v4 < v5) {
                goto lab_0x709e;
            } else {
                // 0x709c
                *(int32_t *)0x20000450 = v5;
                goto lab_0x709e;
            }
        }
    } else {
        goto lab_0x709e;
    }
  lab_0x709e:
    // 0x709e
    function_c73e(0x20000a94, 0x20000450, 0x200003cc, 197);
    *(int16_t *)0x200003bf = 1;
    *(int32_t *)0x200003c5 = 1;
    *(int32_t *)0x200003c9 = 0x2000039d;
    *(int32_t *)0x200003cd = 197;
    float64_t v6; // 0x7070
    __asm_vqadd_s8(v6, v6);
    g59 = 197;
    int32_t v7; // 0x7070
    __asm_ldc(9, 12, *(int32_t *)(v7 + (int32_t)&g57));
    return __asm_adr(628);
}

// Address range: 0x739c - 0x73a2
int32_t function_739c(int32_t result, int32_t a2, int32_t a3) {
    // 0x739c
    return result;
}

// Address range: 0x7408 - 0x7448
int32_t function_7408(void) {
    // 0x7408
    int32_t v1; // bp-32, 0x7408
    int32_t v2 = function_af60((int32_t)&v1); // 0x740e
    int32_t v3 = function_a73e((char)v2); // 0x7412
    char * v4; // bp-40, 0x7408
    function_a77e((int32_t *)&v4);
    int32_t v5; // bp-16, 0x7408
    int32_t v6; // bp-36, 0x7408
    function_9d7c(&v6, &v5);
    uint32_t v7 = v6 + (int32_t)v4; // 0x7430
    v4 = (char *)(0x10000 * v7 / 0x10000);
    int32_t v8; // 0x7408
    return function_166((v7 % 0x10000 | v3 + 0x6c16 << (int32_t)&g2) ^ v8);
}

// Address range: 0x744c - 0x74a2
int32_t function_744c(int32_t a1, int32_t a2) {
    // 0x744c
    function_1d7c();
    int32_t v1 = *(int32_t *)0x200003d0; // 0x745a
    unsigned char v2 = *(char *)(v1 + 30); // 0x745c
    *"\x10\x04" = v2;
    *"\x80\x03" = (char)a2;
    *"\x15\x04" = 0;
    if (v2 < 200) {
        if (a1 == 1) {
            // 0x7482
            *"\x14\x04" = v2;
        }
        // 0x7486
        function_7dac();
    } else {
        if (a1 == 1) {
            // 0x7472
            *(int32_t *)0x20000418 = *(int32_t *)v1;
        }
        // 0x7478
        function_82a8();
    }
    // 0x748a
    *(int16_t *)0x20000336 = (int16_t)&g47;
    *"8\x03" = 0;
    *"\x11\x04" = 0;
    *"\x12\x04" = 0;
    *"\x13\x04" = 0;
    return (int32_t)"\x13\x04";
}

// Address range: 0x74d0 - 0x74f2
int32_t function_74d0(int32_t a1) {
    // 0x74d0
    *"\x81\x03" = 1;
    *"\x1e\x04" = (char)a1;
    function_1d7c();
    function_7ea0();
    *(int16_t *)0x20000336 = (int16_t)&g47;
    *"8\x03" = 0;
    return 0;
}

// Address range: 0x7504 - 0x7564
int32_t function_7504(int16_t a1, int32_t a2, int32_t a3) {
    // 0x7504
    function_bf98(0x40061000, (int32_t)&g62);
    *"k\x03" = 0;
    *(int16_t *)0x2000034c = (int16_t)&g97;
    *"N\x03" = 0;
    *"\x90\x03" = (char)a2;
    *"'\x04" = 0;
    *"(\x04" = 0;
    *")\x04" = 0;
    if (a3 == 1) {
        // 0x755a
        *(int16_t *)0x20000ac4 = a1;
        return function_a2f0(a1);
    }
    uint32_t v1 = (int32_t)a1 + a2; // 0x7540
    uint32_t v2 = v1 % 0x10000; // 0x7542
    uint16_t v3 = *(int16_t *)0x20000aca; // 0x7544
    uint16_t v4 = *(int16_t *)0x20000ac8;
    int16_t v5 = v4; // 0x7548
    if (v2 <= (int32_t)v3) {
        uint32_t v6 = (int32_t)v4;
        v5 = v2 == v6 | v2 > v6 ? (int16_t)v1 : v3;
    }
    // 0x755a
    *(int16_t *)0x20000ac4 = v5;
    return function_a2f0(v5);
}

// Address range: 0x7588 - 0x7640
int32_t function_7588(void) {
    // 0x7588
    function_7820();
    function_1d7c();
    int32_t v1 = *(int32_t *)0x200003d0; // 0x7594
    char * v2 = (char *)(v1 + 30); // 0x7596
    unsigned char v3 = *v2; // 0x7596
    char v4 = v3; // 0x759a
    if (v3 >= 207) {
        // 0x759c
        *v2 = -51;
        v4 = -51;
    }
    int32_t v5 = *(int32_t *)*(int32_t *)(v1 + 16); // 0x75a6
    function_7020(v1, (int32_t)v4, (int32_t)*(char *)(v1 + 46), v5);
    int32_t v6 = *(int32_t *)0x200003d0; // 0x75b4
    *(char *)(v6 + (int32_t)&g32) = *(char *)(v1 + 38);
    *(int16_t *)(v6 + 28) = *(int16_t *)(v1 + 28);
    function_1ab8(1);
    *"\xc9\x03" = 0;
    *"^\x04" = 0;
    *(int32_t *)0x20000454 = -1;
    function_a06c((char)function_1e0c(-1));
    *"]\x04" = (char)&g12;
    *"[\x04" = -1;
    *"Z\x04" = -1;
    *"_\x04" = 0;
    *"\\\x04" = 0;
    *"\xaa\x03" = 0;
    *"\xae\x03" = 0;
    *"\xab\x03" = 0;
    *"\xac\x03" = 0;
    *"\xad\x03" = 0;
    *"\xaf\x03" = 0;
    *"\xb0\x03" = 0;
    *"a\x04" = 0;
    *"d\x04" = 0;
    return (int32_t)"d\x04";
}

// Address range: 0x7690 - 0x76f8
int32_t function_7690(void) {
    // 0x7690
    *"o\x03" = 1;
    int32_t result; // 0x7690
    if (*(char *)0x20000b26 == 0) {
        // 0x76da
        result = (int32_t)"\xc9\x03";
        *(char *)result = 0;
        return result;
    }
    // 0x76a4
    if (*(char *)(0x20000b2e - (int32_t)&g91) == 0) {
        unsigned char v1 = *(char *)(*(int32_t *)0x200003d0 + 30); // 0x76e2
        int32_t result2 = (int32_t)"\xc9\x03"; // 0x76e6
        if (v1 >= 207) {
            // 0x76e8
            *"\xc9\x03" = 1;
            *"n\x04" = v1 + 49;
            *(int16_t *)0x20000356 = (int16_t)&g47;
            result2 = 0x20000358;
        }
        // 0x76da
        *(char *)result2 = 0;
        return result2;
    }
    // 0x76b0
    if (*(char *)(0x20000b14 - (int32_t)&g91) >= 207) {
        // 0x76c4
        *"n\x04" = *(char *)(0x20000bca - (int32_t)&g91) + 49;
        *"\xc9\x03" = 1;
        return (int32_t)"\xc9\x03";
    }
    // 0x76b6
    if (*(char *)(0x20000b15 - (int32_t)&g91) < 207) {
        // 0x76da
        result = (int32_t)"\xc9\x03";
        *(char *)result = 0;
        return result;
    }
    int32_t v2 = &g67;
    char v3 = *(char *)(v2 + 0x20000bca - (int32_t)&g91); // 0x76cc
    *"n\x04" = v3 + 49;
    *"\xc9\x03" = 1;
    return (int32_t)"\xc9\x03";
}

// Address range: 0x7714 - 0x7788
int32_t function_7714(void) {
    // 0x7714
    *"\x80\x03" = 0;
    unsigned char v1 = *(char *)0x20000a9c; // 0x7768
    int32_t v2 = v1; // 0x7768
    *(char *)(v2 + 0x20000a98) = 20;
    *(char *)(v2 + 0x20000a94) = 20;
    function_5f5c(v1, 2);
    function_1ab8(1);
    *"p\x03" = 1;
    return 1;
}

// Address range: 0x77a8 - 0x77b8
int32_t function_77a8(char a1, char a2, char a3) {
    // 0x77a8
    *"\x81\x03" = 0;
    return function_1ab8(1);
}

// Address range: 0x77bc - 0x7800
int32_t function_77bc(void) {
    // 0x77bc
    *"\x90\x03" = 0;
    function_20a0();
    int32_t v1; // 0x77bc
    function_6cb0((char)function_a2f0(*(int16_t *)0x20000ac4), v1, v1, v1);
    *(int16_t *)0x2000034c = 0;
    *"N\x03" = 0;
    *"(\x04" = 0;
    function_bfe4(0x40061000, (int32_t *)&g62);
    *"k\x03" = 1;
    return (int32_t)"k\x03";
}

// Address range: 0x7820 - 0x782c
int32_t function_7820(void) {
    // 0x7820
    int32_t v1; // 0x7820
    return function_a07c(function_a088(v1, v1));
}

// Address range: 0x782c - 0x7880
int32_t function_782c(int32_t a1) {
    int32_t result = 255; // 0x782c
    switch (a1) {
        default: {
            // 0x783c
            *"\xe6\x03" = 0;
            *"\xc6\x03" = 0;
            *"\x81\x03" = 0;
            *"\x80\x03" = 0;
            *"\x90\x03" = 0;
            *"C\x04" = 0;
            *"\xba\x03" = 0;
            *"\xbb\x03" = 0;
            *"h\x03" = 0;
            *"(\x04" = 0;
            *")\x04" = 0;
        }
        case 217: {
            // 0x7878
            *"\xd9\x03" = (char)a1;
            *"p\x03" = 1;
            result = (int32_t)"p\x03";
        }
        case 255: {
            // 0x787e
            return result;
        }
    }
}

// Address range: 0x78bc - 0x7b06
int32_t function_78bc(int32_t a1) {
    // 0x78bc
    int32_t v1; // 0x78bc
    int32_t v2 = v1;
    *"\xd8\x03" = (char)a1;
    switch (a1) {
        case 0: {
            // 0x7936
            function_1fec();
            // 0x7970
            *"0\x03" = 0;
            *(int16_t *)0x2000032e = 1000;
            // 0x792a
            return 1000;
        }
        case 1: {
            // 0x798e
            function_1cd8(function_87d0(131, v2), v2, v1, v1);
            function_a794(5, 1);
            *"\xbe\x03" = 0;
            function_9fbc(1, 500, (int32_t)"\x14\v" - 60, v1);
            function_d0ec(2);
            function_bfe4(0x40061000, (int32_t *)&g62);
            *"k\x03" = 1;
            *" \x04" = 0;
            goto lab_0x7b00;
        }
        default: {
            if (a1 == (int32_t)&g44 || a1 == (int32_t)&g62) {
                goto lab_0x7b00;
            } else {
                int32_t result = (int32_t)"\xd8\x03"; // 0x78bc
                switch (a1) {
                    case 2: {
                        goto lab_0x7b00;
                    }
                    case 5: {
                        unsigned char v3 = *(char *)((int32_t)"\x14\v" - 100); // 0x78fe
                        *(int16_t *)0x20000332 = (int16_t)v3 * (int16_t)&g97;
                        *"\xda\x03" = 1;
                        function_a600();
                        function_ab40();
                        function_a794(0, 0);
                        *"4\x03" = 0;
                        *"o\x03" = 1;
                        result = function_782c(0);
                        // 0x792a
                        return result;
                    }
                    default: {
                        return result;
                    }
                }
            }
        }
    }
  lab_0x7b00:
    // 0x7b00
    *(int16_t *)0x2000038e = 0;
    // 0x7970
    *"0\x03" = 0;
    *(int16_t *)0x2000032e = 1000;
    // 0x792a
    return 1000;
}

// Address range: 0x7b74 - 0x7c68
int32_t function_7b74(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x7b74
    if (*(char *)0x20000aae != 0) {
        // 0x7b82
        *(int16_t *)0x2000033a = 360;
        *"<\x03" = 0;
        *"\x1f\x04" = 1;
    }
    // 0x7ba8
    function_1de0();
    function_78bc(1);
    *(int16_t *)0x2000033e = 0;
    *"@\x03" = 0;
    *"\xfd\x03" = 0;
    *"m\x03" = 0;
    *"\xbe\x03" = 0;
    return (int32_t)"\xbe\x03";
}

// Address range: 0x7cb0 - 0x7cc2
int32_t function_7cb0(void) {
    // 0x7cb0
    int32_t v1; // 0x7cb0
    function_6f60((char)v1, v1, v1, v1);
    function_6ff8();
    return function_1ab8(0);
}

// Address range: 0x7cc4 - 0x7cdc
int32_t function_7cc4(void) {
    // 0x7cc4
    function_a794(0, 1);
    return function_aedc();
}

// Address range: 0x7ce0 - 0x7d86
int32_t function_7ce0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x7ce0
    *"g\x04" = 0;
    *"p\x03" = 1;
    int32_t v1 = function_a960((int32_t *)&g102); // 0x7cf6
    function_a63c();
    int32_t v2 = 0; // 0x7d04
    int32_t result; // 0x7d52
    if (v1 << (int32_t)&g19 < 0 || (int32_t)&g101 != 3386 || (int32_t)"_DCS" != 0x492c) {
        // 0x7d50
        result = (int32_t)*(int16_t *)0x2000046c + 1;
        *(int16_t *)0x2000046c = (int16_t)result;
        return result;
    }
    int32_t v3 = 2 * v2; // 0x7d20
    int16_t v4 = *(int16_t *)(v3 + 3388); // 0x7d28
    int16_t v5 = *(int16_t *)((v3 & 14) + 0xe198); // 0x7d2a
    v2 = v2 + 1 & (int32_t)&g129;
    *(int16_t *)(v3 + (int32_t)&g25 + 3386) = v5 ^ v4;
    while (v2 < (int32_t)&g28) {
        // 0x7d20
        v3 = 2 * v2;
        v4 = *(int16_t *)(v3 + 3388);
        v5 = *(int16_t *)((v3 & 14) + 0xe198);
        v2 = v2 + 1 & (int32_t)&g129;
        *(int16_t *)(v3 + (int32_t)&g25 + 3386) = v5 ^ v4;
    }
    int32_t v6 = function_afa4(3388, 66); // 0x7d3c
    int32_t v7 = &g89; // 0x7d44
    uint32_t v8 = 0; // 0x7d44
    int32_t v9 = 0x2000; // 0x7d44
    if (v6 != 0xd10d || (int32_t)&g126 << (int32_t)&g95 <= 0x2000) {
        // 0x7d50
        result = (int32_t)*(int16_t *)0x2000046c + 1;
        *(int16_t *)0x2000046c = (int16_t)result;
        return result;
    }
    function_b02a(v9, v7);
    v8 = (v8 + 1) % 256;
    v7 += (int32_t)&g90;
    v9 = (v9 + 8) % 0x10000;
    while (v8 < 8) {
        // 0x7d5c
        function_b02a(v9, v7);
        v8 = (v8 + 1) % 256;
        v7 += (int32_t)&g90;
        v9 = (v9 + 8) % 0x10000;
    }
    if ((int32_t)&g126 << (int32_t)&g95 == 0x2040) {
        // 0x7d76
        *"f\x04" = 2;
    }
    int32_t result2 = (int32_t)*(int16_t *)0x2000046a + 1; // 0x7d80
    *(int16_t *)0x2000046a = (int16_t)result2;
    return result2;
}

// Address range: 0x7dac - 0x7e7e
int32_t function_7dac(void) {
    unsigned char v1 = *(char *)((int32_t)&g24 + 0x20000a94); // 0x7db8
    char v2 = *(char *)((int32_t)v1 + (int32_t)&g26 + 0x20000a94); // 0x7dbe
    if (v2 == 1) {
        // 0x7e6c
        *(int16_t *)0x20000336 = (int16_t)&g11;
        *"\x13\x04" = 0;
        *"\x15\x04" = 0;
        // 0x7e7a
        return 0;
    }
    int32_t v3 = function_2004(144, -128, 1, (int32_t)*(char *)0x20000ab3); // 0x7e30
    int32_t result = 255; // 0x7e36
    if (v3 != 255) {
        // 0x7e5c
        *"\x10\x04" = (char)v3;
        *(int16_t *)0x20000336 = (int16_t)&g11;
        *"\x13\x04" = 0;
        result = 0;
    }
    // 0x7e7a
    return result;
}

// Address range: 0x7ea0 - 0x7f06
int32_t function_7ea0(void) {
    // 0x7ea0
    return 80;
}

// Address range: 0x7f24 - 0x7f96
int32_t function_7f24(void) {
    char v1 = *(char *)((int32_t)"\x94\n" + 8); // 0x7f2c
    *(char *)((int32_t)"\x94\n" + 8) = (char)(v1 == 0);
    int32_t v2 = v1 == 0 ? (int32_t)&g67 + (int32_t)"\x94\n" + 152 : (int32_t)"\x94\n" + 152; // 0x7f42
    *(int32_t *)0x200003d0 = v2;
    function_1ab8(0);
    *(int16_t *)0x2000033a = (int16_t)&g97;
    return 0x2000033a;
}

// Address range: 0x7fa8 - 0x8196
int32_t function_7fa8(void) {
    // 0x7fa8
    return (int32_t)"\xaa\x03";
}

// Address range: 0x8204 - 0x8284
int32_t function_8204(void) {
    uint16_t v1 = *(int16_t *)0x20000ac4; // 0x8208
    int32_t v2; // 0x8204
    if (function_a098((int32_t)v1, *(int16_t *)0x20000ac8, v2, v2) != 0) {
        // 0x825a
        function_7504(v1, -112, 0);
        // 0x827c
        return function_782c(1);
    }
    // 0x8224
    *(int16_t *)0x2000034c = 0;
    *"'\x04" = 1;
    if (*(char *)0x20000ac3 == 0) {
        // 0x8268
        *(int16_t *)0x20000ac0 = v1;
    }
    // 0x826a
    function_bfe4(0x40061000, (int32_t *)&g62);
    *"k\x03" = 1;
    // 0x827c
    return function_782c(1);
}

// Address range: 0x82a8 - 0x82de
int32_t function_82a8(void) {
    // 0x82a8
    function_1558(*(int32_t *)0x200003d0, -128);
    function_14d8(*(int32_t *)0x200003d0);
    function_12a8(*(int32_t *)0x200003d0);
    function_1ab8(1);
    *"p\x03" = 1;
    *(int16_t *)0x20000336 = (int16_t)&g97;
    *"\x13\x04" = 0;
    return 0;
}

// Address range: 0x82f4 - 0x8308
int32_t function_82f4(void) {
    // 0x82f4
    *"n\x04" = 0;
    return (int32_t)"n\x04";
}

// Address range: 0x830c - 0x83d8
int32_t function_830c(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x830c
    if (*(int16_t *)0x200003b6 == 0) {
        uint16_t result = *(int16_t *)0x200003b8; // 0x832a
        if (result != 0) {
            // 0x8382
            return result;
        }
    } else {
        // 0x8324
        *"\xaf\x03" = 0;
        *(int16_t *)0x200003b8 = 0;
    }
    // 0x8382
    return 128;
}

// Address range: 0x8418 - 0x846e
int32_t function_8418(char a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 1; // 0x8418
    int32_t v2 = 0; // 0x8418
    switch (a1) {
        case 1: {
            // 0x844c
            return function_b5b4(110, 0, (int32_t *)&g7, 0xd3cd, 0);
        }
        case 2: {
            // 0x844c
            return function_b5b4(110, 0, (int32_t *)&g7, 0xd3df, 0);
        }
        default: {
            int32_t v3 = a1;
            v1 = 0;
            v2 = 0xd3f1;
            if (v3 != (int32_t)&g44) {
                // 0x8434
                v1 = 0;
                v2 = v3 == (int32_t)&g62 ? 0xd403 : 0xd415;
            }
        }
        case 0: {
            // 0x844c
            return function_b5b4(110, 0, (int32_t *)&g7, v2, v1);
        }
    }
}

// Address range: 0x8478 - 0x84b6
int32_t function_8478(int32_t a1) {
    char v1; // 0x8478
    switch (a1) {
        case 0: {
            // 0x8494
            *"q\x03" = 0;
            *(char *)((int32_t)"q\x03" + 1) = 0;
            v1 = 0;
            // break -> 0x84ae
            break;
        }
        case 6: {
            // 0x849e
            *"q\x03" = 6;
            *(char *)((int32_t)"q\x03" + 1) = (char)&g44;
            v1 = 5;
            // break -> 0x84ae
            break;
        }
        default: {
            char v2 = *(char *)0x20000aaf; // 0x848a
            unsigned char v3 = *((v2 == 0 ? (char *)0x20000a9c : (char *)0x20000a9d));
            *(char *)((int32_t)v3 + (int32_t)"q\x03") = (char)a1;
            v1 = 5;
            // break -> 0x84ae
            break;
        }
    }
    // 0x84ae
    *"s\x03" = v1;
    *"p\x03" = 1;
    return 1;
}

// Address range: 0x84c8 - 0x8580
int32_t function_84c8(int32_t a1, char a2, int32_t a3, char a4) {
    // 0x84c8
    return 217;
}

// Address range: 0x8594 - 0x859c
int32_t function_8594(void) {
    // 0x8594
    int32_t v1; // 0x8594
    bool v2; // 0x8594
    if (v2) {
        v1 = function_4759dc();
    }
    int32_t result = v1; // 0x8598
    if (v2) {
        result = function_2660c();
    }
    // 0x859c
    return result;
}

// Address range: 0x859e - 0x85bc
int32_t function_859e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = a1; // 0x859e
    bool v1; // 0x859e
    if (v1) {
        result = function_3d09a6();
    }
    unsigned char v2 = *(char *)(a2 + a4); // 0x85a4
    if ((int32_t)v2 == (int32_t)&g97) {
        // 0x85b8
        *(char *)(a2 + result) = (char)&g37;
    } else {
        // 0x85aa
        *(char *)(a2 + result) = v2 + (char)&g45;
    }
    int32_t v3 = a2 + (int32_t)&g1 & (int32_t)&g129; // 0x85b0
    while (v3 < (int32_t)&g44) {
        int32_t v4 = v3;
        v2 = *(char *)(v4 + a4);
        if ((int32_t)v2 == (int32_t)&g97) {
            // 0x85b8
            *(char *)(v4 + result) = (char)&g37;
        } else {
            // 0x85aa
            *(char *)(v4 + result) = v2 + (char)&g45;
        }
        // 0x85ae
        v3 = v4 + (int32_t)&g1 & (int32_t)&g129;
    }
    // 0x85b6
    return result;
}

// Address range: 0x85bc - 0x85da
int32_t function_85bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x85bc
    int32_t v1; // 0x85bc
    int32_t v2; // 0x85bc
    if (a2 == 1) {
        // 0x85c6
        v1 = __asm_adr(28);
        return function_c6e8(a1, v1, a3 + 1, v2);
    }
    if (a3 == 255) {
        // 0x85d2
        return function_c6e8(a1, __asm_adr(32), 255, v2);
    }
    // 0x85c6
    v1 = __asm_adr(28);
    return function_c6e8(a1, v1, a3 + 1, v2);
}

// Address range: 0x85da - 0x863c
int32_t function_85da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x85da
    int32_t v1; // 0x85da
    int32_t v2 = v1 << (int32_t)&g126; // 0x85dc
    *(int32_t *)(v2 + (int32_t)&g63) = a4;
    *(char *)(a2 + 1 * (int32_t)&g37) = (char)v2;
    *"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" = (char)&g65;
    *(char *)((int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 1) = (char)&g69;
    *(char *)((int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 2) = (char)&g37;
    int32_t v3 = 0;
    char v4 = *(char *)(v3 + 0x200003e7); // 0x8616
    if (v4 == 10) {
        // 0x862c
        *(char *)(v3 + (int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 3) = (char)&g37;
    } else {
        // 0x861c
        *(char *)(v3 + (int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 3) = v4 + 48;
    }
    uint32_t v5 = (v3 + 1) % 256; // 0x8624
    while (v5 < 2) {
        // 0x8616
        v3 = v5;
        v4 = *(char *)(v3 + 0x200003e7);
        if (v4 == 10) {
            // 0x862c
            *(char *)(v3 + (int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 3) = (char)&g37;
        } else {
            // 0x861c
            *(char *)(v3 + (int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a" + 3) = v4 + 48;
        }
        // 0x8622
        v5 = (v3 + 1) % 256;
    }
    // 0x862a
    return (int32_t)"\xd2\xd1\xa4\x1f\xad\x1f\xcf\xe7\x04\a";
}

// Address range: 0x864c - 0x8704
int32_t function_864c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a2 + 0x20000704 + (a3 << (uint32_t)(int32_t)&g82); // 0x8656
    int32_t v2 = 0;
    int32_t v3 = v1 + (int32_t)&g91;
    unsigned char v4 = *(char *)(v2 + a1); // 0x8666
    int32_t v5; // 0x864c
    int32_t v6; // 0x864c
    int32_t v7; // 0x864c
    int32_t v8; // 0x867c
    int32_t v9; // 0x8688
    if (a4 != 1 == v4 == 0) {
        // 0x86f8
        v7 = 0;
        v5 = v3;
        v6 = v1;
        if (a5 == 1) {
            // 0x86fe
            v7 = 0;
            v5 = v3 - (int32_t)&g76;
            v6 = v1 - 6;
        }
    } else {
        // 0x8676
        v8 = (int32_t)v4 * (int32_t)&g18;
        v9 = v2 * (int32_t)&g111;
        function_178((int32_t *)(v9 + v1), (char *)(v8 + 0xd502));
        function_178((int32_t *)(v9 + v3), (char *)(v8 + 0xd50f));
        v7 = 1;
        v5 = v3;
        v6 = v1;
    }
    int32_t v10 = v6;
    int32_t v11 = v5;
    int32_t v12 = v2 + 1 & (int32_t)&g129; // 0x86a6
    while (v12 < (int32_t)&g44) {
        // 0x8664
        v2 = v12;
        int32_t v13 = v10;
        v3 = v11;
        v4 = *(char *)(v2 + a1);
        if (a4 != 1 == v7 == 0 == v4 == 0) {
            // 0x86f8
            v7 = 0;
            v5 = v3;
            v6 = v13;
            if (a5 == 1) {
                // 0x86fe
                v7 = 0;
                v5 = v3 - (int32_t)&g76;
                v6 = v13 - 6;
            }
        } else {
            // 0x8676
            v8 = (int32_t)v4 * (int32_t)&g18;
            v9 = v2 * (int32_t)&g111;
            function_178((int32_t *)(v9 + v13), (char *)(v8 + 0xd502));
            function_178((int32_t *)(v9 + v3), (char *)(v8 + 0xd50f));
            v7 = 1;
            v5 = v3;
            v6 = v13;
        }
        // 0x86a4
        v10 = v6;
        v11 = v5;
        v12 = v2 + 1 & (int32_t)&g129;
    }
    // 0x86ac
    *(char *)(v11 + (int32_t)&g33) = (char)&g77;
    *(char *)(v11 + (int32_t)&g33 + (int32_t)&g1) = (char)&g77;
    *(char *)(v11 + (int32_t)&g33 + (int32_t)&g25) = (char)&g77;
    int32_t v14 = v11 + (int32_t)&g33 + (int32_t)&g44; // 0x86b8
    int32_t v15 = (char)v10 + (char)&g35; // 0x86d4
    int32_t v16 = 0; // 0x86be
    unsigned char v17 = *(char *)(a1 + (int32_t)&g44 + v16); // 0x86c2
    int32_t v18 = (int32_t)v17 * (int32_t)&g18; // 0x86c6
    int32_t v19 = v16 * (int32_t)&g111; // 0x86d2
    function_178((int32_t *)(v19 + v15), (char *)(v18 + 0xd502));
    int32_t result = function_178((int32_t *)(v14 + v19), (char *)(v18 + (int32_t)&g111 + 0xd502)); // 0x86e8
    v16 = v16 + 1 & (int32_t)&g129;
    while (v16 < (int32_t)&g44) {
        // 0x86c0
        v17 = *(char *)(a1 + (int32_t)&g44 + v16);
        v18 = (int32_t)v17 * (int32_t)&g18;
        v19 = v16 * (int32_t)&g111;
        function_178((int32_t *)(v19 + v15), (char *)(v18 + 0xd502));
        result = function_178((int32_t *)(v14 + v19), (char *)(v18 + (int32_t)&g111 + 0xd502));
        v16 = v16 + 1 & (int32_t)&g129;
    }
    // 0x86f4
    return result;
}

// Address range: 0x870c - 0x8744
int32_t function_870c(uint32_t a1, int32_t * a2, int32_t a3, int32_t * a4) {
    // 0x870c
    if (a1 == 0) {
        // 0x8740
        return 0;
    }
    int32_t v1 = a3 + 0x20000704 + ((int32_t)a4 << (int32_t)&g82); // 0x871a
    int32_t v2 = 0; // 0x873a
    unsigned char v3 = *(char *)(v2 + (int32_t)a2); // 0x8726
    int32_t result = function_178((int32_t *)(v1 + v2 * ((1 << (int32_t)&g44) - 1)), (char *)((int32_t)v3 * ((1 << (int32_t)&g44) - 1) + (int32_t)&g116)); // 0x8734
    v2 = v2 + 1 & (int32_t)&g129;
    while (v2 < a1) {
        // 0x8722
        v3 = *(char *)(v2 + (int32_t)a2);
        result = function_178((int32_t *)(v1 + v2 * ((1 << (int32_t)&g44) - 1)), (char *)((int32_t)v3 * ((1 << (int32_t)&g44) - 1) + (int32_t)&g116));
        v2 = v2 + 1 & (int32_t)&g129;
    }
    // 0x8740
    return result;
}

// Address range: 0x874c - 0x87c6
int32_t function_874c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = (int32_t)a1;
    uint32_t v2 = function_1c0(v1) % 256; // 0x875c
    int32_t v3 = a2; // 0x8762
    if (a6 == 1) {
        uint32_t v4 = 1 - a2 + a3 + -1 * v2 * a5; // 0x876c
        v3 = (((v4 >> (int32_t)&g24) + v4) / 2 + a2) % 256;
    }
    int32_t result = (a4 << (int32_t)&g82) + 0x20000704; // 0x877c
    if (v2 == 0) {
        // 0x87c2
        return result;
    }
    int32_t v5 = 0;
    unsigned char v6 = *(char *)(v5 + v1); // 0x878a
    int32_t v7 = (int32_t)v6 - (int32_t)&g26; // 0x878c
    int32_t result2 = v7; // 0x8790
    int32_t v8; // 0x874c
    int32_t v9; // 0x8794
    if (v7 < 95) {
        // 0x8792
        v9 = v7 << (int32_t)&g16 >> (int32_t)&g11;
        v8 = v3 + result + v5 * a5;
        function_178((int32_t *)v8, (char *)(v9 + (int32_t)&g117));
        result2 = function_178((int32_t *)(v8 + 128), (char *)(v9 + (int32_t)&g117 + (int32_t)&g90));
    }
    int32_t v10 = v5 + 1 & (int32_t)&g129; // 0x87bc
    while (v10 < v2) {
        // 0x8788
        v5 = v10;
        v6 = *(char *)(v5 + v1);
        v7 = (int32_t)v6 - (int32_t)&g26;
        result2 = v7;
        if (v7 < 95) {
            // 0x8792
            v9 = v7 << (int32_t)&g16 >> (int32_t)&g11;
            v8 = v3 + result + v5 * a5;
            function_178((int32_t *)v8, (char *)(v9 + (int32_t)&g117));
            result2 = function_178((int32_t *)(v8 + 128), (char *)(v9 + (int32_t)&g117 + (int32_t)&g90));
        }
        // 0x87ba
        v10 = v5 + 1 & (int32_t)&g129;
    }
    // 0x87c2
    return result2;
}

// Address range: 0x87d0 - 0x87ea
int32_t function_87d0(int32_t a1, int32_t a2) {
    // 0x87d0
    int32_t v1; // 0x87d0
    return function_8d08(function_c73e(217, a2, v1, 217), a2, v1, 217);
}

// Address range: 0x87ea - 0x87f0
int32_t function_87ea(int32_t a1) {
    // 0x87ea
    return function_8934();
}

// Address range: 0x87f0 - 0x87f6
int32_t function_87f0(int32_t a1) {
    // 0x87f0
    return function_9440();
}

// Address range: 0x87f6 - 0x87fc
int32_t function_87f6(int32_t a1) {
    // 0x87f6
    return function_8af8();
}

// Address range: 0x87fc - 0x8802
int32_t function_87fc(int32_t a1) {
    // 0x87fc
    return function_8808();
}

// Address range: 0x8808 - 0x88d2
int32_t function_8808(void) {
    // 0x8808
    int32_t v1; // 0x8808
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v1, v1);
    int32_t v2 = __asm_adr(184); // 0x8822
    int32_t v3; // bp-32, 0x8808
    function_c6e8((int32_t)&v3, v2, v1, v1);
    function_874c(&v3, 2, 127, 0, (int32_t)&g90, 1);
    function_864c(0x200003e7, (int32_t *)&g2, 2, 1, 0);
    v3 = 0;
    function_874c(&v3, 2, 127, (int32_t)&g62, (int32_t)&g90, 1);
    return function_b638();
}

// Address range: 0x8920 - 0x8934
int32_t function_8920(int32_t a1) {
    int32_t v1 = a1; // 0x8920
    bool v2; // 0x8920
    if (!v2) {
        v1 = function_1599670();
    }
    int32_t result = v1; // 0x8924
    if (v2) {
        result = v1 - 1061;
    }
    if (v2) {
        int32_t v3; // 0x8920
        if ((1 << v3 - 1 & v3) != 0) {
            // 0x8930
            return result;
        }
    } else {
        if (v2) {
            // 0x8930
            return result;
        }
    }
    // 0x8930
    return function_111c280();
}

// Address range: 0x8934 - 0x8a7e
int32_t function_8934(void) {
    // 0x8934
    int32_t v1; // 0x8934
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v1, v1);
    int32_t v2 = 0; // bp-40, 0x8944
    int32_t v3 = __asm_adr(312); // 0x894a
    int32_t v4 = &v2; // 0x894c
    function_c6e8(v4, v3, v1, v1);
    function_874c(&v2, 0, 127, 0, (int32_t)&g106, 1);
    v2 = 0;
    function_c6e8(v4, __asm_adr(260), 39, 0);
    function_874c(&v2, 0, 127, 2, (int32_t)&g97, 1);
    v2 = 0;
    if (*(char *)0x20000ac3 == 1) {
        // 0x8a4a
        function_874c(&v2, 0, 127, (int32_t)&g62, (int32_t)&g97, 1);
    } else {
        // 0x8a72
        function_864c(0x200003e7, (int32_t *)&g14, (int32_t)&g62, 1, 0);
    }
    // 0x8a76
    return function_b638();
}

// Address range: 0x8af8 - 0x8c54
int32_t function_8af8(void) {
    // 0x8af8
    int32_t v1; // 0x8af8
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v1, v1);
    int32_t v2 = 0; // bp-40, 0x8b0a
    int32_t v3 = *(int32_t *)0x20000454; // 0x8b26
    int32_t v4 = function_508(v3, (int32_t)&g82 << (int32_t)&g82, v1, v1); // 0x8b28
    int32_t v5 = function_348(v4, (int32_t)&g82 << (int32_t)&g82, -0x771c970f, 0x3ee4f8b5); // 0x8b30
    int32_t v6 = __asm_adr(304); // 0x8b38
    int32_t v7 = &v2; // 0x8b3a
    function_c6e8(v7, v6, v5, (int32_t)&g82 << (int32_t)&g82);
    function_874c(&v2, 2, 127, 1, (int32_t)&g90, 0);
    v2 = 0;
    function_c6e8(v7, __asm_adr(280), 127, 1);
    function_874c(&v2, 2, 127, (int32_t)&g44, (int32_t)&g90, 0);
    v2 = 0;
    int32_t v8 = __asm_adr(188); // 0x8c30
    function_c6e8(v7, v8, 127, (int32_t)&g44);
    function_874c(&v2, 2, 127, 5, (int32_t)&g90, 0);
    return function_b638();
}

// Address range: 0x8c6e - 0x8c82
int32_t function_8c6e(void) {
    // 0x8c6e
    bool v1; // 0x8c6e
    int32_t v2; // 0x8c6e
    int32_t result = v1 ? v2 : v2; // 0x8c7a
    if (v1 ? (v2 & 512) != 0 : v1) {
        function_e9d196();
        result = function_a9452e();
    }
    // 0x8c82
    return result;
}

// Address range: 0x8c8c - 0x8c98
int32_t function_8c8c(int32_t a1) {
    // 0x8c8c
    int32_t result; // 0x8c8c
    bool v1; // 0x8c8c
    if (v1) {
        result = function_a93540();
    } else {
        // 0x8c90
        result = function_10ddda0();
    }
    // 0x8c94
    return result;
}

// Address range: 0x8cb4 - 0x8cc0
int32_t function_8cb4(int32_t a1) {
    int32_t result = a1; // 0x8cb4
    bool v1; // 0x8cb4
    if (!v1) {
        result = function_14d99cc();
    }
    // 0x8cb8
    return result;
}

// Address range: 0x8ccc - 0x8ce8
int32_t function_8ccc(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // 0x8ccc
    bool v2; // 0x8ccc
    if (!v2) {
        v1 = function_10ddde0();
    }
    uint32_t v3 = v1;
    uint32_t v4 = (v2 ? (int32_t)&g94 >> v3 : -1) & v3;
    int32_t v5; // 0x8ccc
    return (v2 ? v5 >> v4 : -1) & v4;
}

// Address range: 0x8d08 - 0x9420
int32_t function_8d08(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8d08
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (uint32_t)(int32_t)&g82), a3, a4);
    if (*(char *)0x20000aa6 == 1) {
        int32_t v1 = __asm_adr(996); // 0x8d30
        function_874c((int32_t *)v1, 0, 127, 1, (int32_t)&g90, 1);
        int32_t v2 = __asm_adr(996); // 0x8d40
        function_874c((int32_t *)v2, 0, 127, (int32_t)&g44, (int32_t)&g90, 1);
        // 0x9418
        return function_b638();
    }
    // 0x8d4e
    int32_t v3; // bp-88, 0x8d08
    int32_t v4 = &v3;
    char v5; // bp-82, 0x8d08
    int32_t v6 = &v5;
    char v7; // bp-72, 0x8d08
    int32_t v8 = &v7;
    int32_t v9; // bp-83, 0x8d08
    int32_t v10 = &v9;
    int32_t v11 = a4; // 0x8d08
    uint32_t v12 = 0; // 0x9410
    int32_t v13; // 0x8d08
    int32_t v14; // 0x8d08
    int32_t v15; // 0x8d08
    int32_t v16; // 0x8d08
    int32_t v17; // 0x8d08
    int32_t v18; // 0x8d08
    int32_t v19; // 0x8d08
    int32_t v20; // 0x8d08
    int32_t v21; // 0x8d08
    int32_t v22; // 0x8d08
    int32_t v23; // 0x8d08
    int32_t v24; // 0x8d08
    int32_t v25; // 0x8d08
    int16_t * v26; // 0x8d08
    int32_t v27; // 0x8d08
    unsigned char v28; // 0x8d52
    int32_t v29; // 0x8d52
    int32_t v30; // 0x8fbe
    int32_t * v31; // 0x8fc0
    while (true) {
      lab_0x8d4e:
        // 0x8d4e
        v22 = v12;
        if (v22 == (int32_t)*(char *)0x20000a9d) {
            int32_t v32 = v11;
            v28 = *(char *)(v22 + 0x20000a94);
            v29 = v28;
            v13 = v22 == 0 ? 0x20000704 : 0x20000904;
            function_178((int32_t *)(v13 | 2), (char *)((int32_t)"u\xd3" - 8));
            int32_t v33 = v22 == 0 ? 0x20000784 : 0x20000984;
            int32_t v34; // 0x8d08
            int32_t v35; // 0x8d08
            int32_t v36; // 0x8d08
            if (v28 < 200) {
                // 0x8f18
                function_178((int32_t *)(v33 | 2), (char *)((int32_t)"u\xd3" - 16));
                if (v22 == (int32_t)*(char *)0x20000a9d) {
                    // 0x8f38
                    function_178(&v9, "\xe7\x03");
                    v34 = (int32_t)&g44;
                    v35 = v10;
                    v36 = (int32_t)&g97;
                } else {
                    // 0x8f46
                    function_1e3c(v29 + 1, &v3, (int32_t)&g90, v32);
                    v34 = (int32_t)&g44;
                    v35 = v10;
                    v36 = (int32_t)&g97;
                }
            } else {
                if (v28 < 207) {
                    // 0x8f60
                    function_178((int32_t *)(v33 + 14), (char *)((int32_t)"u\xd3" + 72));
                    v7 = v28 + 57;
                    v34 = 1;
                    v35 = v8;
                    v36 = &g13;
                } else {
                    // 0x8f7e
                    function_178((int32_t *)(v33 + 7), (char *)((int32_t)"u\xd3" + 56));
                    if (v22 == (int32_t)*(char *)0x20000a9d) {
                        // 0x8f9c
                        v5 = -25;
                        v34 = 2;
                        v35 = v6;
                        v36 = (int32_t)&g126;
                    } else {
                        // 0x8faa
                        function_1e3c(v29 - 206, &v3, (int32_t)&g90, v32);
                        v34 = 2;
                        v35 = v6;
                        v36 = (int32_t)&g126;
                    }
                }
            }
            // 0x8fbe
            v15 = v36;
            v30 = v22 == 0 ? 1 : (int32_t)&g62 + 1;
            v31 = (int32_t *)v30;
            function_870c(v34, (int32_t *)v35, v15, v31);
            unsigned char v37 = *(char *)(v22 + 0x20000371); // 0x8fce
            if (v37 == 0) {
                // 0x9054
                v14 = v22 == 0 ? 0x20000804 : 0x20000a04;
                if (v29 - (int32_t)&g108 < 7) {
                    // 0x905c
                    if (v22 == (int32_t)*(char *)0x20000a9d) {
                        // 0x9062
                        function_864c((int32_t)"\xe7\x03", (int32_t *)&g24, 4 * v22 & 252, 1, 0);
                        v18 = 1;
                        v21 = v14;
                        v24 = v22;
                        goto lab_0x9246;
                    } else {
                        goto lab_0x9076;
                    }
                } else {
                    goto lab_0x9076;
                }
            } else {
                int32_t v38 = v37; // 0x8fce
                v3 = 0;
                function_c73e(v38, 0, v15, v38);
                function_c6e8(v4, __asm_adr(412), v15, v38);
                v26 = (int16_t *)&g126;
                v16 = 111;
                v17 = 0;
                v20 = v15 >> (int32_t)&g16;
                v23 = 0;
                v27 = v4;
                goto lab_0x9242;
            }
        } else {
            // 0x8dc4
            function_c6e8(v4, __asm_adr(900), 0x20000d1c, (int32_t)"\xba\x03");
            uint32_t v39 = 3 * v22; // 0x8e1a
            function_874c(&v3, 2, 127, v39 % 256, (int32_t)&g90, 0);
            v3 = 0;
            int32_t v40 = (v39 + 2) % 256; // 0x8e92
            function_874c(&v3, 2, 127, v40, (int32_t)&g90, 0);
            v19 = v40;
            v25 = v22;
            goto lab_0x940e;
        }
    }
    // 0x9418
    return function_b638();
  lab_0x940e:
    // 0x940e
    v12 = (v25 + 1) % 256;
    v11 = v19;
    if (v12 >= 2) {
        return function_b638();
    }
    goto lab_0x8d4e;
  lab_0x9076:
    if (v28 < 200) {
        // 0x907a
        v18 = v30;
        v21 = v14;
        v24 = v22;
        switch (*(char *)0x20000aab) {
            case 2: {
                int32_t v41 = v22 * (int32_t)&g67 + 0x20000b60;
                if (*(char *)v41 < 1) {
                    goto lab_0x920c;
                } else {
                    // 0x922a
                    v26 = (int16_t *)&g90;
                    v16 = &g83;
                    v17 = 4 * v22 & 252;
                    v20 = v14;
                    v23 = v22;
                    v27 = v41;
                    goto lab_0x9242;
                }
            }
            case 0: {
                goto lab_0x90c0;
            }
            case 1: {
                goto lab_0x920c;
            }
            default: {
                goto lab_0x9246;
            }
        }
    } else {
        goto lab_0x90c0;
    }
  lab_0x9242:
    // 0x9242
    function_874c((int32_t *)v27, (int32_t)&g24, v16, v17, (int32_t)v26, 1);
    v18 = v17;
    v21 = v20;
    v24 = v23;
    goto lab_0x9246;
  lab_0x90c0:;
    int32_t v54 = *(int32_t *)(v22 * (int32_t)&g67 + 0x20000b3c);
    function_1e3c(*(int32_t *)v54, &v3, v15, v30);
    function_864c(v4, (int32_t *)&g24, 4 * v22 & 252, 0, 0);
    v7 = v28;
    if (v28 < 200) {
        int32_t v55 = (int32_t)*(char *)(v29 + 0x20000bb4); // 0x90f2
        if ((v55 & 128) != 0) {
            // 0x90f8
            function_178((int32_t *)(v13 | 113), (char *)((int32_t)"u\xd3" - 22));
        }
        if ((v55 & 64) != 0) {
            // 0x91ee
            function_178((int32_t *)(v13 | 120), "_\xd3");
        }
    }
    // 0x91fa
    function_870c(2, (int32_t *)&v5, (int32_t)&g83, v31);
    v18 = v30;
    v21 = v14;
    v24 = v22;
    goto lab_0x9246;
  lab_0x9246:;
    int32_t v42 = v24;
    int32_t v43 = v21;
    int32_t v44 = v18;
    int32_t v45 = v42 * (int32_t)&g67; // 0x9248
    unsigned char v46 = *(char *)(v42 + 0x20000378); // 0x927e
    if (v46 != 0) {
        // 0x9284
        function_178((int32_t *)v43, (char *)((int32_t)"_\xd3" - 5));
        function_178((int32_t *)(v43 + 5), "``");
        if (v46 != 1) {
            // 0x92a0
            function_178((int32_t *)(v43 + 8), "pp");
        }
        uint32_t v47 = (int32_t)v46; // 0x927e
        if (v47 >= (int32_t)&g44) {
            // 0x92b2
            function_178((int32_t *)(v43 + 11), "xx");
        }
        if (v47 >= (int32_t)&g62) {
            // 0x92c4
            function_178((int32_t *)(v43 + 14), "||");
        }
        if (v46 >= 5) {
            // 0x92e4
            function_178((int32_t *)(v43 + 17), "~~");
            if (v46 != 5) {
                // 0x92e8
                function_178((int32_t *)(v43 + 20), (char *)((int32_t)"_\xd3" - 8));
            }
        }
    }
    int32_t v48; // 0x8d08
    int32_t v49; // 0x8d08
    if (*(char *)(v45 + 0x20000b5f) == 1) {
        // 0x9318
        v48 = v43 + 27;
        v49 = (int32_t)"_\xd3" + 200;
        goto lab_0x9340;
    } else {
        int32_t v50 = *(int32_t *)(v45 + (int32_t)&g91 + (int32_t)&g34 + 0x20000a94);
        unsigned char v51 = *(char *)(v50 + (int32_t)&g62); // 0x9308
        if (v51 == 1) {
            // 0x932a
            v48 = v43 + 27;
            v49 = (int32_t)"_\xd3" + 212;
            goto lab_0x9340;
        } else {
            if (v51 == 2 || (int32_t)v51 == (int32_t)&g44) {
                // 0x9336
                v48 = v43 + 24;
                v49 = (int32_t)"_\xd3" + 224;
                goto lab_0x9340;
            } else {
                goto lab_0x9344;
            }
        }
    }
  lab_0x920c:
    // 0x920c
    function_c6e8(v4, __asm_adr(532), v29 + 1, v30);
    v26 = (int16_t *)&g90;
    v16 = &g83;
    v17 = 4 * v22 & 252;
    v20 = v14;
    v23 = v22;
    v27 = v4;
    goto lab_0x9242;
  lab_0x9340:
    // 0x9340
    function_178((int32_t *)v48, (char *)v49);
    goto lab_0x9344;
  lab_0x9344:;
    int32_t v52 = (int32_t)"_\xd3" + 30; // 0x8d08
    switch (*(char *)(v45 + 0x20000b53)) {
        case 1: {
            // 0x9364
            v52 = (int32_t)"_\xd3" + 38;
        }
        case 2: {
          lab_0x937a:
            // 0x937a
            function_178((int32_t *)(v43 + 44), (char *)v52);
            // break -> 0x937e
            break;
        }
        case 0: {
            // 0x9370
            v52 = (int32_t)"_\xd3" + 46;
            // branch (via goto) -> 0x937a
            goto lab_0x937a;
        }
    }
    // 0x937e
    if (*(int32_t *)(v45 + 0x20000b2c) != *(int32_t *)(v45 + 0x20000b34)) {
        int32_t v53 = (int32_t)"_\xd3" + 62; // 0x8d08
        switch (*(char *)(v45 + 0x20000b4b)) {
            case 2: {
                // 0x93a2
                v53 = (int32_t)"_\xd3" + 70;
            }
            case 1: {
                // 0x93ac
                function_178((int32_t *)(v43 + 54), (char *)v53);
                // break -> 0x93b0
                break;
            }
        }
    }
    // 0x93b0
    if (*(char *)(v45 + 0x20000b55) == 1) {
        // 0x93b6
        function_178((int32_t *)(v43 + 64), (char *)((int32_t)"_\xd3" + 54));
    }
    // 0x93c4
    if (*(char *)(v45 + 0x20000b57) == 1) {
        // 0x93ca
        function_178((int32_t *)(v43 + 74), (char *)((int32_t)"_\xd3" + 78));
    }
    // 0x93d8
    if (*(char *)(v45 + 0x20000b5b) == 1) {
        // 0x93e6
        function_178((int32_t *)(v43 + 84), "q\xd4");
    }
    // 0x93f2
    v19 = v44;
    v25 = v42;
    if (*(char *)(v45 + 0x20000b56) != 0) {
        // 0x9400
        function_178((int32_t *)(v43 + 110), (char *)((int32_t)"q\xd4" + 24));
        v19 = v44;
        v25 = v42;
    }
    goto lab_0x940e;
}

// Address range: 0x9440 - 0x9530
int32_t function_9440(void) {
    // 0x9440
    float64_t v1; // 0x9440
    float64_t v2 = v1;
    int32_t v3; // 0x9440
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v3, v3);
    int32_t v4 = 0;
    function_874c((int32_t *)(7 * ((v4 + 196) % 256) + (int32_t)"SQL"), 0, 127, 2 * v4 & 254, (int32_t)&g90, 0);
    uint32_t v5 = (v4 + 1) % 256; // 0x948c
    int32_t v6 = 0; // 0x9490
    while (v5 < 3) {
        // 0x9456
        v4 = v5;
        function_874c((int32_t *)(7 * ((v4 + 196) % 256) + (int32_t)"SQL"), 0, 127, 2 * v4 & 254, (int32_t)&g90, 0);
        v5 = (v4 + 1) % 256;
        v6 = 0;
    }
    char * v7 = (char *)(v6 + 0x20000804); // 0x949c
    *v7 = -1 - *v7;
    char * v8 = (char *)(v6 + 0x20000884); // 0x94a2
    *v8 = -1 - *v8;
    uint32_t v9 = (v6 + 1) % 256; // 0x94aa
    v6 = v9;
    int32_t v10 = 0; // 0x94ae
    while (v9 < 48) {
        // 0x949c
        v7 = (char *)(v6 + 0x20000804);
        *v7 = -1 - *v7;
        v8 = (char *)(v6 + 0x20000884);
        *v8 = -1 - *v8;
        v9 = (v6 + 1) % 256;
        v6 = v9;
        v10 = 0;
    }
    int32_t v11 = 128 * v10; // 0x94b4
    *(char *)(v11 + 0x20000734) = -1;
    uint32_t v12 = (v10 + 1) % 256; // 0x94be
    *(char *)(v11 + 0x20000735) = -1;
    v10 = v12;
    while (v12 < 7) {
        // 0x94b4
        v11 = 128 * v10;
        *(char *)(v11 + 0x20000734) = -1;
        v12 = (v10 + 1) % 256;
        *(char *)(v11 + 0x20000735) = -1;
        v10 = v12;
    }
    // 0x94c6
    int32_t v13; // bp-56, 0x9440
    function_1e3c(198, &v13, 0x20000a34, 0x20000704);
    int32_t v14; // bp-50, 0x9440
    function_870c(2, &v14, (int32_t)&g27, (int32_t *)6);
    v13 = 0;
    int32_t result = function_c73e(0x20000b02, 197, 0x20000af0, 197); // 0x950e
    __asm_vaba_u8(v2, v1, v2);
    *(int16_t *)(*(int32_t *)((int32_t)"\xc5\x03" + 0x47ae147b) + 18) = 0x6820;
    return result;
}

// Address range: 0x9532 - 0x953e
int32_t function_9532(void) {
    // 0x9532
    int32_t result; // 0x9532
    bool v1; // 0x9532
    if (v1 == !v1) {
        // 0x953e
        return result;
    }
    if (v1 || !v1) {
        int32_t v2; // 0x9532
        *(char *)((v2 << (int32_t)&g44) + v2) = (char)v2;
    }
    if (v1) {
        result = function_fe8b13b2();
    }
    // 0x953e
    return result;
}

// Address range: 0x9540 - 0x9558
int32_t function_9540(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0x9540
    bool v2; // 0x9540
    if (v2) {
        function_1305104();
        __asm_svcmi(0x4bedff);
        v1 = function_12dc27c();
    }
    int32_t v3 = v1;
    int32_t result = v3; // 0x954c
    if (v2) {
        *(int32_t *)a3 = v3;
        *(int32_t *)v3 = v3;
        *(int32_t *)(v3 - (int32_t)&g62) = a4;
        int32_t v4; // 0x9540
        *(int32_t *)(v3 - (int32_t)&g106) = (int32_t)&v4;
        *(int32_t *)(v3 - (int32_t)&g2) = 0x954c;
        *(int32_t *)(v3 - (int32_t)&g11) = 0x9558;
        result = v3 - (int32_t)&g16;
    }
    // .critedge
    return result;
}

// Address range: 0x9558 - 0x956e
int32_t function_9558(int32_t a1, int32_t a2) {
    uint16_t v1 = *(int16_t *)(a2 + a1); // 0x9558
    int32_t v2; // 0x9558
    function_348(function_508((int32_t)v1, a2, v2, v2), a2, v2, 0x3f847ae1);
    __asm_adr(776);
    return function_96e4();
}

// Address range: 0x956e - 0x958e
int32_t function_956e(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x956e
    bool v1; // 0x956e
    int32_t v2; // 0x956e
    bool v3; // 0x956e
    if (v3) {
        v2 = (a1 >> (int32_t)&g2) + a2;
        v1 = (a1 & 0x8000) != 0;
    }
    if (v3) {
        *(int32_t *)(a2 + (int32_t)&g62) = v2;
    }
    int32_t result = a1; // 0x9576
    int32_t v4; // 0x956e
    if (v3) {
        *(int32_t *)(a1 - (int32_t)&g62) = (int32_t)&v4;
        *(int32_t *)(a1 - (int32_t)&g106) = 0x957c;
        result = a1 - (int32_t)&g2;
    }
    bool v5 = v1; // 0x957a
    int32_t v6; // 0x956e
    if (v3) {
        v6 = result + (a2 >> (int32_t)&g9);
        v5 = (a2 & 0x40000) != 0;
    }
    if (v3) {
        *(int32_t *)a3 = a3;
        *(int32_t *)(a3 - (int32_t)&g62) = a4;
        *(int32_t *)(a3 - (int32_t)&g90) = v6;
        *(int32_t *)(a3 - (int32_t)&g2) = v2;
        *(int32_t *)(a3 - (int32_t)&g16) = (int32_t)&v4;
        *(int32_t *)(a3 - (int32_t)&g26) = 0x9584;
    }
    if (v3 || false) {
        if ((0x80000 * result & 1 << (int32_t)&g24) == 0) {
            // 0x958e
            return result;
        }
        // 0x958e
        return function_2361a();
    }
    if (!v5) {
        // 0x958e
        return result;
    }
    // 0x958e
    return function_2361a();
}

// Address range: 0x9590 - 0x95bc
int32_t function_9590(int32_t a1, int32_t a2, int32_t a3) {
    // 0x9590
    bool v1; // 0x9590
    bool v2; // 0x9590
    bool v3; // 0x9590
    bool v4; // 0x9590
    bool v5; // 0x9590
    bool v6; // 0x9590
    int32_t v7; // 0x9590
    int32_t v8; // 0x9590
    bool v9; // 0x9590
    if (v9) {
        int32_t v10 = a1 >> (int32_t)&g2; // 0x9594
        uint32_t v11 = a2 - v10; // 0x9594
        int32_t v12 = (a1 & 0x8000) == 0; // 0x9594
        int32_t v13 = v11 - v12; // 0x9594
        v6 = ((v13 - v12 ^ a2) & (v10 ^ a2)) < 0;
        v4 = v11 % 2 != 0;
        v2 = (a1 & 0x8000) == 0;
        v8 = v13;
        v5 = ((v13 - v12 ^ a2) & (v10 ^ a2)) < 0;
        v3 = v11 % 2 != 0;
        v1 = (a1 & 0x8000) == 0;
        v7 = v13;
        if (v13 < 0) {
            goto lab_dec_label_pc_unknown_4;
        } else {
            goto lab_dec_label_pc_unknown_5;
        }
    } else {
        if (v9) {
            goto lab_dec_label_pc_unknown_4;
        } else {
            goto lab_dec_label_pc_unknown_5;
        }
    }
  lab_dec_label_pc_unknown_4:;
    int32_t v14; // 0x9590
    int32_t v15 = v14 + (int32_t)&g2; // 0x959c
    int32_t v16 = *(int32_t *)(v14 + (int32_t)&g62); // 0x959c
    int32_t v17 = v8; // 0x959c
    bool v18 = v2; // 0x959c
    bool v19 = v4; // 0x959c
    bool v20 = v2; // 0x959c
    bool v21 = v4; // 0x959c
    int32_t v22 = a1; // 0x959c
    if (v6) {
        goto lab_dec_label_pc_unknown_6;
    } else {
        goto lab_dec_label_pc_unknown_7;
    }
  lab_dec_label_pc_unknown_5:
    v17 = v7;
    v18 = v1;
    v19 = v3;
    v20 = v1;
    v21 = v3;
    v22 = a1;
    if (v5) {
        goto lab_dec_label_pc_unknown_6;
    } else {
        goto lab_dec_label_pc_unknown_7;
    }
  lab_dec_label_pc_unknown_6:
    *(int32_t *)a1 = a1;
    *(int32_t *)(a1 - (int32_t)&g62) = a3;
    *(int32_t *)(a1 - (int32_t)&g90) = v16;
    *(int32_t *)(a1 - (int32_t)&g2) = v17;
    int32_t v23; // 0x9590
    *(int32_t *)(a1 - (int32_t)&g16) = (int32_t)&v23;
    *(int32_t *)(a1 - (int32_t)&g20) = v15;
    *(int32_t *)(a1 - (int32_t)&g26) = 0x95a4;
    v20 = v18;
    v21 = v19;
    v22 = a1 - (int32_t)&g30;
    goto lab_dec_label_pc_unknown_7;
  lab_dec_label_pc_unknown_7:;
    int32_t v24 = v22; // 0x95a0
    if (v21 != v20) {
        v24 = function_2098ac();
    }
    int32_t v25 = v24;
    *(int16_t *)v14 = (int16_t)v14;
    uint32_t v26 = 2 * v25 - v14 + (int32_t)((v25 & 1 << (int32_t)&g24) == 0); // 0x95ac
    uint32_t v27 = 2 * v26; // 0x95b4
    int32_t v28 = (v26 & 1 << (int32_t)&g24) == 0; // 0x95b4
    int32_t v29 = v26 - v28; // 0x95b4
    bool v30 = (v26 & 1 << (int32_t)&g24) == 0 ? v26 != -1 | v27 < v29 - v28 : v27 < v26; // 0x95b4
    int32_t result = v29; // 0x95b8
    if (!v30) {
        result = function_23648();
    }
    // 0x95bc
    return result;
}

// Address range: 0x95be - 0x95c2
int32_t function_95be(void) {
    // 0x95be
    int32_t result; // 0x95be
    return result;
}

// Address range: 0x95c2 - 0x95d2
int32_t function_95c2(int32_t result) {
    // 0x95c2
    bool v1; // 0x95c2
    if (v1) {
        int32_t v2; // 0x95c2
        *(int32_t *)(result - (int32_t)&g90) = (int32_t)&v2;
    }
    if (v1) {
        return result;
    }
    if (!v1) {
        // branch -> 
    }
    if (v1 == !v1) {
        __asm_svchi(0xc03840);
    }
    return result;
}

// Address range: 0x95d2 - 0x95da
int32_t function_95d2(void) {
    // 0x95d2
    int32_t v1; // 0x95d2
    return function_508(v1, v1, v1, v1);
}

// Address range: 0x95de - 0x960e
int32_t function_95de(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x95de
    int16_t v1; // 0x95de
    int16_t v2; // 0x95de
    bool v3; // 0x95de
    int32_t v4; // 0x95de
    int32_t v5; // 0x95de
    int32_t v6; // 0x95de
    bool v7; // 0x95de
    int32_t v8; // 0x95de
    if (v7) {
        v1 = *(int16_t *)&v4;
        v6 = a3 - (v8 << (int32_t)&g106);
        if ((2048 * v8 & 1 << (int32_t)&g24) == 0) {
            // .thread
            return result;
        }
        goto lab_dec_label_pc_unknown_9;
    } else {
        int16_t v9 = v8;
        v1 = v9;
        v6 = a3;
        v5 = a3;
        v3 = false;
        v2 = v9;
        if (v7) {
            goto lab_dec_label_pc_unknown_9;
        } else {
            goto lab_0x95ee;
        }
    }
  lab_dec_label_pc_unknown_9:;
    int32_t v10; // 0x95de
    *(int32_t *)(result - (int32_t)&g90) = (int32_t)&v10;
    *(int32_t *)(result - (int32_t)&g106) = v4;
    v5 = v6;
    v3 = true;
    v2 = v1;
    if (v7) {
        // .thread
        return result;
    }
    goto lab_0x95ee;
  lab_0x95ee:
    // 0x95ee
    if (v7 || false) {
        *(int32_t *)v8 = a4;
        *(int32_t *)(v8 - (int32_t)&g2) = (int32_t)&v10;
    }
    if (!v7) {
        // branch -> 
    }
    if (v3 == !v7) {
        __asm_svchi(0xc23840);
    }
    *(int16_t *)a2 = v2;
    v10 = v2;
    if (!v7) {
        // branch -> 
    }
    if (!v3) {
        int32_t v11 = a2 + (int32_t)&g7; // 0x95fa
        *(int32_t *)v11 = result;
        *(int32_t *)(v11 - (int32_t)&g62) = v11;
        *(int32_t *)(v11 - (int32_t)&g90) = v5;
        *(int32_t *)(v11 - (int32_t)&g106) = a4;
        *(int32_t *)(v11 - (int32_t)&g34) = v8 - a4;
    }
    // .thread
    return result;
}

// Address range: 0x960e - 0x9610
int32_t function_960e(void) {
    // 0x960e
    int32_t result; // 0x960e
    return result;
}

// Address range: 0x9610 - 0x9616
int32_t function_9610(void) {
    // 0x9610
    int32_t v1; // 0x9610
    int32_t v2 = function_c6e8(v1, v1, v1, v1); // 0x9610
    int32_t result = function_9756(v2, v1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x9614
    return result;
}

// Address range: 0x9616 - 0x961e
int32_t function_9616(void) {
    // 0x9616
    int32_t v1; // 0x9616
    return 4 * v1;
}

// Address range: 0x961e - 0x9622
int32_t function_961e(int32_t result, char * a2, int32_t a3) {
    // 0x961e
    __asm_adr(700);
    return result;
}

// Address range: 0x9622 - 0x962c
int32_t function_9622(void) {
    // 0x9622
    __asm_adr(692);
    return function_9610();
}

// Address range: 0x962c - 0x9634
int32_t function_962c(void) {
    // 0x962c
    return function_9748(*(int32_t *)0x20000af0, *(int32_t *)0x20000af4);
}

// Address range: 0x9634 - 0x9640
int32_t function_9634(int32_t a1) {
    // 0x9634
    int32_t v1; // 0x9634
    int32_t v2 = function_178(&v1, (char *)a1); // 0x963a
    int32_t result = function_9756(v2, a1, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x963e
    return result;
}

// Address range: 0x9644 - 0x964a
int32_t function_9644(int32_t a1, int32_t a2) {
    // 0x9644
    return a2 * a1;
}

// Address range: 0x964a - 0x9650
int32_t function_964a(void) {
    // 0x964a
    __asm_adr(664);
    int32_t result; // 0x964a
    return result;
}

// Address range: 0x9650 - 0x9656
int32_t function_9650(void) {
    // 0x9650
    __asm_adr(660);
    int32_t result; // 0x9650
    return result;
}

// Address range: 0x9660 - 0x966a
int32_t function_9660(void) {
    // 0x9660
    int32_t v1; // 0x9660
    return 3 * v1;
}

// Address range: 0x966a - 0x968e
int32_t function_966a(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x966a
    bool v1; // 0x966a
    int32_t v2; // 0x966a
    bool v3; // 0x966a
    if (v3) {
        v2 = (a1 >> (int32_t)&g2) + a2;
        v1 = (a1 & 0x8000) != 0;
    }
    int32_t v4 = a2; // 0x966e
    if (v3) {
        *(int32_t *)(a2 + (int32_t)&g62) = v2;
        v4 = a2 + (int32_t)&g106;
    }
    int32_t result = a1; // 0x9672
    int32_t v5; // 0x966a
    if (v3) {
        *(int32_t *)a1 = v4;
        *(int32_t *)(a1 - (int32_t)&g90) = (int32_t)&v5;
        *(int32_t *)(a1 - (int32_t)&g2) = 0x9678;
        result = a1 - (int32_t)&g11;
    }
    bool v6 = v3 ? (v4 & 0x40000) != 0 : v1;
    if (v6) {
        int32_t v7; // 0x966a
        __asm_mcrhs(0, 0, v7, 1, 14, 3);
    }
    if (v3) {
        return function_202ed3f6();
    }
    if (v6) {
        *(int32_t *)(result - (int32_t)&g90) = (int32_t)&v5;
        return result;
    }
    // .critedge
    return result;
}

// Address range: 0x968e - 0x96d0
int32_t function_968e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x968e
    int32_t v1; // 0x968e
    int32_t v2 = &v1; // 0x968e
    char v3 = a3;
    unsigned char v4 = *(char *)(a1 + a4); // 0x9690
    if ((int32_t)v4 == (int32_t)&g97) {
        // 0x96c6
        *(char *)(a1 + v2) = v3;
    } else {
        // 0x9696
        *(char *)(a1 + v2) = v4 + (char)&g45;
    }
    int32_t v5 = a1 + (int32_t)&g1 & (int32_t)&g129; // 0x969c
    int32_t v6 = (int32_t)&g44; // 0x96a0
    while (v5 < (int32_t)&g44) {
        int32_t v7 = v5;
        v4 = *(char *)(v7 + a4);
        if ((int32_t)v4 == (int32_t)&g97) {
            // 0x96c6
            *(char *)(v7 + v2) = v3;
        } else {
            // 0x9696
            *(char *)(v7 + v2) = v4 + (char)&g45;
        }
        // 0x969a
        v5 = v7 + (int32_t)&g1 & (int32_t)&g129;
        v6 = (int32_t)&g44;
    }
    unsigned char v8 = *(char *)(v6 + a4); // 0x96aa
    int32_t v9 = v6 + v2;
    if ((int32_t)v8 == (int32_t)&g97) {
        // 0x96ca
        *(char *)(v9 + (int32_t)&g1) = v3;
    } else {
        // 0x96b0
        *(char *)(v9 + 1) = v8 + (char)&g45;
    }
    int32_t v10 = v6 + (int32_t)&g1 & (int32_t)&g129; // 0x96b8
    v6 = v10;
    while (v10 < 6) {
        // 0x96aa
        v8 = *(char *)(v6 + a4);
        v9 = v6 + v2;
        if ((int32_t)v8 == (int32_t)&g97) {
            // 0x96ca
            *(char *)(v9 + (int32_t)&g1) = v3;
        } else {
            // 0x96b0
            *(char *)(v9 + 1) = v8 + (char)&g45;
        }
        // 0x96b6
        v10 = v6 + (int32_t)&g1 & (int32_t)&g129;
        v6 = v10;
    }
    int32_t v11 = 0x1000000 * a3 >> 24; // 0x96c4
    int32_t v12; // 0x968e
    int32_t result = function_9756((int32_t)&v12, v2, v11, v11, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x96c4
    return result;
}

// Address range: 0x96d0 - 0x96e4
int32_t function_96d0(int32_t a1, int32_t a2) {
    // 0x96d0
    int32_t v1; // 0x96d0
    int32_t result = function_348(function_508(v1, a2, v1, v1), a2, -0x771c970f, 0x3ee4f8b5); // 0x96da
    __asm_adr(556);
    return result;
}

// Address range: 0x96e4 - 0x96ec
int32_t function_96e4(void) {
    // 0x96e4
    int32_t v1; // 0x96e4
    int32_t v2; // 0x96e4
    int32_t v3 = function_c6e8((int32_t)&v1, v2, v2, v2); // 0x96e6
    int32_t result = function_9756(v3, v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x96ea
    return result;
}

// Address range: 0x96ec - 0x96ee
int32_t function_96ec(void) {
    // 0x96ec
    return function_9728();
}

// Address range: 0x96ee - 0x96f0
int32_t function_96ee(void) {
    // 0x96ee
    int32_t result; // 0x96ee
    return result;
}

// Address range: 0x96f0 - 0x96f2
int32_t function_96f0(void) {
    // 0x96f0
    int32_t result; // 0x96f0
    return result;
}

// Address range: 0x96f2 - 0x96f4
int32_t function_96f2(void) {
    // 0x96f2
    return function_9706();
}

// Address range: 0x96f4 - 0x96f6
int32_t function_96f4(void) {
    // 0x96f4
    return function_9730((int32_t)&g130, (int32_t)&g130);
}

// Address range: 0x96f6 - 0x96f8
int32_t function_96f6(void) {
    // 0x96f6
    return function_96fc();
}

// Address range: 0x96f8 - 0x96fc
int32_t function_96f8(int32_t result, int32_t a2) {
    // 0x96f8
    return result;
}

// Address range: 0x96fc - 0x9706
int32_t function_96fc(void) {
    // 0x96fc
    int32_t v1; // 0x96fc
    return 5 * v1;
}

// Address range: 0x9706 - 0x9710
int32_t function_9706(void) {
    // 0x9706
    int32_t v1; // 0x9706
    return 5 * v1;
}

// Address range: 0x9710 - 0x9728
int32_t function_9710(void) {
    // 0x9710
    int32_t v1; // 0x9710
    int32_t v2 = function_1928((uint32_t)v1 % 0x10000, 0, 0); // 0x9718
    int32_t v3 = function_8594(); // 0x9722
    int32_t result = function_9756(v3, v2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x9726
    return result;
}

// Address range: 0x9728 - 0x9730
int32_t function_9728(void) {
    // 0x9728
    int32_t v1; // 0x9728
    return 4 * v1;
}

// Address range: 0x9730 - 0x9748
int32_t function_9730(int32_t a1, int32_t a2) {
    int32_t result = a1;
    int32_t v1; // 0x9730
    int32_t v2 = function_1fc8((int32_t)((char)v1 - 1), &result); // 0x9738
    *"\xc8\x03" = (char)v2;
    if (v2 == 0) {
        function_974e();
    }
    // 0x9744
    return result;
}

// Address range: 0x9748 - 0x974e
int32_t function_9748(int32_t a1, int32_t a2) {
    int32_t result = function_9756(a1, a2, a1, a2, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130, (int32_t)&g130); // 0x974c
    return result;
}

// Address range: 0x974e - 0x9756
int32_t function_974e(void) {
    int32_t v1 = __asm_adr(472); // 0x974e
    int32_t v2; // 0x974e
    int32_t v3; // 0x974e
    return function_c6e8((int32_t)&v2, v1, v3, v3);
}

// Address range: 0x9756 - 0x9a8c
int32_t function_9756(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x9756
    int32_t v1; // 0x9756
    uint32_t v2 = v1;
    int32_t v3; // 0x9756
    function_874c(&v3, (int32_t)&g47, 127, 2, (int32_t)&g90, 1);
    uint32_t v4 = v2 % 256;
    int32_t v5 = 2; // 0x976e
    if (v4 == (int32_t)&g90) {
        int32_t v6 = __asm_adr(416); // 0x97a4
        function_874c((int32_t *)v6, (int32_t)&g47, 127, (int32_t)&g62, (int32_t)&g90, 1);
        v5 = (int32_t)&g62;
    }
    int32_t v7 = v5; // 0x97b2
    if (v4 == (int32_t)&g46 || v4 == (int32_t)&g47 || v4 == (int32_t)&g106) {
        int32_t v8 = __asm_adr(388); // 0x97c8
        int32_t v9 = __asm_adr(272); // 0x97ca
        function_c6e8((int32_t)&v3, v9, v8, v5);
        function_874c(&v3, (int32_t)&g47, 127, (int32_t)&g62, (int32_t)&g90, 1);
        v7 = (int32_t)&g62;
    }
    int32_t v10 = v7; // 0x97e6
    if (v4 == (int32_t)&g62 || v4 == (int32_t)&g44) {
        int32_t v11 = __asm_adr(352); // 0x9800
        function_874c((int32_t *)v11, (int32_t)&g47, 127, (int32_t)&g62, (int32_t)&g90, 1);
        v10 = (int32_t)&g62;
    }
    int32_t v12 = v10; // 0x980e
    if (v4 == (int32_t)&g29) {
        uint32_t v13 = function_1c0(a4); // 0x9812
        v12 = v10;
        if (v13 != (int32_t)&g90 && v13 >= (int32_t)&g90) {
            // 0x981a
            function_874c((int32_t *)0x20000af8, (int32_t)&g47, 127, (int32_t)&g62, (int32_t)&g90, 1);
            v12 = (int32_t)&g62;
        }
    }
    int32_t v14 = v12; // 0x9830
    if (v4 == (int32_t)&g30) {
        uint32_t v15 = function_1c0(a3); // 0x9834
        v14 = v12;
        if (v15 != (int32_t)&g90 && v15 >= (int32_t)&g90) {
            // 0x983c
            function_874c((int32_t *)2826, (int32_t)&g47, 127, (int32_t)&g62, (int32_t)&g90, 1);
            v14 = (int32_t)&g62;
        }
    }
    // 0x997a
    int32_t v16; // 0x9756
    int32_t v17; // 0x9756
    if (v4 == (int32_t)&g36) {
        goto lab_0x99ca;
    } else {
        char v18 = v2;
        v16 = 127;
        v17 = v14;
        if (v18 == 5 || v4 == (int32_t)&g44 || v18 == 6 || v4 == (int32_t)&g62) {
            goto lab_0x99ca;
        } else {
            goto lab_0x99e8;
        }
    }
  lab_0x99ca:
    // 0x99ca
    function_1e3c(v1 % 256, &v3, 127, v14);
    int32_t v19 = v4 == (int32_t)&g36 ? 2 : (int32_t)&g44;
    function_870c(v19, (int32_t *)((int32_t)&g90 - v19 + (int32_t)&v3), 105, NULL);
    v16 = 105;
    v17 = 0;
    goto lab_0x99e8;
  lab_0x99e8:;
    int32_t v20 = 2826 - (int32_t)&g85 + (int32_t)&g26; // 0x99ec
    if (v4 != (int32_t)&g24) {
        // 0x99ee
        v20 = 2826 - (int32_t)&g85 + (int32_t)&g26 + 1;
        if (v4 != (int32_t)&g26) {
            // 0x9a84
            function_b638();
            return function_c399();
        }
    }
    if (v1 == 255) {
        // 0x9a0e
        function_c6e8((int32_t)&v3, (int32_t)"NULL", v16, v17);
        // 0x9a7a
        function_874c(&v3, (int32_t)&g47, 127, 2, (int32_t)&g90, 1);
        // 0x9a84
        function_b638();
        return function_c399();
    }
    // 0x9a14
    function_8594();
    if (*(char *)v20 != 1) {
        // 0x9a7a
        function_874c(&v3, (int32_t)&g47, 127, 2, (int32_t)&g90, 1);
        // 0x9a84
        function_b638();
        return function_c399();
    }
    // 0x9a34
    function_874c(&v3, (int32_t)&g47, 127, 0, (int32_t)&g90, 1);
    uint32_t v21 = (int32_t)*(char *)(v20 + (int32_t)&g25); // 0x9a44
    int32_t v22 = 0; // 0x9a48
    if (v21 < (int32_t)&g108) {
        int32_t v23 = __asm_adr(88); // 0x9a4a
        function_c6e8((int32_t)&v3, v23, v21 + 1, 0);
        function_874c(&v3, (int32_t)&g47, 127, 2, (int32_t)&g90, 1);
        v22 = 2;
    }
    uint32_t v24 = (int32_t)*(char *)(v20 + (int32_t)&g62); // 0x9a64
    if (v24 >= (int32_t)&g108) {
        // 0x9a84
        function_b638();
        return function_c399();
    }
    int32_t v25 = __asm_adr(64); // 0x9a6a
    function_c6e8((int32_t)&v3, v25, v24 + 1, v22);
    int32_t v26 = (int32_t)&g62;
    function_874c(&v3, (int32_t)&g47, 127, v26, (int32_t)&g90, 1);
    // 0x9a84
    function_b638();
    return function_c399();
}

// Address range: 0x9ab4 - 0x9b28
int32_t function_9ab4(void) {
    // 0x9ab4
    int32_t v1; // 0x9ab4
    function_1aa((int32_t *)0x20000684, (int32_t *)&g91, v1, v1);
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v1, v1);
    int32_t v2 = __asm_adr(100); // 0x9aca
    int32_t v3; // bp-32, 0x9ab4
    int32_t v4 = &v3; // 0x9acc
    function_c6e8(v4, v2, v1, v1);
    function_874c(&v3, 0, 127, 1, (int32_t)&g97, 1);
    int32_t v5 = 0; // 0x9aee
    char v6 = *(char *)(v5 + 0x200003e7); // 0x9af0
    char v7 = v6 == 10 ? (char)&g37 : (char)&g35;
    *(char *)(v5 + v4) = v7;
    v5 = v5 + (int32_t)&g1 & (int32_t)&g129;
    while (v5 < 6) {
        // 0x9af0
        v6 = *(char *)(v5 + 0x200003e7);
        v7 = v6 == 10 ? (char)&g37 : (char)&g35;
        *(char *)(v5 + v4) = v7;
        v5 = v5 + (int32_t)&g1 & (int32_t)&g129;
    }
    // 0x9b04
    function_874c(&v3, 0, 127, (int32_t)&g44, (int32_t)&g106, 1);
    function_b6b0();
    return function_b638();
}

// Address range: 0x9b30 - 0x9b38
int32_t function_9b30(int32_t a1) {
    int32_t result = a1; // 0x9b30
    bool v1; // 0x9b30
    if (v1) {
        result = function_10dd868();
    }
    // 0x9b34
    return result;
}

// Address range: 0x9b3c - 0x9be6
int32_t function_9b3c(void) {
    // 0x9b3c
    int32_t v1; // 0x9b3c
    function_1aa((int32_t *)0x20000684, (int32_t *)&g91, v1, v1);
    function_1aa((int32_t *)0x20000704, (int32_t *)((int32_t)&g82 << (int32_t)&g82), v1, v1);
    char v2 = *(char *)0x20000ace; // 0x9b54
    if (v2 == 0) {
        // 0x9bb4
        return function_b70c(255);
    }
    int32_t v3 = 0; // bp-48, 0x9b5c
    int32_t v4 = 0; // bp-32, 0x9b64
    if (v2 == 2) {
        int32_t v5 = __asm_adr(48); // 0x9bc0
        function_c6e8((int32_t)&v3, v5, v1, v1);
        uint16_t v6 = *(int16_t *)0x20000406; // 0x9bca
        int32_t v7 = function_348(function_508((int32_t)v6, v5, v1, v1), v5, 0x47ae147b, 0x3f847ae1); // 0x9bd4
        int32_t v8 = __asm_adr(40); // 0x9bdc
        function_c6e8((int32_t)&v4, v8, v7, v5);
    } else {
        // 0x9b70
        function_aff4(3760, &v3, (char)&g2);
        function_aff4(64 * (int32_t)&g56, &v4, (char)&g2);
    }
    // 0x9b88
    function_874c(&v3, 0, 127, 1, (int32_t)&g97, 1);
    function_874c(&v4, 0, 127, (int32_t)&g44, (int32_t)&g97, 1);
    function_b6b0();
    // 0x9bb4
    return function_b638();
}

// Address range: 0x9bf4 - 0x9bfa
int32_t function_9bf4(int32_t result, int32_t a2) {
    // 0x9bf4
    int32_t v1; // 0x9bf4
    *(char *)(2 * a2) = (char)v1;
    return result;
}

// Address range: 0x9c10 - 0x9d4a
int32_t function_9c10(void) {
    // 0x9c10
    int32_t v1; // 0x9c10
    function_1aa((int32_t *)0x20000684, (int32_t *)&g91, v1, v1);
    function_178((int32_t *)0x200006f2, (char *)((int32_t)"\xb5\xd3" + 96));
    if (*(char *)0x20000aa6 == 1) {
        // 0x9ca4
        function_178((int32_t *)0x200006de, (char *)((int32_t)"\xb5\xd3" + 239));
    }
    // 0x9cb4
    if (*(char *)0x20000aa7 == 1) {
        // 0x9cba
        function_178((int32_t *)0x200006cb, (char *)((int32_t)"\xec\xd4" - 63));
    }
    // 0x9cc8
    if (*(char *)0x20000aaf != 0) {
        // 0x9cce
        function_178((int32_t *)0x200006be, (char *)((int32_t)"\xec\xd4" - 45));
    }
    // 0x9cdc
    if (*(char *)0x20000aae != 0) {
        // 0x9ce2
        function_178((int32_t *)0x200006b1, (char *)((int32_t)"\xec\xd4" - 33));
    }
    // 0x9cf0
    if (*(char *)0x20000aa9 != 0) {
        // 0x9cf6
        function_178((int32_t *)0x200006a6, (char *)((int32_t)"\xec\xd4" - 21));
    }
    // 0x9d04
    return function_b6b0();
}

// Address range: 0x9d7c - 0x9db8
int32_t function_9d7c(int32_t * a1, int32_t * a2) {
    // 0x9d7c
    *(int16_t *)a1 = 0;
    return 0;
}

// Address range: 0x9dbc - 0x9e06
int32_t function_9dbc(void) {
    char v1 = 1; // bp-28, 0x9dc4
    function_7f4(&v1);
    function_a50();
    return function_a90();
}

// Address range: 0x9e08 - 0x9e48
int32_t function_9e08(int32_t result, int32_t a2, int32_t a3) {
    // 0x9e08
    *(int32_t *)0x400bd000 = (int32_t)&g26;
    *(int32_t *)0x400bd01c = a2;
    *(int32_t *)0x400bd018 = *(int32_t *)(a2 + (int32_t)&g62);
    *(int32_t *)0x400bd014 = *(int32_t *)(a2 + (int32_t)&g90);
    *(int32_t *)0x400bd010 = *(int32_t *)(a2 + (int32_t)&g106);
    *(int32_t *)0x400bd02c = a3;
    *(int32_t *)0x400bd028 = *(int32_t *)(a3 + (int32_t)&g62);
    *(int32_t *)0x400bd024 = *(int32_t *)(a3 + (int32_t)&g90);
    *(int32_t *)0x400bd020 = *(int32_t *)(a3 + (int32_t)&g106);
    *(int32_t *)0x400bd000 = *(int32_t *)0x400bd000 | 1;
    return result;
}

// Address range: 0x9e4c - 0x9eae
int32_t function_9e4c(int32_t * a1, int32_t * a2) {
    int32_t v1 = function_a960((int32_t *)105); // 0x9e54
    if ((v1 & 1 << (int32_t)&g126) == 0) {
        int32_t v2 = function_a960((int32_t *)106); // 0x9e66
        *a1 = v2 & 0xffffffff >> (int32_t)&g11 | v1 << (int32_t)&g12 >> (int32_t)&g95;
        // 0x9e7c
        return 2;
    }
    int32_t v3 = function_a960(&g79); // 0x9e80
    int32_t result = 0; // 0x9e8e
    if ((v3 & 1 << (int32_t)&g126) == 0) {
        int32_t v4 = function_128(0x12eb * (v3 & 0xffffffff >> (int32_t)&g9), (int32_t *)0x2710); // 0x9e9c
        *(int16_t *)a2 = (int16_t)v4;
        result = 1;
    }
    // 0x9e7c
    return result;
}

// Address range: 0x9eb8 - 0x9ee6
int32_t function_9eb8(int32_t * a1) {
    int32_t v1 = function_a960((int32_t *)&g111); // 0x9ebe
    int32_t result = 0; // 0x9ecc
    if ((v1 & 1 << (int32_t)&g126) == 0) {
        int32_t v2 = function_a960((int32_t *)&g121); // 0x9ed4
        *a1 = v2 + (v1 << (int32_t)&g12) / 32;
        result = 1;
    }
    // 0x9ed0
    return result;
}

// Address range: 0x9ee8 - 0x9f0e
int32_t function_9ee8(void) {
    // 0x9ee8
    function_af00(&g83, 0);
    function_c0bc(function_a348(NULL));
    function_af00(&g45, 0);
    return function_af00(&g45, 0xbff1);
}

// Address range: 0x9f14 - 0x9f70
int32_t function_9f14(int32_t a1, int32_t a2) {
    // 0x9f14
    function_c0a0(a1);
    function_a348((int32_t *)&g44);
    int32_t v1 = a2 == 0 ? (int32_t)&g82 << (int32_t)&g111 : (int32_t)&g33 << (int32_t)&g97;
    function_af00(&g83, v1);
    function_af00(&g45, 0);
    function_af00(&g45, 770);
    int32_t v2; // 0x9f14
    int32_t v3 = function_508(a1, 770, v2, v2); // 0x9f4c
    return function_af00((int32_t *)113, function_524(function_348(v3, 770, -0x14f8b6, 0x4024a61c), 770) % 0x10000);
}

// Address range: 0x9f7c - 0x9f84
int32_t function_9f7c(int32_t a1) {
    // 0x9f7c
    return function_c0bc(a1);
}

// Address range: 0x9f84 - 0x9f8c
int32_t function_9f84(int32_t a1) {
    // 0x9f84
    return function_c0a0(a1);
}

// Address range: 0x9f8c - 0x9fb8
int32_t function_9f8c(int32_t a1) {
    // 0x9f8c
    function_c0a0(a1);
    function_a348(NULL);
    int32_t v1 = function_af00(&g83, 0); // 0x9f9e
    function_a5d0((char)v1);
    int32_t v2 = function_af00(&g45, 0xc1fe); // 0x9faa
    int32_t result = v2; // 0x9fb0
    if (a1 == 0) {
        // 0x9fb2
        result = function_c0bc(v2);
    }
    // 0x9fb6
    return result;
}

// Address range: 0x9fbc - 0xa016
int32_t function_9fbc(char a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x9fbc
    function_c0a0((int32_t)a1);
    function_af00(&g83, (int32_t)&g82 << (uint32_t)(int32_t)&g111);
    int32_t v1 = function_508(a2, (int32_t)&g82 << (uint32_t)(int32_t)&g111, a3, a4); // 0x9fd2
    int32_t v2 = function_348(v1, (int32_t)&g82 << (int32_t)&g111, -0x14f8b6, 0x4024a61c); // 0x9fdc
    uint32_t v3 = function_524(v2, (int32_t)&g82 << (int32_t)&g111); // 0x9fe4
    function_af00((int32_t *)113, v3 % 0x10000);
    int32_t v4; // 0x9fbc
    if (a1 == 1) {
        // 0x9ff8
        v4 = function_a348((int32_t *)&g44);
    } else {
        // 0xa000
        v4 = function_a348(NULL);
    }
    // 0xa006
    function_acf4(v4);
    int32_t v5 = function_d0ec((int32_t)&g47); // 0xa00c
    return function_c0bc(v5);
}

// Address range: 0xa020 - 0xa048
int32_t function_a020(int32_t a1) {
    // 0xa020
    int32_t v1; // 0xa020
    int32_t v2 = v1;
    int32_t v3 = function_508(a1, v2, v1, v1); // 0xa026
    return function_af00((int32_t *)113, function_524(function_348(v3, v2, -0x14f8b6, 0x4024a61c), v2) % 0x10000);
}

// Address range: 0xa050 - 0xa06a
int32_t function_a050(int32_t a1) {
    // 0xa050
    function_aabc(a1);
    function_af00((int32_t *)81, (int32_t)&g44 << (uint32_t)(int32_t)&g90);
    return function_c134();
}

// Address range: 0xa06c - 0xa078
int32_t function_a06c(char a1) {
    // 0xa06c
    return function_af00(&g47, 581);
}

// Address range: 0xa07c - 0xa088
int32_t function_a07c(int32_t a1) {
    // 0xa07c
    return function_af00(&g45, 0);
}

// Address range: 0xa088 - 0xa096
int32_t function_a088(int32_t a1, int32_t a2) {
    // 0xa088
    return function_af00(&g47, 580);
}

// Address range: 0xa098 - 0xa19c
int32_t function_a098(int32_t a1, int16_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a2;
    int32_t v2 = function_a29c((int32_t *)&g82, v1, a3, a4); // 0xa0a0
    int32_t v3 = v2 >> (int32_t)&g62; // 0xa0a6
    if ((v2 & 0xffffffff >> (int32_t)&g20) <= 1) {
        // 0xa0b0
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return -1;
    }
    uint32_t v4 = function_a29c((int32_t *)&g97, v1, a3, a4); // 0xa0c0
    if ((v4 & 1 << (int32_t)&g106) != 0) {
        // 0xa0d0
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return -1;
    }
    if (v4 % 256 < (int32_t)&g97) {
        // 0xa0e4
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return -1;
    }
    if (v3 <= 3815) {
        // 0xa100
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return -1;
    }
    if (v1 < a1) {
        // 0xa112
        if (a1 - (int32_t)*(int16_t *)0x20000362 == 1) {
            int32_t v5 = (int32_t)*(int16_t *)0x20000364; // 0xa11e
            if ((v5 & 1 << (int32_t)&g102) != 0) {
                // 0xa12a
                *(int16_t *)0x20000362 = (int16_t)a1;
                *(int16_t *)0x20000364 = (int16_t)v3;
                // 0xa0bc
                return -1;
            }
            if (v5 < (int32_t)&g11) {
                // 0xa140
                *(int16_t *)0x20000362 = (int16_t)a1;
                *(int16_t *)0x20000364 = (int16_t)v3;
                // 0xa0bc
                return -1;
            }
        }
    }
    if (v1 > a1 || (int32_t)*(int16_t *)0x20000362 - a1 != 1) {
        // 0xa190
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return 0;
    }
    uint16_t v6 = *(int16_t *)0x20000364; // 0xa15e
    if (((int32_t)v6 & 1 << (int32_t)&g102) == 0) {
        // 0xa16a
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return -1;
    }
    if (v6 < 4076) {
        // 0xa190
        *(int16_t *)0x20000362 = (int16_t)a1;
        *(int16_t *)0x20000364 = (int16_t)v3;
        // 0xa0bc
        return 0;
    }
    // 0xa182
    *(int16_t *)0x20000362 = (int16_t)a1;
    *(int16_t *)0x20000364 = (int16_t)v3;
    // 0xa0bc
    return -1;
}

// Address range: 0xa1ac - 0xa260
int32_t function_a1ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result; // 0xa1ac
    if (a2 == 1) {
        // 0xa1b6
        function_bf98(0x40060800, (int32_t)&g126);
        int32_t * v1 = (int32_t *)a4; // 0xa21a
        function_a31a(2, 513, a3, v1);
        function_a31a(5, (int16_t)&g100, a3, v1);
        int16_t v2 = (int16_t)a1 - 760; // 0xa232
        function_a31a((int32_t)&g44, v2, a3, v1);
        function_d0ec((int32_t)&g97);
        int32_t v3 = function_a31a((int32_t)&g44, v2 | (int16_t)(1 << (int32_t)&g126), a3, v1); // 0xa246
        result = v3;
    } else {
        // 0xa24c
        function_a31a(2, 577, a3, (int32_t *)a4);
        result = function_bfe4(0x40060800, (int32_t *)&g126);
    }
    // 0xa25e
    return result;
}

// Address range: 0xa278 - 0xa294
int32_t function_a278(char a1) {
    // 0xa278
    int32_t v1; // 0xa278
    int32_t * v2 = (int32_t *)v1;
    int32_t result; // 0xa278
    if (a1 == 1) {
        // 0xa280
        result = function_a31a(2, 0x4201, v1, v2);
    } else {
        // 0xa28a
        result = function_a31a(2, 513, v1, v2);
    }
    // 0xa292
    return result;
}

// Address range: 0xa29c - 0xa2d0
int32_t function_a29c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-16, 0xa29c
    function_b510();
    function_b3f8((int32_t *)&g91);
    function_b3f8((int32_t *)(2 * (int32_t)a1 & 254 | 1));
    function_b2aa(&v1, 2);
    function_b550();
    char v2; // 0xa29c
    return v1 % 256 << (int32_t)&g90 | (int32_t)(unsigned char)v2;
}

// Address range: 0xa2d0 - 0xa2e8
int32_t function_a2d0(int32_t a1) {
    // 0xa2d0
    int32_t v1; // 0xa2d0
    int32_t v2 = function_a29c((int32_t *)&g82, v1, v1, v1); // 0xa2d6
    *(int16_t *)0x20000362 = (int16_t)a1;
    *(int16_t *)0x20000364 = (int16_t)(v2 >> (int32_t)&g62);
    return 0x20000364;
}

// Address range: 0xa2f0 - 0xa31a
int32_t function_a2f0(int16_t a1) {
    int16_t v1 = a1 - 760;
    int32_t v2; // 0xa2f0
    int32_t * v3 = (int32_t *)v2; // 0xa300
    function_a31a((int32_t)&g44, v1, v2, v3);
    function_d0ec((int32_t)&g97);
    int32_t result = function_a31a((int32_t)&g44, v1 | (int16_t)(1 << (int32_t)&g126), v2, v3); // 0xa314
    return result;
}

// Address range: 0xa31a - 0xa346
int32_t function_a31a(int32_t a1, int16_t a2, int32_t a3, int32_t * a4) {
    // 0xa31a
    function_b510();
    function_b3f8((int32_t *)&g91);
    function_b3f8((int32_t *)((uint32_t)(a1 << (uint32_t)(int32_t)&g17) >> (uint32_t)(int32_t)&g16));
    int16_t * v1 = (int16_t *)(0x1000000 * ((int32_t)a2 >> (uint32_t)(int32_t)&g90) / 0x1000000); // bp-16, 0xa336
    function_b590((int32_t *)&v1, 2);
    return function_b550();
}

// Address range: 0xa348 - 0xa35c
int32_t function_a348(int32_t * a1) {
    int32_t result = function_af00(&g68, (int32_t)a1 << (uint32_t)(int32_t)&g90 | 0x6040); // 0xa356
    return result;
}

// Address range: 0xa360 - 0xa4dc
int32_t function_a360(int32_t a1) {
    // 0xa360
    int32_t v1; // 0xa360
    if (a1 == (int32_t)&g53) {
        // 0xa41e
        function_af00((int32_t *)113, 0x1f0e);
        // 0xa4d8
        return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x3b91), 0x3b91, v1, v1);
    }
    int32_t v2; // 0xa360
    int32_t v3; // 0xa360
    if (a1 > (int32_t)&g53) {
        if (a1 == 65) {
            // 0xa46a
            function_af00((int32_t *)113, 0x1c1c);
            // 0xa4d8
            return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x41dc), 0x41dc, v1, v1);
        }
        if (a1 > 65) {
            if (a1 == 66) {
                // 0xa47c
                function_af00((int32_t *)113, 0x1f0e);
                // 0xa4d8
                return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x41dc), 0x41dc, v1, v1);
            }
            if (a1 == (int32_t)&g65) {
                // 0xa490
                function_af00((int32_t *)113, 0x225c);
                // 0xa4d8
                return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x41dc), 0x41dc, v1, v1);
            }
            // 0xa3ac
            v2 = a1;
            if (a1 == (int32_t)&g67) {
                // 0xa4a2
                function_af00((int32_t *)113, 0x25f3);
                v2 = function_af00((int32_t *)114, 0x41dc);
                v3 = 0x41dc;
            }
            // 0xa4d8
            return __asm_nop((int32_t *)v2, v3, v1, v1);
        }
        if (a1 == (int32_t)&g54) {
            // 0xa430
            function_af00((int32_t *)113, 0x225c);
            // 0xa4d8
            return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x30c2), 0x30c2, v1, v1);
        }
        if (a1 == (int32_t)&g55) {
            // 0xa442
            function_af00((int32_t *)113, 0x225c);
            // 0xa4d8
            return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x35e1), 0x35e1, v1, v1);
        }
        // 0xa39e
        v2 = a1;
        if (a1 == 57) {
            // 0xa458
            function_af00((int32_t *)113, 0x225c);
            v2 = function_af00((int32_t *)114, 0x3b91);
            v3 = 0x3b91;
        }
        // 0xa4d8
        return __asm_nop((int32_t *)v2, v3, v1, v1);
    }
    if (a1 == (int32_t)&g47) {
        // 0xa3d6
        function_af00((int32_t *)113, 0x1c1c);
        // 0xa4d8
        return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x35e1), 0x35e1, v1, v1);
    }
    if (a1 > (int32_t)&g47) {
        if (a1 == (int32_t)&g48) {
            // 0xa3e8
            function_af00((int32_t *)113, 0x1c1c);
            // 0xa4d8
            return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x3b91), 0x3b91, v1, v1);
        }
        if (a1 == (int32_t)&g51) {
            // 0xa3fa
            function_af00((int32_t *)113, 0x1f0e);
            // 0xa4d8
            return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x30c2), 0x30c2, v1, v1);
        }
        // 0xa38a
        v2 = a1;
        if (a1 == (int32_t)&g52) {
            // 0xa40c
            function_af00((int32_t *)113, 0x1f0e);
            v2 = function_af00((int32_t *)114, 0x35e1);
            v3 = 0x35e1;
        }
        // 0xa4d8
        return __asm_nop((int32_t *)v2, v3, v1, v1);
    }
    if (a1 == (int32_t)&g29) {
        // 0xa4c6
        function_af00((int32_t *)113, 0x25f3);
        v2 = __asm_nop((int32_t *)function_af00((int32_t *)114, 0x3b91), 0x3b91, v1, v1);
        // 0xa4d8
        return __asm_nop((int32_t *)v2, 0x3b91, v1, v1);
    }
    if (a1 == (int32_t)&g35) {
        // 0xa4b4
        function_af00((int32_t *)113, 0x25f3);
        // 0xa4d8
        return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x30c2), 0x30c2, v1, v1);
    }
    if (a1 == (int32_t)&g45) {
        // 0xa3b2
        function_af00((int32_t *)113, 0x25f3);
        // 0xa4d8
        return __asm_nop((int32_t *)function_af00((int32_t *)114, 0x35e1), 0x35e1, v1, v1);
    }
    // 0xa37e
    v2 = a1;
    if (a1 == (int32_t)&g46) {
        // 0xa3c4
        function_af00((int32_t *)113, 0x1c1c);
        v2 = function_af00((int32_t *)114, 0x30c2);
        v3 = 0x30c2;
    }
    // 0xa4d8
    return __asm_nop((int32_t *)v2, v3, v1, v1);
}

// Address range: 0xa4fc - 0xa512
int32_t function_a4fc(void) {
    // 0xa4fc
    function_af00(&g27, 1752);
    return function_af00((int32_t *)&g30, (int32_t)"*.*****");
}

// Address range: 0xa518 - 0xa546
int32_t function_a518(void) {
    // 0xa518
    function_af00(&g83, 224);
    function_af00((int32_t *)114, 0x3065);
    function_af00(&g74, 193);
    function_af00(&g75, 0x5665);
    int32_t result = function_af00((int32_t *)93, (int32_t)&g68 << (uint32_t)(int32_t)&g90); // 0xa540
    return result;
}

// Address range: 0xa550 - 0xa57e
int32_t function_a550(int32_t a1) {
    int32_t v1 = function_a960(&g46); // 0xa556
    function_af00(&g46, v1 | 2);
    int32_t result = function_af00((int32_t *)113, 1032 * a1 + (int32_t)&g80 & 0xfffc); // 0xa578
    return result;
}

// Address range: 0xa584 - 0xa5cc
int32_t function_a584(int16_t a1, int16_t a2) {
    int32_t v1 = function_a960(&g46); // 0xa58c
    function_af00((int32_t *)70, (int32_t)a1 & 0xffffffff >> (int32_t)&g12 | 5 << (int32_t)&g111);
    function_af00((int32_t *)121, (int32_t)a2 & 0xffffffff >> (int32_t)&g12 | (int32_t)&g44 << (int32_t)&g102);
    function_af00((int32_t *)122, (int32_t)")F F");
    return function_af00(&g46, v1 | (int32_t)&g62);
}

// Address range: 0xa5d0 - 0xa5dc
int32_t function_a5d0(char a1) {
    // 0xa5d0
    return function_af00((int32_t *)&g30, 0);
}

// Address range: 0xa5dc - 0xa5f4
int32_t function_a5dc(void) {
    int32_t v1 = function_a960(&g46); // 0xa5e0
    return function_af00(&g46, v1 & 0xfffd);
}

// Address range: 0xa5f8 - 0xa600
int32_t function_a5f8(int32_t a1) {
    // 0xa5f8
    return function_c0b0();
}

// Address range: 0xa600 - 0xa618
int32_t function_a600(void) {
    int32_t v1 = function_a960(&g46); // 0xa604
    return function_af00(&g46, v1 & 0xfffb);
}

// Address range: 0xa61c - 0xa63a
int32_t function_a61c(void) {
    // 0xa61c
    function_af00(&g61, 0);
    function_af00((int32_t *)89, (int32_t)&g79);
    int32_t v1 = function_d0ec((int32_t)&g23); // 0xa630
    return function_c128(v1);
}

// Address range: 0xa63c - 0xa672
int32_t function_a63c(void) {
    // 0xa63c
    function_a61c();
    function_af00((int32_t *)2, 0);
    function_af00(&g61, 0);
    function_c134();
    function_af00(&g61, (int32_t)&g44 << (uint32_t)(int32_t)&g106);
    function_af00((int32_t *)89, 0x4068);
    return function_af00((int32_t *)89, 0x3068);
}

// Address range: 0xa67c - 0xa706
int32_t function_a67c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xa67c
    function_d0ec((int32_t)&g23);
    function_af00(&g61, 1 << (uint32_t)(int32_t)&g126);
    function_af00((int32_t *)89, 0x8068);
    function_af00((int32_t *)89, (int32_t)&g79);
    int32_t v1 = 0; // 0xa6b6
    if (&g30 > NULL) {
        function_af00((int32_t *)95, (int32_t)*(int16_t *)(2 * v1 + a1));
        v1 = v1 + 1 & (int32_t)&g129;
        while (v1 < (int32_t)&g30) {
            // 0xa6a6
            function_af00((int32_t *)95, (int32_t)*(int16_t *)(2 * v1 + a1));
            v1 = v1 + 1 & (int32_t)&g129;
        }
    }
    // 0xa6b8
    function_d0ec((int32_t)&g11);
    function_af00((int32_t *)89, 0x2868);
    int32_t v2 = &g108; // 0xa6e2
    int32_t v3 = function_a960((int32_t *)&g106); // 0xa6ca
    int32_t v4 = v3 & 0xffffffff >> (int32_t)&g24; // 0xa6d2
    bool v5 = false; // 0xa6d6
    int32_t v6 = v4; // 0xa6d6
    while (v4 == 0) {
        // 0xa6da
        function_d0ec(5);
        int32_t v7 = v2 - 1; // 0xa6e0
        v2 = v7 % 256;
        v5 = true;
        v6 = v7;
        if (v2 == 0) {
            // break -> 0xa6e8
            break;
        }
        v3 = function_a960((int32_t *)&g106);
        v4 = v3 & 0xffffffff >> (int32_t)&g24;
        v5 = false;
        v6 = v4;
    }
    // 0xa6e8
    __asm_nop((int32_t *)v6, 0x2868, a3, a4);
    function_af00((int32_t *)2, 0);
    function_d0ec((int32_t)&g23);
    int32_t v8 = function_a61c(); // 0xa6f8
    int32_t result = v8; // 0xa6fe
    if (!v5) {
        // 0xa702
        result = __asm_nop((int32_t *)v8, 0, a3, a4);
    }
    // 0xa700
    return result;
}

// Address range: 0xa710 - 0xa71e
int32_t function_a710(int32_t a1) {
    int32_t v1 = function_a960((int32_t *)&g106); // 0xa714
    return v1 >> (int32_t)&g121;
}

// Address range: 0xa71e - 0xa72e
int32_t function_a71e(int32_t * a1, int32_t a2, char a3, char a4) {
    int32_t v1 = function_a960((int32_t *)&g106); // 0xa722
    return v1 << (int32_t)&g11 >> (int32_t)&g23;
}

// Address range: 0xa72e - 0xa73e
int32_t function_a72e(int32_t * a1) {
    int32_t v1 = function_a960((int32_t *)&g102); // 0xa732
    return v1 << (int32_t)&g11 >> (int32_t)&g20;
}

// Address range: 0xa73e - 0xa74e
int32_t function_a73e(char a1) {
    int32_t v1 = function_a960((int32_t *)103); // 0xa742
    return v1 & 0xffffffff >> (int32_t)&g14;
}

// Address range: 0xa74e - 0xa77e
int32_t function_a74e(int32_t * a1, int32_t * a2, int32_t * a3, int32_t a4) {
    int32_t v1 = function_a960((int32_t *)103); // 0xa758
    *(int16_t *)a1 = (int16_t)v1 & (int16_t)(0xffffffff >> (int32_t)&g14);
    int32_t v2 = function_a960((int32_t *)101); // 0xa766
    *(char *)a2 = (char)v2 & (char)(0xffffffff >> (int32_t)&g17);
    int32_t result = function_a960((int32_t *)99); // 0xa774
    *(char *)a3 = (char)result;
    return result;
}

// Address range: 0xa77e - 0xa792
int32_t function_a77e(int32_t * a1) {
    int32_t v1 = function_a960(&g78); // 0xa784
    int32_t result = v1 & 0xffffffff >> (int32_t)&g3; // 0xa78c
    *(int16_t *)a1 = (int16_t)result;
    return result;
}

// Address range: 0xa794 - 0xa7c8
int32_t function_a794(uint32_t a1, int32_t a2) {
    int16_t v1 = *(int16_t *)0x2000035e;
    int16_t v2 = (int32_t)&g63 >> a1;
    uint16_t v3 = a2 == 1 ? v1 | v2 : v1 & -1 - v2;
    *(int16_t *)0x2000035e = v3;
    return function_af00((int32_t *)&g48, (int32_t)v3);
}

// Address range: 0xa7cc - 0xa8d6
int32_t function_a7cc(void) {
    // 0xa7cc
    function_bfe4(0x40061000, NULL);
    function_bfe4(0x40061000, (int32_t *)1);
    function_bfe4(0x40061000, (int32_t *)2);
    function_af00(NULL, 1 << (uint32_t)(int32_t)&g126);
    function_af00(NULL, 0);
    function_af00(&g54, 0x1d0f);
    function_af00((int32_t *)&g53, (int32_t)&g28);
    function_c158(0);
    function_af00((int32_t *)&g17, 0x1041);
    function_af00((int32_t *)125, 0xe940);
    function_af00(&g69, 0xb3a8);
    function_af00((int32_t *)&g95, 111);
    function_af00((int32_t *)&g95, 0x106b);
    function_af00((int32_t *)&g95, 0x2067);
    function_af00((int32_t *)&g95, 0x3062);
    function_af00((int32_t *)&g95, 0x4050);
    function_af00((int32_t *)&g95, 0x5047);
    function_af00((int32_t *)&g95, 0x603a);
    function_af00((int32_t *)&g95, 0x702c);
    function_af00((int32_t *)&g95, 0x8041);
    function_af00((int32_t *)&g95, 0x9037);
    function_af00((int32_t *)&g95, 0xa025);
    function_af00((int32_t *)&g95, (int32_t)&g104);
    function_af00((int32_t *)&g95, 0xc0e4);
    function_af00((int32_t *)&g95, 0xd0cb);
    function_af00((int32_t *)&g95, 0xe0b5);
    function_af00((int32_t *)&g95, 0xf09f);
    function_af00((int32_t *)&g24, 0x5454);
    function_af00((int32_t *)62, 0xa037);
    *(int16_t *)0x2000035e = (int16_t)((int32_t)&g95 << (uint32_t)(int32_t)&g106);
    function_af00((int32_t *)&g48, (int32_t)(int16_t)((int32_t)&g95 << (int32_t)&g106));
    return function_af00(&g61, 0);
}

// Address range: 0xa92c - 0xa95a
int32_t function_a92c(int32_t a1) {
    uint32_t v1 = 0; // 0xa94e
    if (&g106 <= NULL) {
        // 0xa950
        return a1 << (int32_t)&g11 >> (int32_t)&g12 << (int32_t)&g106 | a1;
    }
    int32_t v2 = a1 << (int32_t)&g3 >> (int32_t)&g2; // 0xa938
    int32_t v3 = (v2 & 1 << (int32_t)&g106) == 0 ? v2 : v2 ^ 2282;
    v1 = (v1 + 1) % 256;
    while (v1 < (int32_t)&g106) {
        // 0xa936
        v2 = v3 << (int32_t)&g3 >> (int32_t)&g2;
        v3 = (v2 & 1 << (int32_t)&g106) == 0 ? v2 : v2 ^ 2282;
        v1 = (v1 + 1) % 256;
    }
    // 0xa950
    return v3 << (int32_t)&g11 >> (int32_t)&g12 << (int32_t)&g106 | a1;
}

// Address range: 0xa960 - 0xa9b4
int32_t function_a960(int32_t * a1) {
    // 0xa960
    function_bfe4(0x40061000, NULL);
    function_bf98(0x40061000, 1);
    function_d100(1);
    function_bf98(0x40061000, 0);
    function_abd8((int32_t)a1 | (int32_t)&g91);
    int32_t result = function_ab58(); // 0xa98c
    function_bfe4(0x40061000, NULL);
    function_d100(1);
    function_bfe4(0x40061000, (int32_t *)1);
    function_bfe4(0x40061000, (int32_t *)2);
    return result;
}

// Address range: 0xa9b8 - 0xaa0e
int32_t function_a9b8(char a1, char a2, char a3, char a4, int32_t a5, int32_t a6) {
    // 0xa9b8
    function_af00(&g83, 0);
    function_af00((int32_t *)77, a5 | 5 << (uint32_t)(int32_t)&g111);
    function_af00((int32_t *)78, a6 | 0x6f00);
    function_af00((int32_t *)79, (int32_t)a4 << (uint32_t)(int32_t)&g90 | (int32_t)a3);
    function_af00(&g87, (int32_t)a1 << (uint32_t)(int32_t)&g90 | (int32_t)a2);
    function_a348(NULL);
    return function_c134();
}

// Address range: 0xaa10 - 0xaa40
int32_t function_aa10(int32_t a1) {
    // 0xaa10
    function_af00((int32_t *)81, 0x8033);
    function_af00((int32_t *)&g82, 2775);
    function_af00((int32_t *)&g90, a1 & 0xffffffff >> (uint32_t)(int32_t)&g11);
    int32_t result = function_af00((int32_t *)&g90, ((uint32_t)(a1 << (uint32_t)(int32_t)&g90) >> (uint32_t)(int32_t)&g11) + (1 << (uint32_t)(int32_t)&g126)); // 0xaa3a
    return result;
}

// Address range: 0xaa48 - 0xaa6e
int32_t function_aa48(int32_t a1) {
    // 0xaa48
    int32_t v1; // 0xaa48
    int32_t v2; // 0xaa48
    int32_t v3; // 0xaa48
    switch (a1) {
        case 0: {
            int32_t v4 = function_af00(&g65, 0x3028); // 0xaa62
            v2 = 0x3028;
            v1 = v4;
            // break -> 0xaa6a
            break;
        }
        case 1: {
            int32_t v5 = function_af00(&g65, 0x4048); // 0xaa58
            v2 = 0x4048;
            v1 = v5;
            // break -> 0xaa6a
            break;
        }
        default: {
            // 0xaa68
            v1 = __asm_nop((int32_t *)a1, v3, v3, v3);
            // break -> 0xaa6a
            break;
        }
    }
    // 0xaa6a
    return __asm_nop((int32_t *)v1, v2, v3, v3);
}

// Address range: 0xaa78 - 0xaaac
int32_t function_aa78(int32_t a1) {
    // 0xaa78
    function_af00((int32_t *)81, a1 == 2625 ? 0x944a : 0x904a);
    uint32_t v1 = function_128(2065 * a1, (int32_t *)1000); // 0xaa9c
    return function_af00((int32_t *)&g82, v1 % 0x10000);
}

// Address range: 0xaabc - 0xaad2
int32_t function_aabc(uint32_t a1) {
    // 0xaabc
    function_af00(&g55, a1 % 0x10000);
    int32_t result = function_af00((int32_t *)57, a1 >> (uint32_t)(int32_t)&g2); // 0xaacc
    return result;
}

// Address range: 0xaad4 - 0xaafc
int32_t function_aad4(int32_t a1, uint32_t a2) {
    int32_t v1 = a2 < 0x1ab3f00 ? (int32_t)&g90 | 128 : (int32_t)&g28 | 128; // 0xaaee
    return function_af00((int32_t *)&g53, v1 | 256 * (a1 < 255 ? a1 : 255));
}

// Address range: 0xab00 - 0xab0c
int32_t function_ab00(int32_t a1) {
    // 0xab00
    return function_af00((int32_t *)&g82, 0x21ce);
}

// Address range: 0xab10 - 0xab22
int32_t function_ab10(void) {
    // 0xab10
    int32_t v1; // 0xab10
    function_c0cc(0, v1);
    return function_af00((int32_t *)81, 0x804a);
}

// Address range: 0xab28 - 0xab3a
int32_t function_ab28(void) {
    // 0xab28
    int32_t v1; // 0xab28
    function_c0cc((int32_t)&g62, v1);
    return function_af00((int32_t *)81, 0x904a);
}

// Address range: 0xab40 - 0xab56
int32_t function_ab40(void) {
    // 0xab40
    function_af00(&g45, 0);
    int32_t result = function_af00(&g54, (int32_t)&g21 << (uint32_t)(int32_t)&g90); // 0xab50
    return result;
}

// Address range: 0xab58 - 0xabce
int32_t function_ab58(void) {
    // 0xab58
    *(int32_t *)0x400b0108 = *(int32_t *)0x400b0108 | (int32_t)&g62;
    int32_t v1 = *(int32_t *)0x40061004; // 0xab6a
    *(int32_t *)0x40061004 = v1 & ((int32_t)&g62 ^ -1);
    function_d100(1);
    uint32_t v2 = 0; // 0xabb0
    int32_t v3 = 0; // 0xabb0
    int32_t result = 0; // 0xabb0
    if (&g2 > NULL) {
        v3 = (function_bfb2(0x40061000, 2) | 2 * v3) % 0x10000;
        function_bfe4(0x40061000, (int32_t *)1);
        function_d100(1);
        function_bf98(0x40061000, 1);
        function_d100(1);
        v2 = (v2 + 1) % 256;
        result = v3;
        while (v2 < (int32_t)&g2) {
            // 0xab7e
            v3 = (function_bfb2(0x40061000, 2) | 2 * v3) % 0x10000;
            function_bfe4(0x40061000, (int32_t *)1);
            function_d100(1);
            function_bf98(0x40061000, 1);
            function_d100(1);
            v2 = (v2 + 1) % 256;
            result = v3;
        }
    }
    int32_t v4 = *(int32_t *)0x400b0108; // 0xabb4
    *(int32_t *)0x400b0108 = v4 & ((int32_t)&g62 ^ -1);
    *(int32_t *)0x40061004 = *(int32_t *)0x40061004 | (int32_t)&g62;
    return result;
}

// Address range: 0xabd8 - 0xac32
int32_t function_abd8(int32_t a1) {
    int32_t v1 = a1; // 0xac2e
    int32_t result = function_bf98(0x40061000, 1); // 0xac2e
    if (&g90 <= NULL) {
        // 0xac30
        return result;
    }
    if ((v1 & (int32_t)&g91) == 0) {
        // 0xabfa
        function_bf98(0x40061000, 2);
    } else {
        // 0xabf0
        function_bfe4(0x40061000, (int32_t *)2);
    }
    // 0xac02
    function_d100(1);
    function_bfe4(0x40061000, (int32_t *)1);
    function_d100(1);
    function_bf98(0x40061000, 1);
    function_d100(1);
    int32_t result2 = 1; // 0xac28
    uint32_t v2 = result2 % 256; // 0xac2a
    v1 = v1 << (int32_t)&g17 >> (int32_t)&g16;
    while (v2 < (int32_t)&g90) {
        // 0xabe8
        if ((v1 & (int32_t)&g91) == 0) {
            // 0xabfa
            function_bf98(0x40061000, 2);
        } else {
            // 0xabf0
            function_bfe4(0x40061000, (int32_t *)2);
        }
        // 0xac02
        function_d100(1);
        function_bfe4(0x40061000, (int32_t *)1);
        function_d100(1);
        function_bf98(0x40061000, 1);
        function_d100(1);
        result2 = v2 + 1;
        v2 = result2 % 256;
        v1 = v1 << (int32_t)&g17 >> (int32_t)&g16;
    }
    // 0xac30
    return result2;
}

// Address range: 0xac38 - 0xac94
int32_t function_ac38(int32_t a1) {
    int32_t v1 = a1; // 0xac90
    int32_t result = function_bf98(0x40061000, 1); // 0xac90
    if (&g2 <= NULL) {
        // 0xac92
        return result;
    }
    if ((v1 & 1 << (int32_t)&g126) == 0) {
        // 0xac5c
        function_bf98(0x40061000, 2);
    } else {
        // 0xac52
        function_bfe4(0x40061000, (int32_t *)2);
    }
    // 0xac64
    function_d100(1);
    function_bfe4(0x40061000, (int32_t *)1);
    function_d100(1);
    function_bf98(0x40061000, 1);
    function_d100(1);
    int32_t result2 = 1; // 0xac8a
    uint32_t v2 = result2 % 256; // 0xac8c
    v1 = v1 << (int32_t)&g3 >> (int32_t)&g2;
    while (v2 < (int32_t)&g2) {
        // 0xac48
        if ((v1 & 1 << (int32_t)&g126) == 0) {
            // 0xac5c
            function_bf98(0x40061000, 2);
        } else {
            // 0xac52
            function_bfe4(0x40061000, (int32_t *)2);
        }
        // 0xac64
        function_d100(1);
        function_bfe4(0x40061000, (int32_t *)1);
        function_d100(1);
        function_bf98(0x40061000, 1);
        function_d100(1);
        result2 = v2 + 1;
        v2 = result2 % 256;
        v1 = v1 << (int32_t)&g3 >> (int32_t)&g2;
    }
    // 0xac92
    return result2;
}

// Address range: 0xac98 - 0xacd6
int32_t function_ac98(char a1, int32_t a2) {
    // 0xac98
    function_c0a0(function_a4fc());
    if (a1 == 1) {
        // 0xacaa
        function_a348((int32_t *)&g44);
    } else {
        // 0xacb2
        function_a348(NULL);
    }
    int32_t v1 = function_af00(&g83, (int32_t)"AAAAAAAAAAAc"); // 0xacbc
    function_acf4(v1);
    function_d0ec((int32_t)&g47);
    return function_c0bc(function_a360(a2));
}

// Address range: 0xacdc - 0xacf0
int32_t function_acdc(void) {
    // 0xacdc
    function_af00(&g45, 0);
    return function_af00(&g45, 770);
}

// Address range: 0xacf4 - 0xad00
int32_t function_acf4(int32_t a1) {
    // 0xacf4
    return function_af00(&g45, 0xc3fa);
}

// Address range: 0xad04 - 0xad62
int32_t function_ad04(int32_t a1, int32_t a2, int16_t a3, uint16_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = a3;
    char * v2 = (char *)a1; // 0xad12
    char v3 = *v2; // 0xad12
    if (v3 == 0) {
        // 0xad5c
        return __asm_nop(NULL, a2, v1, (int32_t)a4);
    }
    int32_t v4 = 0; // 0xad52
    function_c0bc(function_a360((int32_t)v3));
    int32_t v5 = v1; // 0xad26
    int16_t v6; // 0xad04
    int32_t v7; // 0xad30
    if (a2 == 1 != (v4 == 0)) {
        // 0xad30
        v7 = (int32_t)*v2;
        v6 = v7 == (int32_t)&g35 | v7 == (int32_t)&g29 ? a4 : (int16_t)a5;
        v5 = v6;
    }
    // 0xad46
    function_c0a0(function_d0ec(v5));
    v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
    function_d0ec(a6);
    char * v8 = (char *)(v4 + a1); // 0xad12
    char v9 = *v8; // 0xad12
    char * v10 = v8; // 0xad16
    while (v9 != 0) {
        // 0xad1a
        function_c0bc(function_a360((int32_t)v9));
        v5 = v1;
        if (a2 == 1 != (v4 == 0)) {
            // 0xad30
            v7 = (int32_t)*v10;
            v6 = v7 == (int32_t)&g35 | v7 == (int32_t)&g29 ? a4 : (int16_t)a5;
            v5 = v6;
        }
        // 0xad46
        function_c0a0(function_d0ec(v5));
        v4 = v4 + (int32_t)&g1 & (int32_t)&g129;
        function_d0ec(a6);
        v8 = (char *)(v4 + a1);
        v9 = *v8;
        v10 = v8;
    }
    // 0xad5c
    return __asm_nop(NULL, a2, v1, (int32_t)a4);
}

// Address range: 0xad64 - 0xad90
int32_t function_ad64(char a1) {
    // 0xad64
    function_c0a0(function_a4fc());
    if (a1 == 1) {
        // 0xad74
        function_a348((int32_t *)&g44);
    } else {
        // 0xad7c
        function_a348(NULL);
    }
    int32_t v1 = function_af00(&g83, (int32_t)"AAAAAAAAAAAc"); // 0xad86
    return function_acf4(v1);
}

// Address range: 0xad94 - 0xae2e
int32_t function_ad94(void) {
    // 0xad94
    function_a348(NULL);
    function_af00(&g74, 0x37c3);
    function_af00((int32_t *)114, 0x3065);
    function_af00(&g83, 224);
    function_af00((int32_t *)93, (int32_t)&g111 << (uint32_t)(int32_t)&g90);
    function_af00((int32_t *)89, 0x8068);
    function_af00((int32_t *)89, (int32_t)&g79);
    function_af00((int32_t *)90, 0x5555);
    function_af00((int32_t *)91, 0x55aa);
    function_af00(&g75, 0xaa30);
    uint32_t v1 = 0; // 0xadfe
    if (&g82 > NULL) {
        function_af00((int32_t *)95, (int32_t)*(int16_t *)(2 * v1 + 0xd2e4));
        v1 = (v1 + 1) % 256;
        while (v1 < (int32_t)&g82) {
            // 0xadec
            function_af00((int32_t *)95, (int32_t)*(int16_t *)(2 * v1 + 0xd2e4));
            v1 = (v1 + 1) % 256;
        }
    }
    // 0xae00
    function_d0ec((int32_t)&g11);
    function_af00((int32_t *)89, 2152);
    function_d0ec((int32_t)&g105);
    function_af00((int32_t *)89, (int32_t)&g79);
    function_af00(&g83, 0);
    return function_af00(&g74, 0);
}

// Address range: 0xae4c - 0xae66
int32_t function_ae4c(void) {
    // 0xae4c
    function_a348(NULL);
    function_c0bc(function_af00((int32_t *)126, 0x302e));
    return function_c22c();
}

// Address range: 0xae6c - 0xaece
int32_t function_ae6c(void) {
    // 0xae6c
    int32_t v1; // 0xae6c
    function_c0a0(v1);
    function_a348(NULL);
    int32_t v2 = function_af00(&g83, (int32_t)&g82 << (int32_t)&g111); // 0xae7e
    function_acf4(v2);
    function_d0ec((int32_t)&g47);
    function_c0bc(function_af00((int32_t *)113, 0x142a));
    int32_t v3 = function_d0ec((int32_t)&g72); // 0xae9c
    function_c0a0(v3);
    function_c0bc(function_af00((int32_t *)113, 0x1c3b));
    int32_t v4 = function_d0ec((int32_t)&g72); // 0xaeb4
    function_c0a0(v4);
    function_af00(&g83, 0);
    return function_af00(&g45, 0xc1fe);
}

// Address range: 0xaedc - 0xaef8
int32_t function_aedc(void) {
    // 0xaedc
    function_af00(&g54, 0x1f0f);
    function_af00(&g45, 0);
    return function_af00(&g45, 0xbff1);
}

// Address range: 0xaf00 - 0xaf5c
int32_t function_af00(int32_t * a1, int32_t a2) {
    // 0xaf00
    function_bfe4(0x40061000, NULL);
    function_bf98(0x40061000, 1);
    function_d100(1);
    function_bf98(0x40061000, 0);
    function_abd8((int32_t)a1);
    function_d100(1);
    function_ac38(a2);
    function_d100(1);
    function_bfe4(0x40061000, NULL);
    function_d100(1);
    function_bfe4(0x40061000, (int32_t *)1);
    return function_bfe4(0x40061000, (int32_t *)2);
}

// Address range: 0xaf60 - 0xaf7a
int32_t function_af60(int32_t result) {
    // 0xaf60
    *(int32_t *)result = *(int32_t *)0x40000080;
    *(int32_t *)(result + (int32_t)&g62) = *(int32_t *)0x40000084;
    *(int32_t *)(result + (int32_t)&g90) = *(int32_t *)0x40000088;
    *(int32_t *)(result + (int32_t)&g106) = *(int32_t *)0x4000008c;
    return result;
}

// Address range: 0xaf80 - 0xafa4
int32_t function_af80(void) {
    // 0xaf80
    function_b05c(function_b8d0());
    function_9dbc();
    function_b768();
    function_b2a8();
    int32_t v1; // 0xaf80
    function_a1ac(0, 0, v1, v1);
    return function_afe0();
}

// Address range: 0xafa4 - 0xafdc
int32_t function_afa4(int32_t a1, uint32_t a2) {
    int32_t v1 = *(int32_t *)0x40003000 | 1; // 0xafb0
    *(int32_t *)0x40003000 = v1;
    uint32_t v2 = 0; // 0xafc6
    if (a2 <= 0) {
        // 0xafc8
        *(int32_t *)0x40003000 = v1 & -2;
        return *(int32_t *)0x4000300c % 0x10000;
    }
    *(int32_t *)0x40003008 = (int32_t)*(char *)(v2 + a1);
    v2 = (v2 + 1) % 0x10000;
    while (v2 < a2) {
        // 0xafba
        *(int32_t *)0x40003008 = (int32_t)*(char *)(v2 + a1);
        v2 = (v2 + 1) % 0x10000;
    }
    // 0xafc8
    *(int32_t *)0x40003000 = *(int32_t *)0x40003000 & -2;
    return *(int32_t *)0x4000300c % 0x10000;
}

// Address range: 0xafe0 - 0xafee
int32_t function_afe0(void) {
    // 0xafe0
    *(int32_t *)0x40003000 = 256;
    *(int32_t *)0x40003004 = 0;
    return 0;
}

// Address range: 0xaff4 - 0xb02a
int32_t function_aff4(uint32_t a1, int32_t * a2, unsigned char a3) {
    // 0xaff4
    function_b510();
    function_b3f8(&g98);
    function_b3f8((int32_t *)((int32_t)a1 >> (uint32_t)(int32_t)&g90));
    function_b3f8((int32_t *)(a1 % 256));
    function_b510();
    function_b3f8((int32_t *)161);
    function_b2aa(a2, (int32_t)a3);
    return function_b550();
}

// Address range: 0xb02a - 0xb05c
int32_t function_b02a(uint32_t a1, int32_t a2) {
    // 0xb02a
    function_b510();
    function_b3f8(&g98);
    function_b3f8((int32_t *)(a1 << (uint32_t)(int32_t)&g2 >> (uint32_t)(int32_t)&g16));
    function_b3f8((int32_t *)(a1 % 256));
    function_b590((int32_t *)a2, (int32_t)&g90);
    function_b550();
    return function_d0ec((int32_t)&g97);
}

// Address range: 0xb05c - 0xb0a6
int32_t function_b05c(int32_t a1) {
    int32_t v1 = *(int32_t *)0x40060004; // 0xb060
    *(int32_t *)0x40060004 = (v1 | (int32_t)&g126 << (int32_t)&g97) & ((int32_t)&g87 ^ -1);
    *(int32_t *)0x40060804 = *(int32_t *)0x40060804 | 0x8a40;
    int32_t v2 = *(int32_t *)0x40061004; // 0xb086
    *(int32_t *)0x40061004 = (v2 | (int32_t)&g24) & ((int32_t)&g26 ^ -1);
    return function_bfe4(0x40060800, (int32_t *)&g126);
}

// Address range: 0xb0b8 - 0xb2a2
int32_t function_b0b8(void) {
    // 0xb0b8
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_bfe4(0x40060000, (int32_t *)&g102);
    function_bfe4(0x40060000, (int32_t *)&g106);
    function_bfe4(0x40060000, (int32_t *)&g111);
    function_d100(1);
    int32_t v1 = function_bfb2(0x40060000, (int32_t)&g44); // 0xb0e6
    int32_t result = (int32_t)&g14; // 0xb0ec
    if (v1 != 0) {
        int32_t v2 = function_bfb2(0x40060000, (int32_t)&g62); // 0xb0f6
        result = &g13;
        if (v2 != 0) {
            // 0xb102
            function_bf98(0x40060000, (int32_t)&g97);
            function_d100(1);
            int32_t v3 = function_bfb2(0x40060000, (int32_t)&g44); // 0xb114
            result = (int32_t)&g97;
            if (v3 != 0) {
                int32_t v4 = function_bfb2(0x40060000, (int32_t)&g62); // 0xb124
                result = 1;
                if (v4 != 0) {
                    int32_t v5 = function_bfb2(0x40060000, 5); // 0xb134
                    result = (int32_t)&g62;
                    if (v5 != 0) {
                        int32_t v6 = function_bfb2(0x40060000, 6); // 0xb144
                        result = (int32_t)&g82;
                        if (v6 != 0) {
                            // 0xb150
                            function_bf98(0x40060000, (int32_t)&g102);
                            function_d100(1);
                            function_bfe4(0x40060000, (int32_t *)&g97);
                            function_d100(1);
                            int32_t v7 = function_bfb2(0x40060000, (int32_t)&g44); // 0xb170
                            result = (int32_t)&g102;
                            if (v7 != 0) {
                                int32_t v8 = function_bfb2(0x40060000, (int32_t)&g62); // 0xb180
                                result = 2;
                                if (v8 != 0) {
                                    // 0xb18c
                                    result = 5;
                                    if (function_bfb2(0x40060000, 5) != 0) {
                                        int32_t v9 = function_bfb2(0x40060000, 6); // 0xb1a0
                                        result = (int32_t)&g90;
                                        if (v9 != 0) {
                                            // 0xb1ac
                                            function_bf98(0x40060000, (int32_t)&g97);
                                            function_d100(1);
                                            function_bfe4(0x40060000, (int32_t *)&g102);
                                            function_d100(1);
                                            function_bfe4(0x40060000, (int32_t *)&g97);
                                            function_d100(1);
                                            function_bf98(0x40060000, (int32_t)&g106);
                                            function_d100(1);
                                            int32_t v10 = function_bfb2(0x40060000, (int32_t)&g44); // 0xb1e8
                                            result = (int32_t)&g106;
                                            if (v10 != 0) {
                                                int32_t v11 = function_bfb2(0x40060000, (int32_t)&g62); // 0xb1f8
                                                result = (int32_t)&g44;
                                                if (v11 != 0) {
                                                    // 0xb204
                                                    result = 6;
                                                    if (function_bfb2(0x40060000, 5) != 0) {
                                                        int32_t v12 = function_bfb2(0x40060000, 6); // 0xb218
                                                        result = (int32_t)&g95;
                                                        if (v12 != 0) {
                                                            // 0xb224
                                                            function_bf98(0x40060000, (int32_t)&g111);
                                                            function_d100(1);
                                                            function_bfe4(0x40060000, (int32_t *)&g106);
                                                            function_d100(1);
                                                            int32_t v13 = function_bfb2(0x40060000, (int32_t)&g44); // 0xb244
                                                            result = (int32_t)&g111;
                                                            if (v13 != 0) {
                                                                int32_t v14 = function_bfb2(0x40060000, (int32_t)&g62); // 0xb254
                                                                result = (int32_t)&g121;
                                                                if (v14 != 0) {
                                                                    // 0xb260
                                                                    result = 0;
                                                                    if (function_bfb2(0x40060000, 5) != 0) {
                                                                        int32_t v15 = function_bfb2(0x40060000, 6); // 0xb274
                                                                        result = v15 == 0 ? (int32_t)&g126 : 255;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0xb27e
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_bfe4(0x40060000, (int32_t *)&g102);
    function_bf98(0x40060000, (int32_t)&g106);
    function_bfe4(0x40060000, (int32_t *)&g111);
    return result;
}

// Address range: 0xb2a8 - 0xb2aa
int32_t function_b2a8(void) {
    // 0xb2a8
    int32_t result; // 0xb2a8
    return result;
}

// Address range: 0xb2aa - 0xb2f8
int32_t function_b2aa(int32_t * a1, int32_t a2) {
    if (a2 == 1) {
        // 0xb2b4
        *(char *)a1 = (char)function_b2f8(1);
        // 0xb2be
        return 1;
    }
    int32_t v1 = (int32_t)a1;
    function_d100(1);
    uint32_t v2 = a2; // 0xb2de
    int32_t v3 = 0; // 0xb2de
    if (a2 > 1) {
        int32_t v4 = 0;
        int32_t v5 = function_b2f8(0); // 0xb2cc
        int32_t v6 = v4 + (int32_t)&g1 & (int32_t)&g129; // 0xb2d4
        *(char *)(v4 + v1) = (char)v5;
        v2 = (v2 + 255) % 256;
        function_d100(1);
        v3 = v6;
        while (v2 > 1) {
            // 0xb2c4
            v4 = v6;
            v5 = function_b2f8(0);
            v6 = v4 + (int32_t)&g1 & (int32_t)&g129;
            *(char *)(v4 + v1) = (char)v5;
            v2 = (v2 + 255) % 256;
            function_d100(1);
            v3 = v6;
        }
    }
    // 0xb2e0
    *(char *)(v3 + v1) = (char)function_b2f8(1);
    // 0xb2be
    return (v3 + 1) % 256;
}

// Address range: 0xb2f8 - 0xb3ec
int32_t function_b2f8(int32_t a1) {
    int32_t v1 = *(int32_t *)0x400b0100; // 0xb2fe
    *(int32_t *)0x400b0100 = v1 | 1 << (int32_t)&g102;
    int32_t v2 = *(int32_t *)0x400b0400; // 0xb30c
    *(int32_t *)0x400b0400 = v2 & (1 << (int32_t)&g102 ^ -1);
    int32_t v3 = *(int32_t *)0x40060004; // 0xb31a
    *(int32_t *)0x40060004 = v3 & (1 << (int32_t)&g102 ^ -1);
    uint32_t v4 = 0; // 0xb376
    int32_t v5 = 0; // 0xb376
    int32_t result = 0; // 0xb376
    if (&g90 > NULL) {
        function_bf98(0x40060000, (int32_t)&g97);
        function_d100(1);
        function_bfe4(0x40060000, (int32_t *)&g97);
        function_d100(1);
        function_d100(1);
        int32_t v6 = function_bfb2(0x40060000, (int32_t)&g102); // 0xb356
        v5 = v5 << (int32_t)&g17 >> (int32_t)&g16 | (int32_t)(v6 != 0);
        function_bf98(0x40060000, (int32_t)&g97);
        function_d100(1);
        v4 = (v4 + 1) % 0x10000;
        result = v5;
        while (v4 < (int32_t)&g90) {
            // 0xb32c
            function_bf98(0x40060000, (int32_t)&g97);
            function_d100(1);
            function_bfe4(0x40060000, (int32_t *)&g97);
            function_d100(1);
            function_d100(1);
            v6 = function_bfb2(0x40060000, (int32_t)&g102);
            v5 = v5 << (int32_t)&g17 >> (int32_t)&g16 | (int32_t)(v6 != 0);
            function_bf98(0x40060000, (int32_t)&g97);
            function_d100(1);
            v4 = (v4 + 1) % 0x10000;
            result = v5;
        }
    }
    int32_t v7 = *(int32_t *)0x400b0100; // 0xb37a
    *(int32_t *)0x400b0100 = v7 & (1 << (int32_t)&g102 ^ -1);
    int32_t v8 = *(int32_t *)0x400b0400; // 0xb388
    *(int32_t *)0x400b0400 = v8 | 1 << (int32_t)&g102;
    int32_t v9 = *(int32_t *)0x40060004; // 0xb396
    *(int32_t *)0x40060004 = v9 | 1 << (int32_t)&g102;
    function_bf98(0x40060000, (int32_t)&g97);
    function_d100(1);
    if (a1 == 0) {
        // 0xb3b4
        function_bf98(0x40060000, (int32_t)&g102);
    } else {
        // 0xb3be
        function_bfe4(0x40060000, (int32_t *)&g102);
    }
    // 0xb3c6
    function_d100(1);
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_d100(1);
    function_bf98(0x40060000, (int32_t)&g97);
    function_d100(1);
    return result;
}

// Address range: 0xb3f8 - 0xb502
int32_t function_b3f8(int32_t * a1) {
    // 0xb3f8
    function_bf98(0x40060000, (int32_t)&g97);
    function_d100(1);
    if (&g90 > NULL) {
        uint32_t v1 = 0; // 0xb450
        int32_t v2 = (int32_t)a1; // 0xb3f8
        if ((v2 & (int32_t)&g91) == 0) {
            // 0xb420
            function_bf98(0x40060000, (int32_t)&g102);
        } else {
            // 0xb416
            function_bfe4(0x40060000, (int32_t *)&g102);
        }
        // 0xb428
        function_d100(1);
        function_bfe4(0x40060000, (int32_t *)&g97);
        function_d100(1);
        function_bf98(0x40060000, (int32_t)&g97);
        function_d100(1);
        v1 = (v1 + 1) % 0x10000;
        v2 = v2 << (int32_t)&g17 >> (int32_t)&g16;
        while (v1 < (int32_t)&g90) {
            // 0xb40e
            if ((v2 & (int32_t)&g91) == 0) {
                // 0xb420
                function_bf98(0x40060000, (int32_t)&g102);
            } else {
                // 0xb416
                function_bfe4(0x40060000, (int32_t *)&g102);
            }
            // 0xb428
            function_d100(1);
            function_bfe4(0x40060000, (int32_t *)&g97);
            function_d100(1);
            function_bf98(0x40060000, (int32_t)&g97);
            function_d100(1);
            v1 = (v1 + 1) % 0x10000;
            v2 = v2 << (int32_t)&g17 >> (int32_t)&g16;
        }
    }
    int32_t v3 = *(int32_t *)0x400b0100; // 0xb458
    *(int32_t *)0x400b0100 = v3 | 1 << (int32_t)&g102;
    int32_t v4 = *(int32_t *)0x400b0400; // 0xb466
    *(int32_t *)0x400b0400 = v4 & (1 << (int32_t)&g102 ^ -1);
    int32_t v5 = *(int32_t *)0x40060004; // 0xb474
    *(int32_t *)0x40060004 = v5 & (1 << (int32_t)&g102 ^ -1);
    function_bfe4(0x40060000, (int32_t *)&g102);
    function_d100(1);
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_d100(1);
    uint32_t v6 = 0; // 0xb4b6
    int32_t v7 = function_bfb2(0x40060000, (int32_t)&g102); // 0xb4a4
    int32_t v8 = 0; // 0xb4aa
    int32_t result = 0; // 0xb4aa
    while (v7 != 0) {
        int32_t v9 = v6 + 1; // 0xb4b4
        v6 = v9 % 0x10000;
        v8 = v9;
        result = 255;
        if (v6 >= 255) {
            // break -> 0xb4bc
            break;
        }
        v7 = function_bfb2(0x40060000, (int32_t)&g102);
        v8 = 0;
        result = 0;
    }
    // 0xb4bc
    int32_t v10; // 0xb3f8
    __asm_nop((int32_t *)v8, (int32_t)&g102, v10, v10);
    function_bf98(0x40060000, (int32_t)&g97);
    function_d100(1);
    int32_t v11 = *(int32_t *)0x400b0100; // 0xb4ce
    *(int32_t *)0x400b0100 = v11 & (1 << (int32_t)&g102 ^ -1);
    int32_t v12 = *(int32_t *)0x400b0400; // 0xb4dc
    *(int32_t *)0x400b0400 = v12 | 1 << (int32_t)&g102;
    int32_t v13 = *(int32_t *)0x40060004; // 0xb4ea
    *(int32_t *)0x40060004 = v13 | 1 << (int32_t)&g102;
    function_bfe4(0x40060000, (int32_t *)&g102);
    return result;
}

// Address range: 0xb510 - 0xb54c
int32_t function_b510(void) {
    // 0xb510
    function_bfe4(0x40060000, (int32_t *)&g102);
    function_d100(1);
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_d100(1);
    function_bf98(0x40060000, (int32_t)&g102);
    function_d100(1);
    function_bf98(0x40060000, (int32_t)&g97);
    return function_d100(1);
}

// Address range: 0xb550 - 0xb58c
int32_t function_b550(void) {
    // 0xb550
    function_bf98(0x40060000, (int32_t)&g102);
    function_d100(1);
    function_bf98(0x40060000, (int32_t)&g97);
    function_d100(1);
    function_bfe4(0x40060000, (int32_t *)&g97);
    function_d100(1);
    function_bfe4(0x40060000, (int32_t *)&g102);
    return function_d100(1);
}

// Address range: 0xb590 - 0xb5b4
int32_t function_b590(int32_t * a1, int32_t a2) {
    // 0xb590
    if (a2 == 0) {
        // 0xb5a6
        return 0;
    }
    int32_t v1 = a2; // 0xb5aa
    int32_t v2 = (int32_t)a1; // 0xb590
    int32_t result = 255; // 0xb5a2
    while (function_b3f8((int32_t *)(int32_t)*(char *)v2) == 0) {
        // 0xb5a8
        v1 = (v1 + 255) % 256;
        v2 += (int32_t)&g1;
        result = 0;
        if (v1 == 0) {
            // break -> 0xb5a6
            break;
        }
        result = 255;
    }
    // 0xb5a6
    return result;
}

// Address range: 0xb5b4 - 0xb62e
int32_t function_b5b4(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5) {
    uint32_t v1 = (int32_t)a3;
    function_c344(0x400b8000, 0);
    function_b844((a1 + (int32_t)&g62) % 256, a2);
    function_bfe4(0x40060800, (int32_t *)&g95);
    if (a5 == 0) {
        uint32_t v2 = 0; // 0xb5fc
        if (a3 <= NULL) {
            // 0xb61e
            function_baa4();
            return function_c344(0x400b8000, 1);
        }
        __asm_nop((int32_t *)0, (int32_t)&g95, v1, a4);
        int32_t v3 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb5e6
        while ((v3 & (int32_t)&g2) != 0) {
            // continue -> 0xb5e4
        }
        // 0xb5f0
        *(int32_t *)0x400b8004 = (int32_t)*(char *)(v2 + a4);
        int32_t v4 = v2 + 1; // 0xb5f6
        v2 = v4 % 0x10000;
        int32_t v5 = 0x400b8000; // 0xb5fc
        while (v2 < v1) {
            // 0xb5e2
            __asm_nop((int32_t *)v4, v5, v1, a4);
            v3 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v3 & (int32_t)&g2) != 0) {
                // continue -> 0xb5e4
            }
            // 0xb5f0
            *(int32_t *)0x400b8004 = (int32_t)*(char *)(v2 + a4);
            v4 = v2 + 1;
            v2 = v4 % 0x10000;
            v5 = 0x400b8000;
        }
    } else {
        // 0xb61a
        if (a3 <= NULL) {
            // 0xb61e
            function_baa4();
            return function_c344(0x400b8000, 1);
        }
        __asm_nop((int32_t *)a5, (int32_t)&g95, v1, a4);
        int32_t v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb608
        while ((v6 & (int32_t)&g2) != 0) {
            // continue -> 0xb606
        }
        // 0xb612
        *(int32_t *)0x400b8004 = 0;
        int32_t v7 = 1; // 0xb616
        uint32_t v8 = v7 % 0x10000; // 0xb618
        int32_t v9 = 0x400b8000; // 0xb61c
        while (v8 < v1) {
            // 0xb604
            __asm_nop((int32_t *)v7, v9, v1, a4);
            v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v6 & (int32_t)&g2) != 0) {
                // continue -> 0xb606
            }
            // 0xb612
            *(int32_t *)0x400b8004 = 0;
            v7 = v8 + 1;
            v8 = v7 % 0x10000;
            v9 = 0x400b8000;
        }
    }
    // 0xb61e
    function_baa4();
    return function_c344(0x400b8000, 1);
}

// Address range: 0xb638 - 0xb6a2
int32_t function_b638(void) {
    // 0xb638
    function_c344(0x400b8000, 0);
    function_b8a8(&g63);
    if (&g82 <= NULL) {
        // 0xb692
        function_d0ec((int32_t)&g11);
        return function_c344(0x400b8000, 1);
    }
    int32_t v1 = 0;
    uint32_t v2 = v1 + 1; // 0xb64c
    function_b844((int32_t)&g62, v2 % 256);
    int32_t v3 = function_bfe4(0x40060800, (int32_t *)&g95); // 0xb65c
    int32_t v4; // 0xb638
    int32_t v5; // 0xb67e
    uint32_t v6; // 0xb680
    int32_t v7; // 0xb638
    int32_t v8; // 0xb638
    int32_t v9; // 0xb668
    if (&g91 > NULL) {
        // 0xb664
        v8 = 128 * v1 + 0x20000704;
        v6 = 0;
        __asm_nop((int32_t *)v3, (int32_t)&g95, v7, v7);
        v9 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
        while ((v9 & (int32_t)&g2) != 0) {
            // continue -> 0xb666
        }
        // 0xb672
        *(int32_t *)0x400b8004 = (int32_t)*(char *)(v8 + v6);
        v5 = v6 + 1;
        v6 = v5 % 0x10000;
        v4 = 0x400b8000;
        while (v6 < (int32_t)&g91) {
            // 0xb664
            __asm_nop((int32_t *)v5, v4, v7, v7);
            v9 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v9 & (int32_t)&g2) != 0) {
                // continue -> 0xb666
            }
            // 0xb672
            *(int32_t *)0x400b8004 = (int32_t)*(char *)(v8 + v6);
            v5 = v6 + 1;
            v6 = v5 % 0x10000;
            v4 = 0x400b8000;
        }
    }
    // 0xb686
    function_baa4();
    uint32_t v10 = v2 % 0x10000; // 0xb68c
    while (v10 < (int32_t)&g82) {
        // 0xb64c
        v1 = v10;
        v2 = v1 + 1;
        function_b844((int32_t)&g62, v2 % 256);
        v3 = function_bfe4(0x40060800, (int32_t *)&g95);
        if (&g91 > NULL) {
            // 0xb664
            v8 = 128 * v1 + 0x20000704;
            v6 = 0;
            __asm_nop((int32_t *)v3, (int32_t)&g95, v7, v7);
            v9 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v9 & (int32_t)&g2) != 0) {
                // continue -> 0xb666
            }
            // 0xb672
            *(int32_t *)0x400b8004 = (int32_t)*(char *)(v8 + v6);
            v5 = v6 + 1;
            v6 = v5 % 0x10000;
            v4 = 0x400b8000;
            while (v6 < (int32_t)&g91) {
                // 0xb664
                __asm_nop((int32_t *)v5, v4, v7, v7);
                v9 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
                while ((v9 & (int32_t)&g2) != 0) {
                    // continue -> 0xb666
                }
                // 0xb672
                *(int32_t *)0x400b8004 = (int32_t)*(char *)(v8 + v6);
                v5 = v6 + 1;
                v6 = v5 % 0x10000;
                v4 = 0x400b8000;
            }
        }
        // 0xb686
        function_baa4();
        v10 = v2 % 0x10000;
    }
    // 0xb692
    function_d0ec((int32_t)&g11);
    return function_c344(0x400b8000, 1);
}

// Address range: 0xb6b0 - 0xb700
int32_t function_b6b0(void) {
    // 0xb6b0
    function_c344(0x400b8000, 0);
    function_b8a8(&g63);
    function_b844((int32_t)&g62, 0);
    int32_t v1 = function_bfe4(0x40060800, (int32_t *)&g95); // 0xb6cc
    uint32_t v2 = 0; // 0xb6f0
    if (&g91 <= NULL) {
        // 0xb6f2
        function_baa4();
        return function_c344(0x400b8000, 1);
    }
    int32_t v3; // 0xb6b0
    __asm_nop((int32_t *)v1, (int32_t)&g95, v3, v3);
    int32_t v4 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb6d8
    while ((v4 & (int32_t)&g2) != 0) {
        // continue -> 0xb6d6
    }
    // 0xb6e2
    *(int32_t *)0x400b8004 = (int32_t)*(char *)(v2 + 0x20000684);
    int32_t v5 = v2 + 1; // 0xb6ea
    v2 = v5 % 0x10000;
    int32_t v6 = 0x400b8000; // 0xb6f0
    while (v2 < (int32_t)&g91) {
        // 0xb6d4
        __asm_nop((int32_t *)v5, v6, v3, v3);
        v4 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
        while ((v4 & (int32_t)&g2) != 0) {
            // continue -> 0xb6d6
        }
        // 0xb6e2
        *(int32_t *)0x400b8004 = (int32_t)*(char *)(v2 + 0x20000684);
        v5 = v2 + 1;
        v2 = v5 % 0x10000;
        v6 = 0x400b8000;
    }
    // 0xb6f2
    function_baa4();
    return function_c344(0x400b8000, 1);
}

// Address range: 0xb70c - 0xb760
int32_t function_b70c(int32_t a1) {
    // 0xb70c
    function_c344(0x400b8000, 0);
    if (&g90 <= NULL) {
        // 0xb756
        return function_c344(0x400b8000, 1);
    }
    uint32_t v1 = 0; // 0xb754
    function_b844(0, v1 % 256);
    int32_t v2 = function_bfe4(0x40060800, (int32_t *)&g95); // 0xb748
    int32_t v3; // 0xb70c
    int32_t v4; // 0xb70c
    int32_t v5; // 0xb70c
    int32_t v6; // 0xb734
    int32_t v7; // 0xb742
    uint32_t v8; // 0xb744
    if (&g92 > NULL) {
        __asm_nop((int32_t *)v2, (int32_t)&g95, v5, v5);
        v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
        while ((v6 & (int32_t)&g2) != 0) {
            // continue -> 0xb732
        }
        // 0xb73e
        *(int32_t *)0x400b8004 = a1;
        v7 = 1;
        v8 = v7 % 0x10000;
        v4 = v8;
        v2 = v7;
        v3 = (int32_t)&g2;
        while (v8 < (int32_t)&g92) {
            // 0xb730
            __asm_nop((int32_t *)v2, v3, v5, v5);
            v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v6 & (int32_t)&g2) != 0) {
                // continue -> 0xb732
            }
            // 0xb73e
            *(int32_t *)0x400b8004 = a1;
            v7 = v4 + 1;
            v8 = v7 % 0x10000;
            v4 = v8;
            v2 = v7;
            v3 = (int32_t)&g2;
        }
    }
    // 0xb74a
    function_baa4();
    v1 = (v1 + 1) % 0x10000;
    while (v1 < (int32_t)&g90) {
        // 0xb71c
        function_b844(0, v1 % 256);
        v2 = function_bfe4(0x40060800, (int32_t *)&g95);
        if (&g92 > NULL) {
            __asm_nop((int32_t *)v2, (int32_t)&g95, v5, v5);
            v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
            while ((v6 & (int32_t)&g2) != 0) {
                // continue -> 0xb732
            }
            // 0xb73e
            *(int32_t *)0x400b8004 = a1;
            v7 = 1;
            v8 = v7 % 0x10000;
            v4 = v8;
            v2 = v7;
            v3 = (int32_t)&g2;
            while (v8 < (int32_t)&g92) {
                // 0xb730
                __asm_nop((int32_t *)v2, v3, v5, v5);
                v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000);
                while ((v6 & (int32_t)&g2) != 0) {
                    // continue -> 0xb732
                }
                // 0xb73e
                *(int32_t *)0x400b8004 = a1;
                v7 = v4 + 1;
                v8 = v7 % 0x10000;
                v4 = v8;
                v2 = v7;
                v3 = (int32_t)&g2;
            }
        }
        // 0xb74a
        function_baa4();
        v1 = (v1 + 1) % 0x10000;
    }
    // 0xb756
    return function_c344(0x400b8000, 1);
}

// Address range: 0xb768 - 0xb80c
int32_t function_b768(void) {
    // 0xb768
    int32_t v1; // 0xb768
    function_ba6c(v1, v1, v1, v1);
    function_b810();
    function_c344(0x400b8000, 0);
    function_b8a8((int32_t *)226);
    function_d0ec((int32_t)&g87);
    function_b8a8((int32_t *)162);
    function_b8a8(&g107);
    function_b8a8((int32_t *)161);
    function_b8a8((int32_t *)166);
    function_b8a8(&g99);
    function_b8a8((int32_t *)&g30);
    function_b8a8((int32_t *)129);
    function_b8a8((int32_t *)&g24);
    function_b8a8(&g36);
    function_d0ec(1);
    function_b8a8((int32_t *)&g40);
    function_d0ec(1);
    function_b8a8(&g43);
    function_b8a8(&g43);
    function_b8a8(&g43);
    function_b8a8(&g43);
    function_d0ec((int32_t)&g34);
    function_b8a8(&g63);
    function_b8a8((int32_t *)175);
    function_baa4();
    function_c344(0x400b8000, 1);
    return function_b70c(0);
}

// Address range: 0xb810 - 0xb83e
int32_t function_b810(void) {
    // 0xb810
    function_bfe4(0x40060800, (int32_t *)&g102);
    function_d0ec(1);
    function_bf98(0x40060800, (int32_t)&g102);
    function_d0ec((int32_t)&g11);
    function_bfe4(0x40060800, (int32_t *)&g102);
    return function_d0ec((int32_t)&g87);
}

// Address range: 0xb844 - 0xb8a0
int32_t function_b844(int32_t a1, int32_t a2) {
    // 0xb844
    function_bf98(0x40060800, (int32_t)&g95);
    uint32_t v1 = a2 + (int32_t)&g103; // 0xb854
    int32_t v2; // 0xb844
    __asm_nop((int32_t *)v1, (int32_t)&g95, v2, v2);
    int32_t v3 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb85c
    while ((v3 & (int32_t)&g2) != 0) {
        // continue -> 0xb85a
    }
    // 0xb866
    *(int32_t *)0x400b8004 = v1 % 256;
    int32_t v4 = a1 << (int32_t)&g16 >> (int32_t)&g20 | (int32_t)&g2; // 0xb86e
    __asm_nop((int32_t *)v4, (int32_t)&g2, v2, v2);
    int32_t v5 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb876
    while ((v5 & (int32_t)&g2) != 0) {
        // continue -> 0xb874
    }
    // 0xb880
    *(int32_t *)0x400b8004 = v4;
    __asm_nop((int32_t *)0x400b8000, (int32_t)&g2, v2, v2);
    int32_t v6 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb88c
    while ((v6 & (int32_t)&g2) != 0) {
        // continue -> 0xb88a
    }
    // 0xb896
    *(int32_t *)0x400b8004 = a1 & 0xffffffff >> (int32_t)&g20;
    return function_baa4();
}

// Address range: 0xb8a8 - 0xb8c8
int32_t function_b8a8(int32_t * a1) {
    int32_t v1 = function_bf98(0x40060800, (int32_t)&g95); // 0xb8b0
    int32_t v2; // 0xb8a8
    __asm_nop((int32_t *)v1, (int32_t)&g95, v2, v2);
    int32_t v3 = *(int32_t *)((int32_t)&g16 + 0x400b8000); // 0xb8b8
    while ((v3 & (int32_t)&g2) != 0) {
        // continue -> 0xb8b6
    }
    // 0xb8c2
    *(int32_t *)0x400b8004 = (int32_t)a1;
    return 0x400b8000;
}

// Address range: 0xb8d0 - 0xba38
int32_t function_b8d0(void) {
    int32_t v1 = *(int32_t *)0x400b0000; // 0xb8d2
    *(int32_t *)0x400b0000 = v1 & -0xffff001 | 1 << (int32_t)&g20;
    *(int32_t *)0x400b0004 = *(int32_t *)0x400b0004 & -0x5ffff52 | 0x5000051;
    int32_t v2 = *(int32_t *)((int32_t)&g90 + 0x400b0000); // 0xb904
    *(int32_t *)0x400b0008 = v2 & 0xffffffff >> (int32_t)&g90 | 1 << (int32_t)&g20;
    *(int32_t *)0x400b000c = *(int32_t *)0x400b000c & 0xff0e0e | 257;
    int32_t v3 = *(int32_t *)((int32_t)&g2 + 0x400b0000); // 0xb936
    *(int32_t *)0x400b0010 = v3 & -1 << (int32_t)&g16;
    int32_t v4 = *(int32_t *)0x400b0100; // 0xb940
    *(int32_t *)0x400b0100 = (v4 | (int32_t)&g15) & ((int32_t)&g126 << (int32_t)&g97 ^ -1);
    int32_t v5 = *(int32_t *)0x400b0200; // 0xb95c
    *(int32_t *)0x400b0200 = (v5 | (int32_t)&g87) & ((int32_t)&g126 << (int32_t)&g97 ^ -1);
    *(int32_t *)0x400b0300 = *(int32_t *)0x400b0300 & -0x3c79;
    int32_t v6 = *(int32_t *)0x400b0400; // 0xb982
    *(int32_t *)0x400b0400 = (v6 | (int32_t)&g87) & ((int32_t)&g126 << (int32_t)&g97 ^ -1);
    int32_t v7 = *(int32_t *)0x400b0104; // 0xb99c
    *(int32_t *)0x400b0104 = (v7 | 1 << (int32_t)&g121) & -0x8fc1;
    *(int32_t *)0x400b0204 = *(int32_t *)0x400b0204 & -0xca41;
    *(int32_t *)0x400b0304 = *(int32_t *)0x400b0304 & -0xca41;
    int32_t v8 = *(int32_t *)0x400b0404; // 0xb9ce
    *(int32_t *)0x400b0404 = v8 & -0x8a41 | 1 << (int32_t)&g121;
    int32_t v9 = *(int32_t *)0x400b0108; // 0xb9e8
    *(int32_t *)0x400b0108 = v9 | (int32_t)&g26;
    int32_t v10 = *(int32_t *)((int32_t)&g90 + 0x400b0100); // 0xb9f4
    *(int32_t *)0x400b0108 = v10 & -32;
    int32_t v11 = *(int32_t *)0x400b0208; // 0xb9fe
    *(int32_t *)0x400b0208 = v11 | (int32_t)&g26;
    int32_t v12 = *(int32_t *)((int32_t)&g90 + 0x400b0200); // 0xba0a
    *(int32_t *)0x400b0208 = v12 & -32;
    *(int32_t *)0x400b0308 = *(int32_t *)0x400b0308 & -64;
    int32_t result = *(int32_t *)0x400b0408 & -32 | (int32_t)&g26; // 0xba30
    *(int32_t *)0x400b0408 = result;
    return result;
}

// Address range: 0xba6c - 0xbaa0
int32_t function_ba6c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xba6c
    function_c25c(0x400b8000);
    int32_t v1 = 1; // bp-16, 0xba80
    function_c268(0x400b8000, &v1);
    return function_c360(0x400b8000);
}

// Address range: 0xbaa4 - 0xbac2
int32_t function_baa4(void) {
    int32_t v1 = *(int32_t *)((int32_t)&g11 + 0x400b8000); // 0xbab4
    int32_t v2 = 0; // 0xbaa6
    int32_t v3 = 0; // 0xbabc
    int32_t v4 = 0; // 0xbabc
    while ((v1 & (int32_t)&g26) != 0) {
        // 0xbaa8
        v2++;
        v3 = 0x186a0;
        v4 = v2;
        if (v2 != 0x186a0 && v2 >= 0x186a0) {
            // break -> 0xbabe
            break;
        }
        v3 = 0;
        v4 = 0;
    }
    // 0xbabe
    int32_t v5; // 0xbaa4
    return __asm_nop((int32_t *)v4, v3, (int32_t)&g26, v5);
}

// Address range: 0xbacc - 0xbafc
int32_t function_bacc(void) {
    // 0xbacc
    *(int32_t *)-0x1fff1fec = 0x752ff;
    function_c014((int32_t)&g44 - (int32_t)&g62, (int32_t *)&g44);
    *(int32_t *)-0x1fff1fe8 = 0;
    *(int32_t *)-0x1fff1ff0 = (int32_t)&g82;
    int32_t v1; // 0xbacc
    __asm_nop((int32_t *)&g82, -0x1fff2000, v1, v1);
    *(int32_t *)0x20000324 = (int32_t)&g45;
    return &g45;
}

// Address range: 0xbb0c - 0xbba4
int32_t function_bb0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xbb0c
    *(int32_t *)0x4006b800 = *(int32_t *)0x4006b800 & -2;
    uint32_t v1 = *(int32_t *)((int32_t)&g55 + 0x40000040); // 0xbb1c
    uint32_t v2 = v1 / 2048 % 0x100000; // 0xbb20
    int32_t v3 = function_128((v1 > -1 ? -v2 : v2) + 0x2dc6c00, (int32_t *)"0ms"); // 0xbb36
    *(int32_t *)0x4006b804 = v3;
    *(int32_t *)0x4006b800 = (int32_t)&g121;
    *(int32_t *)0x4006b820 = (int32_t)&g62;
    *(int32_t *)0x4006b81c = 0;
    *(int32_t *)0x4006b818 = 199;
    *(int32_t *)0x4006b810 = 0;
    *(int32_t *)0x40001000 = *(int32_t *)0x40001000 & -2;
    *(int32_t *)0x40001108 = 0x4006b80c;
    *(int32_t *)0x4000110c = 0x20000484;
    *(int32_t *)0x40001104 = 272;
    *(int32_t *)0x40001004 = 0;
    *(int32_t *)0x40001008 = 3855;
    *(int32_t *)0x40001100 = 0x61ff;
    *(int32_t *)0x4006b814 = (int32_t)&g26;
    *(int32_t *)0x40001000 = *(int32_t *)0x40001000 | 1;
    int32_t result = *(int32_t *)0x4006b800 | 1; // 0xbb9c
    *(int32_t *)0x4006b800 = result;
    return result;
}

// Address range: 0xbbc8 - 0xbe22
int32_t function_bbc8(void) {
    uint16_t v1 = *(int16_t *)0x2000035a; // 0xbbce
    int32_t v2 = v1; // 0xbbce
    int32_t v3 = *(int32_t *)((int32_t)&g2 + 0x40001100); // 0xbbd2
    int32_t v4 = v3 & 0xffffffff >> (int32_t)&g11; // 0xbbd6
    if (v4 == v2) {
        // 0xbc12
        return 0;
    }
    int32_t v5 = v4 + (int32_t)&g82 + 249;
    int32_t v6 = v2; // 0xbbe6
    int32_t v7; // 0xbbc8
    int32_t v8 = v7; // 0xbbe6
    int32_t v9; // 0xbbc8
    int32_t v10 = v9; // 0xbbe6
    int32_t v11; // 0xbbfa
    int32_t v12; // 0xbc02
    int32_t v13; // 0xbc04
    int32_t v14; // 0xbbc8
    uint32_t v15; // 0xbbee
    if (*(char *)(v2 + (int32_t)"\x84\x04") != -85) {
        v15 = (int32_t)v1 + 1;
        v11 = v15 - ((v15 >> (int32_t)&g24 >> (int32_t)&g16) + v15 & -1 << (int32_t)&g90);
        *(int16_t *)0x2000035a = (int16_t)v11;
        v12 = v11 % 0x10000;
        v13 = __asm_nop((int32_t *)0x2000035a, v11, 0x2000035a, v14);
        if (v4 == v12) {
            // 0xbc0a
            __asm_nop((int32_t *)v13, v11, 0x2000035a, v14);
            return 0;
        }
        // 0xbbe0
        v6 = v12;
        v8 = 0x2000035a;
        v10 = v11;
        while (*(char *)(v12 + (int32_t)"\x84\x04") != -85) {
            // 0xbbe0
            v15 = (int32_t)*(int16_t *)0x2000035a + 1;
            v11 = v15 - ((v15 >> (int32_t)&g24 >> (int32_t)&g16) + v15 & -1 << (int32_t)&g90);
            *(int16_t *)0x2000035a = (int16_t)v11;
            v12 = v11 % 0x10000;
            v13 = __asm_nop((int32_t *)0x2000035a, v11, 0x2000035a, v14);
            if (v4 == v12) {
                // 0xbc0a
                __asm_nop((int32_t *)v13, v11, 0x2000035a, v14);
                return 0;
            }
            // 0xbbe0
            v6 = v12;
            v8 = 0x2000035a;
            v10 = v11;
        }
    }
    int32_t v16 = v6;
    __asm_nop((int32_t *)171, v10, v8, v14);
    uint32_t v17 = ((v4 > v16 ? v4 : v5) - v16) % 0x10000;
    while (v17 >= (int32_t)&g90) {
        int32_t v18 = v16 + 1; // 0xbc36
        char v19 = *(char *)(v16 + (int32_t)"\x84\x04" + 1 - ((v18 >> (int32_t)&g24 >> (int32_t)&g16) + v18 & -1 << (int32_t)&g90)); // 0xbc46
        if (v19 == -51) {
            int32_t v20 = v16 + 2; // 0xbc68
            uint32_t v21 = v20 - ((v20 >> (int32_t)&g24 >> (int32_t)&g16) + v20 & -1 << (int32_t)&g90); // 0xbc74
            unsigned char v22 = *(char *)((v21 + 1) % 256 + (int32_t)"\x84\x04"); // 0xbc88
            unsigned char v23 = *(char *)(v21 % 0x10000 + (int32_t)"\x84\x04"); // 0xbc8e
            int32_t v24 = (int32_t)v22 << (int32_t)&g90 | (int32_t)v23; // 0xbc90
            uint32_t v25 = v24 + 8; // 0xbc94
            if (v25 != 256 && v25 >= 256) {
                // 0xbc9e
                *(int16_t *)0x2000035a = (int16_t)v4;
                // 0xbc12
                return 0;
            }
            // 0xbca6
            if (v17 < v24 + (int32_t)&g90) {
                // 0xbc12
                return 0;
            }
            uint32_t v26 = (v21 + 2) % 256; // 0xbcc2
            int32_t v27 = v26 + 2 + v24; // 0xbcc6
            uint32_t v28 = v27 - ((v27 >> (int32_t)&g24 >> (int32_t)&g16) + v27 & -1 << (int32_t)&g90); // 0xbcd2
            uint32_t v29 = v28 % 0x10000; // 0xbcd4
            if (*(char *)((int32_t)"\x84\x04" - (v28 & 0xff00) + v29) == -36) {
                // 0xbcec
                if (*(char *)((v28 + 1) % 256 + (int32_t)"\x84\x04") == -70) {
                    // 0xbd0a
                    function_178((int32_t *)0x20000584, (char *)(v26 + (int32_t)"\x84\x04"));
                    if (v29 < v26) {
                        // 0xbd0e
                        function_178((int32_t *)(0x20000684 - v26), "\x84\x04");
                    }
                    uint32_t v30 = (v28 + 2) % 256; // 0xbd4c
                    uint32_t v31 = (int32_t)*(int16_t *)0x2000035a; // 0xbd52
                    if (v30 < v31) {
                        // 0xbd5a
                        function_1aa((int32_t *)(v31 + (int32_t)"\x84\x04"), (int32_t *)(256 - v31), (int32_t)"\x84\x04", v31);
                        function_1aa((int32_t *)"\x84\x04", (int32_t *)v30, (int32_t)"\x84\x04", v31);
                    } else {
                        // 0xbd7a
                        function_1aa((int32_t *)(v31 + (int32_t)"\x84\x04"), (int32_t *)(v30 - v31), (int32_t)"\x84\x04", v31);
                    }
                    // 0xbd8e
                    *(int16_t *)0x2000035a = (int16_t)v30;
                    switch (*(int16_t *)0x20000584) {
                        case 1300: {
                            // 0xbda2
                            *"\\\x03" = 0;
                            // break -> 0xbdf2
                            break;
                        }
                        case 0x6902: {
                            // 0xbdb2
                            *"\\\x03" = 1;
                            // break -> 0xbdf2
                            break;
                        }
                    }
                    unsigned char v32 = *(char *)(v24 + 0x20000584); // 0xbdf4
                    unsigned char v33 = *(char *)(v24 + 0x20000585); // 0xbdfa
                    int32_t v34 = function_afa4(0x20000584, v24); // 0xbe06
                    int32_t result = v34 == ((int32_t)v33 << (int32_t)&g90 | (int32_t)v32); // 0xbe16
                    // 0xbc12
                    return result;
                }
                goto lab_0xbd02;
            } else {
                goto lab_0xbd02;
            }
        }
        uint32_t v35 = (int32_t)*(int16_t *)0x2000035a + 1; // 0xbc50
        int32_t v36 = v35 - ((v35 >> (int32_t)&g24 >> (int32_t)&g16) + v35 & -1 << (int32_t)&g90); // 0xbc5c
        int16_t v37 = v36; // 0xbc60
        *(int16_t *)0x2000035a = v37;
        int32_t v38 = v36 % 0x10000; // 0xbc64
        if (v38 == v4) {
            // break -> 0xbc12
            break;
        }
        int16_t v39 = v37; // 0xbbe6
        v6 = v38;
        v8 = 0x2000035a;
        v10 = v36;
        if (*(char *)(v38 + (int32_t)"\x84\x04") != -85) {
            v15 = (int32_t)v39 + 1;
            v11 = v15 - ((v15 >> (int32_t)&g24 >> (int32_t)&g16) + v15 & -1 << (int32_t)&g90);
            *(int16_t *)0x2000035a = (int16_t)v11;
            v12 = v11 % 0x10000;
            v13 = __asm_nop((int32_t *)0x2000035a, v11, 0x2000035a, v14);
            if (v4 == v12) {
                // 0xbc0a
                __asm_nop((int32_t *)v13, v11, 0x2000035a, v14);
                return 0;
            }
            // 0xbbe0
            v6 = v12;
            v8 = 0x2000035a;
            v10 = v11;
            while (*(char *)(v12 + (int32_t)"\x84\x04") != -85) {
                // 0xbbe0
                v15 = (int32_t)*(int16_t *)0x2000035a + 1;
                v11 = v15 - ((v15 >> (int32_t)&g24 >> (int32_t)&g16) + v15 & -1 << (int32_t)&g90);
                *(int16_t *)0x2000035a = (int16_t)v11;
                v12 = v11 % 0x10000;
                v13 = __asm_nop((int32_t *)0x2000035a, v11, 0x2000035a, v14);
                if (v4 == v12) {
                    // 0xbc0a
                    __asm_nop((int32_t *)v13, v11, 0x2000035a, v14);
                    return 0;
                }
                // 0xbbe0
                v6 = v12;
                v8 = 0x2000035a;
                v10 = v11;
            }
        }
        // 0xbc16
        v16 = v6;
        __asm_nop((int32_t *)171, v10, v8, v14);
        v17 = ((v4 > v16 ? v4 : v5) - v16) % 0x10000;
    }
  lab_0xbc12:
    // 0xbc12
    return 0;
  lab_0xbd02:
    // 0xbd02
    *(int16_t *)0x2000035a = (int16_t)v4;
    // 0xbc12
    return 0;
}

// Address range: 0xbe44 - 0xbe6a
int32_t function_be44(int32_t * a1, int32_t * a2) {
    uint32_t v1 = (int32_t)a2;
    int32_t v2 = (int32_t)a1;
    if (a2 == NULL) {
        // 0xbe68
        return 0;
    }
    int32_t result = 0; // 0xbe66
    int32_t v3 = (int32_t)*(char *)(result + v2); // 0xbe4c
    *(int32_t *)0x4006b808 = v3;
    int32_t v4 = __asm_nop((int32_t *)result, v1, v2, v3); // 0xbe52
    int32_t v5 = *(int32_t *)((int32_t)&g11 + 0x4006b800); // 0xbe56
    while ((v5 & 1 << (int32_t)&g121) != 0) {
        // continue -> 0xbe54
    }
    // 0xbe62
    result = v4 + (int32_t)&g1;
    while (result < v1) {
        // 0xbe4c
        v3 = (int32_t)*(char *)(result + v2);
        *(int32_t *)0x4006b808 = v3;
        v4 = __asm_nop((int32_t *)result, v1, v2, v3);
        v5 = *(int32_t *)((int32_t)&g11 + 0x4006b800);
        while ((v5 & 1 << (int32_t)&g121) != 0) {
            // continue -> 0xbe54
        }
        // 0xbe62
        result = v4 + (int32_t)&g1;
    }
    // 0xbe68
    return result;
}

// Address range: 0xbe70 - 0xbefc
int32_t function_be70(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4) {
    int32_t v1 = -85; // bp-24, 0xbe9c
    function_be44(&v1, (int32_t *)&g62);
    function_be44(a1, a2);
    v1 = -1;
    return function_be44(&v1, (int32_t *)&g62);
}

// Address range: 0xbf04 - 0xbf6a
int32_t function_bf04(char a1) {
    // 0xbf04
    function_bfe4(0x40060000, (int32_t *)&g106);
    function_d0ec((int32_t)&g82);
    int32_t result = function_bf98(0x40060000, (int32_t)&g106); // 0xbf1a
    if (&g90 <= NULL) {
        // 0xbf68
        return result;
    }
    int32_t v1 = a1; // 0xbf04
    if ((v1 & (int32_t)&g91) == 0) {
        // 0xbf34
        function_bf98(0x40060000, (int32_t)&g111);
    } else {
        // 0xbf2a
        function_bfe4(0x40060000, (int32_t *)&g111);
    }
    // 0xbf3c
    function_d100(1200);
    function_bfe4(0x40060000, (int32_t *)&g106);
    function_d100(1200);
    function_bf98(0x40060000, (int32_t)&g106);
    int32_t result2 = 1; // 0xbf60
    uint32_t v2 = result2 % 256; // 0xbf62
    v1 = v1 << (int32_t)&g17 >> (int32_t)&g16;
    while (v2 < (int32_t)&g90) {
        // 0xbf22
        if ((v1 & (int32_t)&g91) == 0) {
            // 0xbf34
            function_bf98(0x40060000, (int32_t)&g111);
        } else {
            // 0xbf2a
            function_bfe4(0x40060000, (int32_t *)&g111);
        }
        // 0xbf3c
        function_d100(1200);
        function_bfe4(0x40060000, (int32_t *)&g106);
        function_d100(1200);
        function_bf98(0x40060000, (int32_t)&g106);
        result2 = v2 + 1;
        v2 = result2 % 256;
        v1 = v1 << (int32_t)&g17 >> (int32_t)&g16;
    }
    // 0xbf68
    return result2;
}

// Address range: 0xbf70 - 0xbf8a
int32_t function_bf70(int32_t a1) {
    int32_t result = a1; // 0xbf74
    if (a1 == 0x40061000 == ((a1 || 2048) != 0x40060800)) {
        // 0xbf86
        int32_t v1; // 0xbf70
        result = __asm_nop((int32_t *)0x40061000, v1, 0x40061000, v1);
    }
    // 0xbf88
    return result;
}

// Address range: 0xbf98 - 0xbfb2
int32_t function_bf98(int32_t a1, uint32_t a2) {
    int32_t result = function_bf70(a1) & (-1 << a2) - 1; // 0xbfac
    *(int32_t *)a1 = result;
    return result;
}

// Address range: 0xbfb2 - 0xbfca
int32_t function_bfb2(int32_t a1, uint32_t a2) {
    uint32_t v1 = function_bf70(a1); // 0xbfbc
    return v1 >> a2 & 0xffffffff >> (int32_t)&g24;
}

// Address range: 0xbfca - 0xbfe4
int32_t function_bfca(int32_t a1, int32_t * a2) {
    int32_t result = function_bf70(a1) ^ 1 << (int32_t)a2; // 0xbfde
    *(int32_t *)a1 = result;
    return result;
}

// Address range: 0xbfe4 - 0xbffe
int32_t function_bfe4(int32_t a1, int32_t * a2) {
    int32_t result = function_bf70(a1) | 1 << (int32_t)a2; // 0xbff8
    *(int32_t *)a1 = result;
    return result;
}

// Address range: 0xc000 - 0xc00e
int32_t function_c000(int32_t * a1) {
    int32_t result = (int32_t)a1;
    *(int32_t *)-0x1fff1f00 = 1 << (result & 0xffffffff >> (int32_t)&g19);
    return result;
}

// Address range: 0xc014 - 0xc082
int32_t function_c014(uint32_t result, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    if (result < 0) {
        int32_t * v2 = (int32_t *)(4 * ((result & 0xffffffff >> (int32_t)&g20) - (int32_t)&g90 >> (int32_t)&g25) - 0x1fff12e4); // 0xc026
        int32_t v3 = *v2; // 0xc026
        uint32_t v4 = result << (int32_t)&g23 >> (int32_t)&g19; // 0xc02a
        *v2 = v3 & (-255 << v4) - 1 | v1 << (int32_t)&g23 >> (int32_t)&g16 << v4;
    } else {
        int32_t * v5 = (int32_t *)(4 * (result >> (int32_t)&g25) + ((int32_t)&g44 << (int32_t)&g90) - 0x1fff1f00); // 0xc05a
        int32_t v6 = *v5; // 0xc05a
        uint32_t v7 = result << (int32_t)&g23 >> (int32_t)&g19; // 0xc05e
        *v5 = v6 & (-255 << v7) - 1 | v1 << (int32_t)&g23 >> (int32_t)&g16 << v7;
    }
    // 0xc080
    return result;
}

// Address range: 0xc08c - 0xc09c
int32_t function_c08c(void) {
    // 0xc08c
    int32_t result; // 0xc08c
    return result;
}

// Address range: 0xc0a0 - 0xc0ac
int32_t function_c0a0(int32_t a1) {
    // 0xc0a0
    return function_af00(&g72, 0xbb20);
}

// Address range: 0xc0b0 - 0xc0bc
int32_t function_c0b0(void) {
    // 0xc0b0
    return function_af00((int32_t *)81, 0);
}

// Address range: 0xc0bc - 0xc0c8
int32_t function_c0bc(int32_t a1) {
    // 0xc0bc
    return function_af00(&g72, 0x3b20);
}

// Address range: 0xc0cc - 0xc0e8
int32_t function_c0cc(int32_t a1, int32_t a2) {
    // 0xc0cc
    int32_t v1; // 0xc0cc
    function_c73e(a1, a2, v1, a1);
    function_af00((int32_t *)&g82, 1135);
    return function_c110((int32_t)&g130);
}

// Address range: 0xc0e8 - 0xc0f2
int32_t function_c0e8(void) {
    // 0xc0e8
    function_af00((int32_t *)82, 0x828f);
    return function_c110((int32_t)&g130);
}

// Address range: 0xc0f2 - 0xc0fc
int32_t function_c0f2(void) {
    // 0xc0f2
    function_af00((int32_t *)82, 0xa28f);
    return function_c110((int32_t)&g130);
}

// Address range: 0xc0fc - 0xc106
int32_t function_c0fc(void) {
    // 0xc0fc
    function_af00((int32_t *)82, 0xc28f);
    return function_c110((int32_t)&g130);
}

// Address range: 0xc106 - 0xc110
int32_t function_c106(void) {
    int32_t v1 = function_af00((int32_t *)82, (int32_t)&g125); // 0xc10a
    int32_t v2; // 0xc106
    return __asm_nop((int32_t *)v1, (int32_t)&g125, v2, v2);
}

// Address range: 0xc110 - 0xc114
int32_t function_c110(int32_t a1) {
    // 0xc110
    int32_t v1; // 0xc110
    return __asm_nop((int32_t *)v1, v1, v1, v1);
}

// Address range: 0xc128 - 0xc134
int32_t function_c128(int32_t a1) {
    // 0xc128
    return function_af00(&g45, 0);
}

// Address range: 0xc134 - 0xc150
int32_t function_c134(void) {
    // 0xc134
    function_af00(&g54, 0x1f0f);
    function_af00(&g45, 0);
    return function_af00(&g45, 0xbff1);
}

// Address range: 0xc158 - 0xc210
int32_t function_c158(int32_t a1) {
    // 0xc158
    int32_t v1; // 0xc158
    int32_t v2; // 0xc158
    int32_t v3; // 0xc158
    int32_t v4; // 0xc158
    int32_t v5; // 0xc158
    switch (a1) {
        case 0: {
            // 0xc166
            function_af00((int32_t *)&g9, 958);
            function_af00((int32_t *)&g7, 891);
            function_af00((int32_t *)&g3, 635);
            function_af00((int32_t *)&g2, 122);
            function_af00((int32_t *)&g11, (int32_t)&g17);
            function_af00((int32_t *)73, 0x2a38);
            // 0xc20c
            return __asm_nop((int32_t *)function_af00((int32_t *)123, 0x8420), 0x8420, v4, v5);
        }
        case 1: {
            // 0xc1a2
            function_af00((int32_t *)&g9, 958);
            function_af00((int32_t *)&g7, 892);
            function_af00((int32_t *)&g3, 635);
            function_af00((int32_t *)&g2, 122);
            function_af00((int32_t *)&g11, (int32_t)&g16);
            function_af00((int32_t *)73, 0x2a38);
            function_af00((int32_t *)123, 0x318c);
            function_af00(&g88, 0x595e);
            int32_t v6 = function_af00((int32_t *)&g26, 0x8def); // 0xc1e8
            int32_t v7 = 0; // 0xc208
            v2 = 0x8def;
            v1 = v6;
            if (&g90 > NULL) {
                int32_t v8 = (v7 << (int32_t)&g21 >> (int32_t)&g2 | (int32_t)&g31 << (int32_t)&g90) + (int32_t)&g53; // 0xc1fc
                int32_t v9 = function_af00((int32_t *)6, v8); // 0xc200
                int32_t v10 = v7 + 1; // 0xc204
                v7 = v10;
                v3 = (int32_t)&g31 << (int32_t)&g90;
                v2 = v8;
                v1 = v9;
                while (v10 < (int32_t)&g90) {
                    // 0xc1f0
                    v8 = (v7 << (int32_t)&g21 >> (int32_t)&g2 | (int32_t)&g31 << (int32_t)&g90) + (int32_t)&g53;
                    v9 = function_af00((int32_t *)6, v8);
                    v10 = v7 + 1;
                    v7 = v10;
                    v3 = (int32_t)&g31 << (int32_t)&g90;
                    v2 = v8;
                    v1 = v9;
                }
            }
            // break -> 0xc20a
            break;
        }
        default: {
            // 0xc20c
            int32_t v11; // 0xc158
            return __asm_nop((int32_t *)a1, v11, v4, v5);
        }
    }
    // 0xc20c
    return __asm_nop((int32_t *)__asm_nop((int32_t *)v1, v2, v3, v5), v2, v3, v5);
}

// Address range: 0xc22c - 0xc250
int32_t function_c22c(void) {
    // 0xc22c
    function_af00(&g54, 0x1d0f);
    function_af00((int32_t *)82, 655);
    function_af00(&g45, 0);
    return function_af00(&g45, 0xc1fe);
}

// Address range: 0xc25c - 0xc266
int32_t function_c25c(int32_t result) {
    // 0xc25c
    *(int32_t *)result = result & ((int32_t)&g90 ^ -1);
    return result;
}

// Address range: 0xc268 - 0xc33e
int32_t function_c268(int32_t a1, int32_t * a2) {
    int32_t v1 = a1 - 0x400b8000; // 0xc272
    char v2; // 0xc268
    int32_t v3; // 0xc268
    int32_t v4; // 0xc268
    int32_t v5; // 0xc268
    if (v1 == 0) {
        int32_t v6 = *(int32_t *)((1 << (int32_t)&g23) + (int32_t)&g90); // 0xc286
        int32_t v7 = v6 | 1 << (int32_t)&g97; // 0xc28c
        *(int32_t *)((1 << (int32_t)&g97 << (int32_t)&g11) + (int32_t)&g90) = v7;
        v2 = 1 << (int32_t)&g97 << (int32_t)&g11;
        v3 = 1 << (int32_t)&g97 << (int32_t)&g11;
        v4 = v7;
    } else {
        // 0xc278
        v2 = 1 << (int32_t)&g102;
        v3 = 1 << (int32_t)&g102;
        v4 = v1 - (1 << (int32_t)&g102);
        if (v1 == 1 << (int32_t)&g102) {
            int32_t v8 = *(int32_t *)((1 << (int32_t)&g23) + (int32_t)&g90); // 0xc298
            int32_t v9 = v8 | 1 << (int32_t)&g102; // 0xc29e
            *(int32_t *)((1 << (int32_t)&g102 << (int32_t)&g9) + (int32_t)&g90) = v9;
            int32_t v10 = __asm_nop((int32_t *)v9, 1 << (int32_t)&g102 << (int32_t)&g9, v5, v5); // 0xc2a4
            v2 = 1 << (int32_t)&g102 << (int32_t)&g9;
            v3 = 1 << (int32_t)&g102 << (int32_t)&g9;
            v4 = v10;
        }
    }
    int32_t v11 = (int32_t)a2;
    __asm_nop((int32_t *)v4, v3, v5, v5);
    int32_t v12 = function_c25c(a1); // 0xc2aa
    unsigned char v13 = *(char *)(v11 + (int32_t)&g1); // 0xc2b8
    unsigned char v14 = *(char *)(v11 + (int32_t)&g25); // 0xc2ba
    unsigned char v15 = *(char *)(v11 + (int32_t)&g44); // 0xc2c0
    unsigned char v16 = *(char *)(v11 + (int32_t)&g62); // 0xc2cc
    unsigned char v17 = *(char *)(v11 + (int32_t)&g76); // 0xc2de
    unsigned char v18 = *(char *)(v11 + (int32_t)&g71); // 0xc2ec
    *(int32_t *)a1 = ((v12 & -248 | 64 * (int32_t)v2 | (int32_t)v13 | (int32_t)v14 << (int32_t)&g62 | 32 * (int32_t)v15 | (int32_t)v16 << (int32_t)&g82) & (1 << (int32_t)&g126 ^ -1) | (int32_t)v17 << (int32_t)&g126) & (2 * (1 << (int32_t)&g126) ^ -1) | (int32_t)v18 << (int32_t)&g2;
    unsigned char v19 = *(char *)(v11 + (int32_t)&g102); // 0xc2f6
    unsigned char v20 = *(char *)(v11 + (int32_t)&g97); // 0xc2fa
    unsigned char v21 = *(char *)(v11 + (int32_t)&g95); // 0xc300
    unsigned char v22 = *(char *)(v11 + (int32_t)&g90); // 0xc306
    unsigned char v23 = *(char *)(v11 + (int32_t)&g82); // 0xc30c
    int32_t v24 = 2 * (int32_t)v20 | (int32_t)v19 | 4 * (int32_t)v21 | (int32_t)v22 << (int32_t)&g44 | (int32_t)v23 << (int32_t)&g62; // 0xc310
    *(int32_t *)(a1 + (int32_t)&g2) = v24;
    if (v24 == 0) {
        // 0xc33c
        return 0;
    }
    int32_t v25; // 0xc268
    int32_t v26; // 0xc268
    if (v1 == 0) {
        int32_t v27 = function_c000((int32_t *)&g2); // 0xc32c
        v25 = 2 * (1 << (int32_t)&g126);
        v26 = v27;
    } else {
        // 0xc322
        v25 = 2 * (1 << (int32_t)&g126) >> 5;
        v26 = v1 - (2 * (1 << (int32_t)&g126) >> 5);
        if (v1 == 2 * (1 << (int32_t)&g126) >> 5) {
            int32_t v28 = function_c000((int32_t *)&g3); // 0xc334
            int32_t v29 = __asm_nop((int32_t *)v28, 2 * (1 << (int32_t)&g126) >> 5, v5, v5); // 0xc338
            v25 = 2 * (1 << (int32_t)&g126) >> 5;
            v26 = v29;
        }
    }
    // 0xc33c
    return __asm_nop((int32_t *)v26, v25, v5, v5);
}

// Address range: 0xc344 - 0xc360
int32_t function_c344(int32_t result, int32_t a2) {
    if (a2 == 0) {
        // 0xc348
        *(int32_t *)result = result & (1 << (uint32_t)(int32_t)&g106 ^ -1);
    } else {
        // 0xc354
        *(int32_t *)result = result | 1 << (uint32_t)(int32_t)&g106;
    }
    // 0xc35e
    return result;
}

// Address range: 0xc360 - 0xc36a
int32_t function_c360(int32_t result) {
    // 0xc360
    *(int32_t *)result = result | (int32_t)&g90;
    return result;
}

// Address range: 0xc36c - 0xc394
int32_t function_c36c(void) {
    int32_t result = *(int32_t *)((int32_t)&g2 + 0x40000800) & -4 | 1; // 0xc37a
    *(int32_t *)0x40000810 = result;
    *(int32_t *)((int32_t)&g25 << (int32_t)&g21) = (int32_t)&g25;
    int32_t v1 = *(int32_t *)(((int32_t)&g25 << (int32_t)&g21) + (int32_t)&g62); // 0xc38a
    *(int32_t *)(((int32_t)&g25 << (int32_t)&g21) + (int32_t)&g62) = v1 & -2;
    return result;
}

// Address range: 0xc399 - 0xc39a
int32_t function_c399(void) {
    // 0xc399
    int32_t result; // 0xc399
    return result;
}

// Address range: 0xc39a - 0xc5f2
int32_t function_c39a(int32_t a1) {
    // 0xc39a
    *(int32_t *)"(\x03" = 809;
    *",\x03" = 1;
    function_128(808, &g47);
    if (40 << (int32_t)&g23 >> (int32_t)&g23 == 0) {
        // 0xc3ea
        *"R\x03" = 1;
    }
    int16_t v1 = *(int16_t *)0x20000354; // 0xc3f2
    if (v1 != 0) {
        // 0xc3f8
        *(int16_t *)0x20000354 = v1 - 1;
    }
    // 0xc40a
    *"F\x03" = 69;
    *"E\x03" = 68;
    int16_t v2 = *(int16_t *)0x20000336; // 0xc540
    if (v2 != 0) {
        int16_t v3 = v2 - 1; // 0xc54a
        *(int16_t *)0x20000336 = v3;
        if (v3 == 0) {
            // 0xc558
            *"8\x03" = 1;
        }
    }
    int16_t v4 = *(int16_t *)0x20000342; // 0xc560
    if (v4 != 0) {
        int16_t v5 = v4 - 1; // 0xc56a
        *(int16_t *)0x20000342 = v5;
        if (v5 == 0) {
            // 0xc578
            *"D\x03" = 1;
        }
    }
    int16_t v6 = *(int16_t *)0x20000348; // 0xc580
    if (v6 != 0) {
        int16_t v7 = v6 - 1; // 0xc58a
        *(int16_t *)0x20000348 = v7;
        if (v7 == 0) {
            // 0xc598
            *"J\x03" = 1;
        }
    }
    int16_t v8 = *(int16_t *)0x2000034c; // 0xc5c0
    if (v8 != 0) {
        int16_t v9 = v8 - 1; // 0xc5ca
        *(int16_t *)0x2000034c = v9;
        if (v9 == 0) {
            // 0xc5d8
            *"N\x03" = 1;
        }
    }
    uint16_t v10 = *(int16_t *)0x20000350; // 0xc5e0
    int32_t result = 0; // 0xc5e4
    if (v10 != 0) {
        // 0xc5e6
        result = (int32_t)v10 - 1;
        *(int16_t *)0x20000350 = (int16_t)result;
    }
    // 0xc5f0
    return result;
}

// Address range: 0xc674 - 0xc6b6
int32_t function_c674(void) {
    int32_t v1 = *(int32_t *)((int32_t)&g1 << (uint32_t)(int32_t)&g23); // 0xc680
    return 8 * (v1 & (1 << (int32_t)&g102 ^ -1) & 384) | v1 & (1 << (int32_t)&g102 ^ -1) & -385 | (v1 & (int32_t)&g1 << (int32_t)&g23 >> (int32_t)&g9) >> (int32_t)&g102 << (int32_t)&g82;
}

// Address range: 0xc6b8 - 0xc6dc
int32_t function_c6b8(void) {
    // 0xc6b8
    int32_t v1; // 0xc6b8
    int32_t v2 = v1;
    function_7d4(function_7c8(0, v2), v2);
    function_c36c();
    *(int32_t *)0x2000031c = 0x2dc6c00;
    *(int32_t *)0x20000320 = (int32_t)&g45;
    return function_7c8(1, 0x20000320);
}

// Address range: 0xc6e8 - 0xc70c
int32_t function_c6e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // bp-16, 0xc6e8
    int32_t v2 = a3; // bp-8, 0xc6e8
    int32_t result = function_c8ec(a2, &v2, &v1, 0xd025); // 0xc6f4
    function_d024(0, &v1);
    return result;
}

// Address range: 0xc710 - 0xc73e
int32_t function_c710(uint32_t a1) {
    int32_t v1 = a1 >> (uint32_t)(int32_t)&g2; // 0xc712
    uint32_t v2 = v1 == 0 ? a1 : v1;
    int32_t v3 = v1 == 0 ? (int32_t)&g26 : (int32_t)&g2;
    int32_t v4 = v2 >> (int32_t)&g90; // 0xc71a
    uint32_t v5 = v4 == 0 ? v2 : v4;
    int32_t v6 = v4 == 0 ? v3 : v3 - (int32_t)&g90;
    int32_t v7 = v5 >> (int32_t)&g62; // 0xc722
    uint32_t v8 = v7 == 0 ? v5 : v7;
    int32_t v9 = v7 == 0 ? v6 : v6 - (int32_t)&g62;
    uint32_t v10 = v8 < 4 ? v8 : v8 / 4;
    int32_t v11 = v8 < 4 ? v9 : v9 - 2;
    if (v10 < 2) {
        // 0xc73a
        return v11 - v10;
    }
    // 0xc736
    return v11 - 2;
}

// Address range: 0xc73e - 0xc758
int32_t function_c73e(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0xc73e
    return result;
}

// Address range: 0xc758 - 0xc766
int32_t function_c758(void) {
    // 0xc758
    int32_t v1; // 0xc758
    if (v1 == 0) {
        // 0xc764
        int32_t result; // 0xc758
        return result;
    }
    int32_t v2; // 0xc758
    int32_t result2 = v2 + 4; // 0xc75a
    int32_t v3; // 0xc758
    int32_t v4 = v3 - (int32_t)&g62; // 0xc75c
    int32_t v5; // 0xc758
    *(int32_t *)v5 = *(int32_t *)v2;
    v5 += 4;
    v2 = result2;
    while (v4 != 0) {
        // 0xc75a
        result2 = v2 + 4;
        v4 -= (int32_t)&g62;
        *(int32_t *)v5 = *(int32_t *)v2;
        v5 += 4;
        v2 = result2;
    }
    // 0xc764
    return result2;
}

// Address range: 0xc766 - 0xc772
int32_t function_c766(uint32_t a1) {
    // 0xc766
    int32_t v1; // 0xc766
    uint32_t v2 = v1;
    bool v3 = false; // 0xc766
    bool v4; // 0xc766
    if (v4) {
        v3 = (a1 << (int32_t)&g26 - v2 | a1 >> v2) < 0;
    }
    if (!v4 && true) {
        __asm_mrsgt(a1);
    }
    int32_t result = a1; // 0xc76e
    if (v3) {
        result = function_143be();
    }
    // 0xc772
    return result;
}

// Address range: 0xc774 - 0xc776
int32_t function_c774(void) {
    // 0xc774
    int32_t result; // 0xc774
    return result;
}

// Address range: 0xc778 - 0xc8d0
int32_t function_c778(int32_t * a1, int32_t * a2, int32_t a3, uint32_t a4, int32_t a5, int32_t a6) {
    if ((a4 || a3) == 0) {
        int32_t result = (int32_t)a1;
        int32_t v1 = __asm_adr(292); // 0xc7b8
        *(int32_t *)(result + (int32_t)&g90) = 1;
        *a1 = v1;
        *(int32_t *)(result + (int32_t)&g106) = a6;
        *(int32_t *)(result + (int32_t)&g62) = a6 == 1 ? -1 - a5 : 0;
        return result;
    }
    int32_t v2 = a6; // 0xc792
    char * v3 = (char *)a5; // 0xc792
    int32_t v4 = 0x4d10 * (a4 >> (int32_t)&g11) - 0x133f2f0 >> (int32_t)&g2; // 0xc792
    while (true) {
        int32_t v5 = v2;
        int32_t v6 = (int32_t)v3; // 0xc798
        int32_t v7 = v5 == 1 ? -v6 : 1 - v6 + v4;
        int32_t v8 = v7 < 0 ? -v7 : v7;
        int32_t v9 = v8; // 0xc810
        int32_t v10 = 0; // 0xc810
        if (v8 != 0) {
            int32_t v11 = 0;
            int32_t v12 = 0;
            int32_t v13 = v11; // 0xc7ea
            if (v9 << (int32_t)&g24 != 0) {
                // 0xc7ec
                v13 = function_348(v11, 0x3ff00000, v12, 0x40140000);
            }
            int32_t v14 = v9 >> 1; // 0xc80c
            int32_t v15 = function_348(v12, 0x40140000, v12, 0x40140000); // 0xc810
            v9 = v14;
            v10 = v13;
            while (v14 != 0) {
                // 0xc7e8
                v11 = v13;
                v12 = v15;
                v13 = v11;
                if (v9 << (int32_t)&g24 != 0) {
                    // 0xc7ec
                    v13 = function_348(v11, 0x3ff00000, v12, 0x40140000);
                }
                // 0xc7fc
                v14 = v9 >> 1;
                v15 = function_348(v12, 0x40140000, v12, 0x40140000);
                v9 = v14;
                v10 = v13;
            }
        }
        int32_t v16 = (v8 << (int32_t)&g11) + 0x3ff00000; // 0xc7e0
        int32_t v17 = v10;
        int32_t v18; // 0xc778
        if (v7 < 0) {
            // 0xc820
            v18 = function_348(function_348(a3, a4, 0, v16), a4, v17, 0x3ff00000);
        } else {
            // 0xc82e
            v18 = function_418(function_418(a3, a4, 0, v16), a4, v17, 0x3ff00000);
        }
        // 0xc83a
        function_560(v18, a4, 0, 0x43f00000);
        int32_t v19 = (int32_t)&g2; // 0xc87c
        if (&g2 >= NULL) {
            int32_t v20 = function_588(-1, -1, (int32_t *)&g97, 0); // 0xc86c
            *(char *)(v19 + (int32_t)a2) = (char)((int32_t)&g97 + 48);
            int32_t v21 = v19 - (int32_t)&g1; // 0xc876
            v19 = v21;
            int32_t v22 = v20; // 0xc87c
            while (v21 >= 0) {
                // 0xc868
                v20 = function_588(v22, -1, (int32_t *)&g97, 0);
                *(char *)(v19 + (int32_t)a2) = (char)((int32_t)&g97 + 48);
                v21 = v19 - (int32_t)&g1;
                v19 = v21;
                v22 = v20;
            }
        }
        // 0xc87e
        v2 = v5 == 1 ? 0 : v5;
        v3 = v5 == 1 ? (char *)&g3 : v3;
        v4 += (int32_t)(v5 != 1);
    }
}

// Address range: 0xc8ec - 0xcfc6
int32_t function_c8ec(int32_t a1, int32_t * a2, int32_t * a3, int32_t a4) {
    char v1 = *(char *)a1; // 0xcd28
    int32_t result = 0; // 0xcd2c
    if (v1 == 0) {
      lab_0xcd30_2:
        // 0xcd30
        return result;
    }
    int32_t v2 = (int32_t)a3;
    char v3; // bp-97, 0xc8ec
    int32_t v4 = &v3;
    int32_t v5; // bp-104, 0xc8ec
    int32_t v6 = &v5;
    char v7 = v6;
    char v8 = v7 + (char)&g82 + 1;
    char v9 = v1; // 0xcd28
    int32_t v10 = a1; // 0xcd26
    int32_t v11 = 0;
    int16_t * v12 = (int16_t *)a2; // 0xc8ec
    char * v13; // 0xc8ec
    char v14; // 0xc8ec
    char v15; // 0xc984
    int32_t v16; // 0xc8ec
    int32_t v17; // 0xc8ec
    int32_t v18; // 0xc8ec
    int32_t v19; // 0xc8ec
    int32_t v20; // 0xc8ec
    int32_t v21; // 0xc8ec
    int32_t v22; // 0xc8ec
    int32_t v23; // 0xc8ec
    int32_t v24; // 0xc8ec
    int32_t v25; // 0xc8ec
    char v26; // 0xc8ec
    char v27; // 0xc8ec
    char * v28; // 0xc8ec
    char * v29; // 0xc8ec
    int16_t * v30; // 0xc8ec
    int16_t * v31; // 0xc8ec
    int32_t v32; // 0xc8ec
    int32_t v33; // 0xc8ec
    int32_t v34; // 0xc8ec
    while (true) {
      lab_0xcd2e:;
        int16_t * v35 = v12;
        v29 = v28;
        v27 = v26;
        v33 = v32;
        v19 = v11;
        int32_t v36 = v10; // 0xc8f8
        v31 = v35;
        v23 = v10;
        if ((int32_t)v9 == (int32_t)&g31) {
            int32_t v37 = v36;
            int32_t v38 = 0;
            int32_t v39 = v37 + (int32_t)&g1; // 0xc906
            char * v40 = (char *)v39;
            unsigned char v41 = *v40; // 0xc908
            int32_t v42 = v41;
            int32_t v43 = 1 << v42 - (int32_t)&g26; // 0xc90e
            int32_t v44 = v43 | v38; // 0xc912
            while ((v43 & 0x12809) != 0) {
                // 0xc906
                v37 = v39;
                v38 = v44;
                v39 = v37 + (int32_t)&g1;
                v40 = (char *)v39;
                v41 = *v40;
                v42 = v41;
                v43 = 1 << v42 - (int32_t)&g26;
                v44 = v43 | v38;
            }
            char * v45; // 0xc8ec
            char v46; // 0xc8ec
            int32_t v47; // 0xc8ec
            int32_t v48; // 0xc8ec
            int32_t v49; // 0xc8ec
            int16_t * v50; // 0xc8ec
            if (v42 == (int32_t)&g35) {
                int32_t v51 = *(int32_t *)v35; // 0xc93a
                int32_t v52 = v37 + 2 * (int32_t)&g1; // 0xc952
                char * v53 = (char *)v52;
                v45 = v53;
                v46 = *v53;
                v50 = (int16_t *)((int32_t)v35 + (int32_t)&g62);
                v49 = v51 < 0 ? -v51 : v51;
                v47 = (v51 < 0 ? v38 | 1 << (int32_t)&g111 : v38) | 2;
                v48 = v52;
            } else {
                uint32_t v54 = v42 - (int32_t)&g45; // 0xc920
                int32_t v55 = v42; // 0xc924
                int32_t v56 = v39; // 0xc924
                int32_t v57 = v38; // 0xc924
                v45 = v40;
                v46 = v41;
                v50 = v35;
                v49 = 0;
                v47 = v38;
                v48 = v39;
                if (v54 >= (int32_t)&g95 != v54 != (int32_t)&g95) {
                    int32_t v58 = v55 - (int32_t)&g45; // 0xc92e
                    int32_t v59 = v57 | 2; // 0xc930
                    int32_t v60 = v56 + (int32_t)&g1; // 0xc932
                    char * v61 = (char *)v60;
                    unsigned char v62 = *v61; // 0xc91c
                    int32_t v63 = v62; // 0xc91c
                    uint32_t v64 = v63 - (int32_t)&g45; // 0xc920
                    v56 = v60;
                    v57 = v59;
                    int32_t v65 = v58; // 0xc924
                    v45 = v61;
                    v46 = v62;
                    v50 = v35;
                    v49 = v58;
                    v47 = v59;
                    v48 = v60;
                    while (v64 >= (int32_t)&g95 != v64 != (int32_t)&g95) {
                        // 0xc926
                        v58 = v65 * (int32_t)&g97 - (int32_t)&g45 + v63;
                        v59 = v57 | 2;
                        v60 = v56 + (int32_t)&g1;
                        v61 = (char *)v60;
                        v62 = *v61;
                        v63 = v62;
                        v64 = v63 - (int32_t)&g45;
                        v56 = v60;
                        v57 = v59;
                        v65 = v58;
                        v45 = v61;
                        v46 = v62;
                        v50 = v35;
                        v49 = v58;
                        v47 = v59;
                        v48 = v60;
                    }
                }
            }
            int32_t v66 = v48;
            int32_t v67 = v47;
            v25 = v49;
            int16_t * v68 = v50;
            int32_t v69 = v46;
            int32_t v70 = v69; // 0xc958
            char * v71 = v45; // 0xc958
            char v72 = v46; // 0xc958
            int16_t * v73 = v68; // 0xc958
            int32_t v74 = v67; // 0xc958
            int32_t v75 = v66; // 0xc958
            int32_t v76 = 0; // 0xc958
            if (v69 == (int32_t)&g40) {
                int32_t v77 = v67 | (int32_t)&g62; // 0xc95c
                unsigned char v78 = *(char *)(v66 + (int32_t)&g1); // 0xc95e
                if ((int32_t)v78 == (int32_t)&g35) {
                    int32_t v79 = v66 + 2; // 0xc968
                    char * v80 = (char *)v79;
                    unsigned char v81 = *v80;
                    v70 = v81;
                    v71 = v80;
                    v72 = v81;
                    v73 = (int16_t *)((int32_t)v68 + (int32_t)&g62);
                    v74 = v77;
                    v75 = v79;
                    v76 = *(int32_t *)v68;
                } else {
                    int32_t v82 = v66 + 1;
                    char * v83 = (char *)v82;
                    unsigned char v84 = *v83; // 0xc97a
                    int32_t v85 = v84;
                    uint32_t v86 = v85 - (int32_t)&g45; // 0xc97e
                    int32_t v87 = v85; // 0xc982
                    int32_t v88 = v82; // 0xc982
                    v70 = v85;
                    v71 = v83;
                    v72 = v84;
                    v73 = v68;
                    v74 = v77;
                    v75 = v82;
                    v76 = 0;
                    if (v86 == (int32_t)&g95 || v86 < (int32_t)&g95) {
                        int32_t v89 = v87 - (int32_t)&g45; // 0xc976
                        int32_t v90 = v88 + 1;
                        char * v91 = (char *)v90;
                        unsigned char v92 = *v91; // 0xc97a
                        int32_t v93 = v92;
                        uint32_t v94 = v93 - (int32_t)&g45; // 0xc97e
                        v88 = v90;
                        int32_t v95 = v89; // 0xc982
                        v70 = v93;
                        v71 = v91;
                        v72 = v92;
                        v73 = v68;
                        v74 = v77;
                        v75 = v90;
                        v76 = v89;
                        while (v94 == (int32_t)&g95 || v94 < (int32_t)&g95) {
                            // 0xc970
                            v89 = v95 * (int32_t)&g97 - (int32_t)&g45 + v93;
                            v90 = v88 + 1;
                            v91 = (char *)v90;
                            v92 = *v91;
                            v93 = v92;
                            v94 = v93 - (int32_t)&g45;
                            v88 = v90;
                            v95 = v89;
                            v70 = v93;
                            v71 = v91;
                            v72 = v92;
                            v73 = v68;
                            v74 = v77;
                            v75 = v90;
                            v76 = v89;
                        }
                    }
                }
            }
            // 0xc984
            v24 = v76;
            v20 = v75;
            v16 = v74;
            v30 = v73;
            v15 = v72;
            int32_t v96 = v70;
            v34 = 1 << (int32_t)&g11;
            if (v96 == (int32_t)&g81) {
                goto lab_0xc9b6;
            } else {
                char * v97 = v71;
                if (v96 > (int32_t)(bool)&g81) {
                    // 0xc99a
                    v17 = v16;
                    v21 = v20;
                    v13 = v97;
                    v14 = v15;
                    v18 = v16;
                    v22 = v20;
                    if (v15 == 122 || v96 == (int32_t)&g84) {
                        goto lab_0xc9c6;
                    } else {
                        goto lab_0xc9c8;
                    }
                } else {
                    // 0xc98c
                    v17 = v16;
                    v21 = v20;
                    if (v96 == (int32_t)&g70) {
                        goto lab_0xc9c6;
                    } else {
                        // 0xc990
                        v34 = (int32_t)&g44 << (int32_t)&g11;
                        if (v96 == (int32_t)&g79) {
                            goto lab_0xc9b6;
                        } else {
                            // 0xc994
                            v13 = v97;
                            v14 = v15;
                            v18 = v16;
                            v22 = v20;
                            if (v15 == 106) {
                                // 0xc9a4
                                v17 = v16 | 1 << (int32_t)&g12;
                                v21 = v20;
                                goto lab_0xc9c6;
                            } else {
                                goto lab_0xc9c8;
                            }
                        }
                    }
                }
            }
        } else {
            goto lab_0xca1e;
        }
    }
  lab_0xcd30_2:
    // 0xcd30
    return result;
  lab_0xca1e:
    // 0xca1e
    v12 = v31;
    char * v98 = v29; // 0xca26
    char v99 = v27; // 0xca26
    int32_t v100 = v33; // 0xca26
    int32_t v101 = v19 + 1; // 0xca26
    int32_t v102 = v23; // 0xca26
    goto lab_0xcd26;
  lab_0xc9b6:;
    int32_t v297 = v34 | v16; // 0xc9b6
    v17 = v297;
    v21 = v20;
    if (v15 == *(char *)(v20 + (int32_t)&g1)) {
        // 0xc9be
        v17 = v297 + (1 << (int32_t)&g11);
        v21 = v20 + 1;
    }
    goto lab_0xc9c6;
  lab_0xcd26:
    // 0xcd26
    v11 = v101;
    v10 = v102 + (int32_t)&g1;
    v9 = *(char *)v10;
    v32 = v100;
    v26 = v99;
    v28 = v98;
    result = v11;
    if (v9 == 0) {
        // break -> 0xcd30
        goto lab_0xcd30_2;
    }
    goto lab_0xcd2e;
  lab_0xc9c6:;
    int32_t v103 = v21 + 1; // 0xc9c6
    char * v104 = (char *)v103;
    v13 = v104;
    v14 = *v104;
    v18 = v17;
    v22 = v103;
    goto lab_0xc9c8;
  lab_0xc9c8:;
    int32_t v105 = v22;
    int32_t v106 = v18;
    unsigned char v107 = v14; // 0xc9c8
    char * v108 = v13;
    int32_t v109 = v107; // 0xc9c8
    int32_t v110 = v109; // bp-60, 0xc9ca
    int32_t v111; // 0xc8ec
    int32_t v112; // 0xc8ec
    int32_t v113; // 0xc8ec
    char v114; // bp-120, 0xc8ec
    char * v115; // 0xc8ec
    int32_t v116; // 0xc8ec
    char * v117; // 0xc8ec
    if (v107 == 102) {
        goto lab_0xcd36;
    } else {
        if (v107 < 102) {
            // 0xc9d2
            v111 = (int32_t)&g2;
            if (v109 == (int32_t)&g74) {
                goto lab_0xcb8a;
            } else {
                if (v109 > (int32_t)&g74) {
                    if (v107 == 99) {
                        char v118 = *(char *)v30; // 0xca60
                        v114 = v118;
                        v117 = &v114;
                        v116 = 1;
                        goto lab_0xca80;
                    } else {
                        if (v109 == (int32_t)&g78) {
                            goto lab_0xcb00;
                        } else {
                            // 0xc9f4
                            v31 = v30;
                            v23 = v105;
                            if (v107 == 101) {
                                goto lab_0xcd36;
                            } else {
                                goto lab_0xca1e;
                            }
                        }
                    }
                } else {
                    // 0xc9d8
                    result = v19;
                    switch (v107) {
                        case 0: {
                            goto lab_0xcd30_2;
                        }
                        case 69: {
                            goto lab_0xcd36;
                        }
                        case 70: {
                            goto lab_0xcd36;
                        }
                        default: {
                            // 0xc9e4
                            v31 = v30;
                            v23 = v105;
                            if (v109 == (int32_t)&g68) {
                                goto lab_0xcd36;
                            } else {
                                goto lab_0xca1e;
                            }
                        }
                    }
                }
            }
        } else {
            if (v109 == (int32_t)&g83) {
                // 0xcb78
                v115 = (char *)&g2;
                v112 = v106 | (int32_t)&g62;
                v113 = (int32_t)&g90;
                goto lab_0xcb90;
            } else {
                if (v109 > (int32_t)&g83) {
                    // 0xca12
                    v111 = (int32_t)&g97;
                    switch (v107) {
                        case 115: {
                            // 0xca74
                            v117 = (char *)*(int32_t *)v30;
                            v116 = -1;
                            goto lab_0xca80;
                        }
                        case 117: {
                            goto lab_0xcb8a;
                        }
                        default: {
                            // 0xca1a
                            v31 = v30;
                            v23 = v105;
                            v111 = (int32_t)&g2;
                            if (v109 == (int32_t)&g87) {
                                goto lab_0xcb8a;
                            } else {
                                goto lab_0xca1e;
                            }
                        }
                    }
                } else {
                    // 0xca00
                    v31 = v30;
                    v23 = v105;
                    v111 = (int32_t)&g90;
                    switch (v107) {
                        case 103: {
                            goto lab_0xcd36;
                        }
                        case 105: {
                            goto lab_0xcb00;
                        }
                        case 110: {
                            int32_t v119 = v106 << (int32_t)&g95 >> (int32_t)&g21; // 0xca2a
                            int32_t v120; // 0xc8ec
                            if (v119 == 2) {
                                int32_t v121 = *(int32_t *)v30; // 0xca48
                                *(int32_t *)v121 = v19;
                                *(int32_t *)(v121 + (int32_t)&g62) = v19 >> (int32_t)&g24;
                                v120 = (int32_t)v30;
                            } else {
                                if (v119 == (int32_t)&g44) {
                                    // 0xca50
                                    *(int16_t *)*(int32_t *)v30 = (int16_t)v19;
                                    v120 = (int32_t)v30;
                                } else {
                                    int32_t v122 = (int32_t)v30; // 0xca36
                                    int32_t v123 = *(int32_t *)v30; // 0xca38
                                    if (v119 == (int32_t)&g62) {
                                        // 0xca58
                                        *(char *)v123 = (char)v19;
                                        v120 = v122;
                                    } else {
                                        // 0xca3c
                                        *(int32_t *)v123 = v19;
                                        v120 = v122;
                                    }
                                }
                            }
                            // 0xca3e
                            v12 = (int16_t *)(v120 + (int32_t)&g62);
                            v98 = v29;
                            v99 = v27;
                            v100 = v33;
                            v101 = v19;
                            v102 = v105;
                            goto lab_0xcd26;
                        }
                        case 111: {
                            goto lab_0xcb8a;
                        }
                        default: {
                            goto lab_0xca1e;
                        }
                    }
                }
            }
        }
    }
  lab_0xcd36:;
    int32_t v124 = (int32_t)v30 + (int32_t)&g82 & -1 << (int32_t)&g44; // 0xcd42
    int32_t v125 = *(int32_t *)(v124 + (int32_t)&g62); // 0xcd44
    int32_t v126 = *(int32_t *)v124; // 0xcd46
    int32_t v127; // 0xc8ec
    if ((v125 & -1 << (int32_t)&g24) == 0) {
        if (v106 << (int32_t)&g11 < 0) {
            // 0xcd5c
            v127 = __asm_adr(620);
        } else {
            // 0xcd60
            v127 = __asm_adr(616);
        }
    } else {
        // 0xcd54
        v127 = __asm_adr(624);
    }
    int32_t v128 = v106 << (int32_t)&g21 < 0 ? v24 : 6;
    int32_t v129 = v127;
    float32_t v130 = fabsf((float32_t)v125);
    int32_t v131 = v110; // 0xcd6c
    char v132; // 0xc8ec
    char * v133; // 0xc8ec
    if (v131 == 101) {
        goto lab_0xcd90;
    } else {
        if (v131 > 101) {
            // 0xcd86
            v133 = v29;
            v132 = v27;
            switch (v131) {
                case 102: {
                    goto lab_0xcdbc;
                }
                case 103: {
                    goto lab_0xce0a;
                }
                default: {
                    goto lab_0xce92;
                }
            }
        } else {
            switch (v131) {
                case 69: {
                    goto lab_0xcd90;
                }
                case 70: {
                    goto lab_0xcdbc;
                }
                default: {
                    // 0xcd80
                    v133 = v29;
                    v132 = v27;
                    if (v131 == (int32_t)&g68) {
                        goto lab_0xce0a;
                    } else {
                        goto lab_0xce92;
                    }
                }
            }
        }
    }
  lab_0xcd90:;
    int32_t v134 = v128 + 1;
    int32_t v135 = v128 < (int32_t)&g3 ? v134 : (int32_t)&g3;
    int32_t v136; // bp-96, 0xc8ec
    function_c778(&v110, &v136, v126, (int32_t)v130, v135, 0);
    char * v137 = (char *)v134; // 0xcdba
    goto lab_0xce5e;
  lab_0xce5e:;
    char v138 = 1; // 0xce62
    char * v139 = v137; // 0xce62
    char v140 = v33; // 0xce62
    goto lab_0xce90;
  lab_0xcb8a:
    // 0xcb8a
    v115 = (char *)v111;
    v112 = v106;
    v113 = v24;
    goto lab_0xcb90;
  lab_0xce90:
    // 0xce90
    v114 = v138;
    v133 = v139;
    v132 = v140;
    goto lab_0xce92;
  lab_0xcdbc:
    // 0xcdbc
    function_c778(&v110, &v136, v126, (int32_t)v130, v128, 1);
    int32_t v291 = v128 + 1;
    int32_t v292; // 0xc8ec
    int32_t v293 = v292 == 0 ? v291 + v33 : v292;
    int32_t v294 = v128 - v293 < 0 ? v293 : v291;
    v114 = v294 - v128;
    v133 = (char *)v294;
    v132 = 1 << (int32_t)&g24;
    goto lab_0xce92;
  lab_0xce0a:;
    int32_t v184 = v128 > 1 ? v128 : 1;
    int32_t v295 = v184 < (int32_t)&g3 ? v184 : (int32_t)&g3;
    function_c778(&v110, &v136, v126, (int32_t)v130, v295, 0);
    char * v296 = (char *)v184; // 0xce36
    char * v179 = v296; // 0xce3a
    int32_t v252; // 0xc8ec
    char * v251; // 0xc8ec
    int32_t v256; // 0xce2c
    if (v106 << (int32_t)&g20 < 0) {
        goto lab_0xce56;
    } else {
        // 0xce3c
        v256 = v110;
        v251 = v296;
        v252 = v184;
        if (v292 < v184) {
            goto lab_0xce46;
        } else {
            goto lab_0xce48;
        }
    }
  lab_0xce92:;
    char v141 = v132;
    char * v142 = v133;
    if (v106 << (int32_t)&g20 >= 0) {
        // 0xce96
        if ((int32_t)v114 >= (int32_t)v142) {
            // 0xce9e
            v114 = -1;
        }
    }
    // 0xcea4
    v3 = 0;
    int32_t v143 = v33; // 0xceb6
    int32_t v144 = v4; // 0xceb6
    if ((int32_t)v141 != 1 << (int32_t)&g24) {
        // 0xceb8
        v110 = 1;
        char v145 = v141 < 0 ? -v141 : v141; // 0xcedc
        int32_t v146 = function_128((int32_t)v145, (int32_t *)&g97); // 0xced4
        int32_t v147 = v4 - (int32_t)&g1; // 0xceda
        v145 = v146;
        *(char *)v147 = (char)((int32_t)&g97 + 48);
        int32_t v148 = v110; // 0xcee0
        v110 = v148 - 1;
        int32_t v149 = v147; // 0xcee8
        while (v145 == 0 != v148 < 1) {
            // 0xced0
            v146 = function_128((int32_t)v145, (int32_t *)&g97);
            v147 = v149 - (int32_t)&g1;
            v145 = v146;
            *(char *)v147 = (char)((int32_t)&g97 + 48);
            v148 = v110;
            v110 = v148 - 1;
            v149 = v147;
        }
        int32_t v150 = v141 < 0 ? (int32_t)&g37 : (int32_t)&g36;
        *(char *)(v147 - (int32_t)&g1) = (char)v150;
        int32_t v151 = v147 - (int32_t)&g25; // 0xcefe
        *(char *)v151 = (*v108 & (char)&g26) + 69;
        v143 = v150;
        v144 = v151;
    }
    char * v152 = (char *)v129; // 0xcd70
    int32_t v153 = *v152 != 0;
    int32_t v154 = (int32_t)v142;
    int32_t v155 = v25 + -1 - (v153 + v154 + ((int32_t)v114 >> (int32_t)&g24) + (int32_t)((char)(v6 - v144) + (char)&g82)); // 0xcf26
    int32_t v156 = function_cff8(v155, v106, v2, a4);
    int32_t v157 = v153; // 0xcf2c
    if (v106 << (int32_t)&g126 >= 0) {
        // 0xcf3c
        v157 = *v152 != 0;
    }
    int32_t v158 = v156 + v19 + v157;
    char * v159 = (char *)(v154 - 1); // 0xcf9e
    int32_t v160 = v158; // 0xcfa2
    char * v161 = v159; // 0xcfa2
    if (v142 > NULL) {
        char * v162 = v159;
        int32_t v163 = (int32_t)v114 - 1; // 0xcf88
        char v164 = v163; // 0xcf8a
        int32_t v165 = (v163 == 0 ? 2 : 1) + v158;
        char * v166 = (char *)((int32_t)v162 - 1); // 0xcf9e
        int32_t v167 = v165; // 0xcfa2
        while (v162 > NULL) {
            // 0xcf60
            v162 = v166;
            v163 = (int32_t)v164 - 1;
            v164 = v163;
            v165 = (v163 == 0 ? 2 : 1) + v167;
            v166 = (char *)((int32_t)v162 - 1);
            v167 = v165;
        }
        // 0xcf9a
        v114 = v164;
        v160 = v165;
        v161 = v166;
    }
    char v168 = v144;
    char v169 = -1 - (char)&g82 - v7 + v168;
    char v170 = v169 > -1 ? v169 : -1;
    int16_t * v171 = (int16_t *)(v124 + (int32_t)&g90); // 0xc8ec
    char * v172 = v161; // 0xc8ec
    char v173 = -2 - v170; // 0xc8ec
    int32_t v174 = v143; // 0xc8ec
    int32_t v175 = v155; // 0xc8ec
    int32_t v176 = v106; // 0xc8ec
    int32_t v177 = v160 + (int32_t)(v8 - v168 + v170); // 0xc8ec
    goto lab_0xcd20;
  lab_0xcb90:;
    int32_t v265 = v113;
    int32_t v264 = v112;
    char * v262 = v115;
    int32_t v283 = v264 << (int32_t)&g95 >> (int32_t)&g21; // 0xcb92
    int32_t v284 = (int32_t)v30;
    int32_t v285; // 0xc8ec
    int32_t v286; // 0xc8ec
    int32_t v287; // 0xc8ec
    if (v283 == 2) {
        int32_t v288 = v284 + (int32_t)&g82 & -1 << (int32_t)&g44; // 0xcbae
        v287 = v288 + (int32_t)&g90;
        v286 = *(int32_t *)v288;
        v285 = *(int32_t *)(v288 + (int32_t)&g62);
    } else {
        uint32_t v289 = *(int32_t *)v30; // 0xcb9a
        uint32_t v290 = v283 == (int32_t)&g44 ? v289 % 0x10000 : v289;
        v287 = v284 + (int32_t)&g62;
        v286 = v283 == (int32_t)&g62 ? v290 % 256 : v290;
        v285 = 0;
    }
    int32_t v266 = v285;
    int32_t v263 = v286;
    int16_t * v261 = (int16_t *)v287;
    v114 = 0;
    int32_t v200 = v109; // 0xcbc6
    int16_t * v198 = v261; // 0xcbc6
    char * v196 = v262; // 0xcbc6
    char v194 = v27; // 0xcbc6
    int32_t v192 = v263; // 0xcbc6
    int32_t v190 = v264; // 0xcbc6
    int32_t v211 = v265; // 0xcbc6
    int32_t v188 = v266; // 0xcbc6
    char v257; // 0xc8ec
    char v259; // 0xc8ec
    if (v264 << (int32_t)&g20 < 0) {
        // 0xcbc8
        v259 = &g63;
        v257 = 1;
        if (v109 == (int32_t)&g83) {
            goto lab_0xcbf8;
        } else {
            // 0xcbce
            v259 = &g45;
            v257 = 2;
            if (v262 != (char *)&g2 || (v266 || v263) == 0) {
                goto lab_0xcbfa;
            } else {
                goto lab_0xcbf8;
            }
        }
    } else {
        goto lab_0xcc1c;
    }
  lab_0xcd20:
    // 0xcd20
    v12 = v171;
    v98 = v172;
    v99 = v173;
    v100 = v174;
    v101 = function_cfd8(v175, v176, v2, a4) + v177;
    v102 = v105;
    goto lab_0xcd26;
  lab_0xce56:;
    char * v178 = v179;
    v137 = v178;
    int32_t v180; // 0xc8ec
    char * v181; // 0xc8ec
    char * v182; // 0xc8ec
    char * v183; // 0xc8ec
    if (v33 < v184) {
        int32_t v185 = v33 + (int32_t)&g62; // 0xce5a
        v137 = v178;
        if (v185 < 0 == ((v185 ^ v33) & (v185 ^ (int32_t)&g62)) < 0) {
            if (v33 > 0) {
                int32_t v186 = v33 + 1; // 0xce7c
                v183 = NULL;
                v180 = v186;
                v182 = NULL;
                v181 = v178;
                if (v186 > (int32_t)v178) {
                    goto lab_0xce82;
                } else {
                    goto lab_0xce84;
                }
            } else {
                // 0xce6e
                v183 = (char *)v33;
                v180 = (int32_t)v178 - v33;
                goto lab_0xce82;
            }
        } else {
            goto lab_0xce5e;
        }
    } else {
        goto lab_0xce5e;
    }
  lab_0xcc1c:;
    int32_t v187 = v188;
    int32_t v189 = v190;
    int32_t v191 = v192;
    char v193 = v194;
    char * v195 = v196;
    int16_t * v197 = v198;
    int32_t v199; // 0xc8ec
    if (v200 == (int32_t)&g74) {
        // 0xcc2c
        v199 = __asm_adr(220);
    } else {
        // 0xcc22
        v199 = __asm_adr(212);
    }
    // 0xcc24
    int16_t * v201; // bp-76, 0xc8ec
    v201 = (int16_t *)&v201;
    int16_t * v202 = (int16_t *)&v201; // 0xcc4c
    if ((v187 || v191) != 0) {
        char * v203 = (char *)(v199 + (int32_t)v195);
        int32_t v204 = v191; // 0xcc36
        v204 = function_588(v204, v187, (int32_t *)v195, 0);
        int32_t v205 = (int32_t)v201 - (int32_t)&g1; // 0xcc42
        v201 = (int16_t *)v205;
        *(char *)v205 = *v203;
        while ((v204 || v187) != 0) {
            // 0xcc30
            v204 = function_588(v204, v187, (int32_t *)v195, 0);
            v205 = (int32_t)v201 - (int32_t)&g1;
            v201 = (int16_t *)v205;
            *(char *)v205 = *v203;
        }
        // 0xcc48
        v202 = v201;
    }
    // 0xcc4e
    int32_t v206; // bp-108, 0xc8ec
    int32_t v207 = (int32_t)&v206 - (int32_t)v202; // 0xcc52
    int32_t v208 = v207 + (int32_t)&g26; // 0xcc54
    int32_t v209 = v189 << (int32_t)&g21 < 0 ? v189 & (1 << (int32_t)&g2 ^ -1) : v189;
    int32_t v210 = v189 << (int32_t)&g21 < 0 ? v211 : 1;
    int32_t v212 = v210 > v208 ? v210 - v208 : 0;
    int32_t v213 = v25 - (int32_t)&g26 - (int32_t)v114 - v207 - v212; // 0xcc7e
    char v214 = v114; // 0xcc84
    int32_t v215 = v19; // 0xcc84
    if (v209 << (int32_t)&g126 >= 0) {
        // 0xcc86
        v214 = v114;
        v215 = function_cff8(v213, v209, v2, a4) + v19;
    }
    int32_t v216 = v215;
    char v217 = v214; // 0xcca6
    int32_t v218 = v216; // 0xccaa
    if (v217 > 0) {
        int32_t v219 = 0; // 0xcca4
        int32_t v220 = v216; // 0xcca2
        v220++;
        v219 += (int32_t)&g1;
        v218 = v220;
        while (v219 < (int32_t)v217) {
            // 0xcc98
            v220++;
            v219 += (int32_t)&g1;
            v218 = v220;
        }
    }
    int32_t v221 = v218;
    int32_t v222 = v221; // 0xccae
    if (v209 << (int32_t)&g126 < 0) {
        // 0xccb0
        v222 = function_cff8(v213, v209, v2, a4) + v221;
    }
    int32_t v223 = v212 + 1 + v222 + -1 - (v212 < 0 ? v212 : 0);
    char * v224 = (char *)(v207 + (int32_t)&g26 - 1); // 0xccec
    v171 = v197;
    v172 = v224;
    v173 = v193;
    v174 = v33;
    v175 = v213;
    v176 = v209;
    v177 = v223;
    if (v208 > 0) {
        char * v225 = v224;
        int16_t * v226 = (int16_t *)((int32_t)v201 + (int32_t)&g1); // 0xccde
        int32_t v227 = v223 + 1; // 0xcce6
        char * v228 = (char *)((int32_t)v225 - 1); // 0xccec
        int16_t * v229 = v226; // 0xccf0
        int32_t v230 = v227; // 0xccf0
        while (v225 > NULL) {
            // 0xccd6
            v225 = v228;
            v226 = (int16_t *)((int32_t)v229 + (int32_t)&g1);
            v227 = v230 + 1;
            v228 = (char *)((int32_t)v225 - 1);
            v229 = v226;
            v230 = v227;
        }
        // 0xcce8
        v201 = v226;
        v171 = v197;
        v172 = v228;
        v173 = v193;
        v174 = v33;
        v175 = v213;
        v176 = v209;
        v177 = v227;
    }
    goto lab_0xcd20;
  lab_0xcb00:;
    int32_t v231 = v106 << (int32_t)&g95 >> (int32_t)&g21; // 0xcb0a
    int32_t v232 = (int32_t)v30;
    int32_t v233; // 0xc8ec
    int32_t v234; // 0xc8ec
    int16_t * v235; // 0xc8ec
    if (v231 == 2) {
        int32_t v236 = v232 + (int32_t)&g82 & -1 << (int32_t)&g44; // 0xcb26
        v235 = (int16_t *)(v236 + (int32_t)&g90);
        v234 = *(int32_t *)v236;
        v233 = *(int32_t *)(v236 + (int32_t)&g62);
    } else {
        int32_t v237 = *(int32_t *)v30; // 0xcb12
        int32_t v238 = v237; // 0xcb1c
        if (v231 == (int32_t)&g44) {
            // 0xcb30
            v238 = __asm_sxth(v237);
        }
        int16_t * v239 = (int16_t *)(v232 + (int32_t)&g62); // 0xcb14
        int32_t v240 = v238;
        v235 = v239;
        v234 = v240;
        v233 = v240 >> (int32_t)&g24;
        if (v231 == (int32_t)&g62) {
            int32_t v241 = __asm_sxtb(v240); // 0xcb3a
            v235 = v239;
            v234 = v241;
            v233 = v241 >> (int32_t)&g24;
        }
    }
    int32_t v242 = v233;
    int32_t v243 = v234;
    int32_t v244; // 0xc8ec
    int32_t v245; // 0xc8ec
    char v246; // 0xc8ec
    char v247; // 0xc8ec
    if (v242 > -1) {
        // 0xcb56
        v247 = &g36;
        v245 = v243;
        v246 = 1;
        v244 = v242;
        if (v106 << (int32_t)&g11 >= 0) {
            int32_t v248 = v106 << (int32_t)&g24; // 0xcb64
            char v249 = v248 == 0 ? v27 : (char)&g26;
            v247 = v249;
            v245 = v243;
            v246 = v248 == 0 ? (char)v248 : 1;
            v244 = v242;
        }
    } else {
        // 0xcb48
        v247 = &g37;
        v245 = -v243;
        v246 = 1;
        v244 = (int32_t)(v243 != 0) - v242;
    }
    // 0xcb6c
    v114 = v246;
    v200 = v110;
    v198 = v235;
    v196 = (char *)&g97;
    v194 = v247;
    v192 = v245;
    v190 = v106;
    v211 = v24;
    v188 = v244;
    goto lab_0xcc1c;
  lab_0xce46:;
    // 0xce46
    int32_t v250; // 0xc8ec
    v251 = (char *)v250;
    v252 = v250;
    goto lab_0xce48;
  lab_0xce48:;
    int32_t v253 = v252;
    char * v254 = v251;
    v179 = v254;
    if (v253 < 2) {
        goto lab_0xce56;
    } else {
        unsigned char v255 = *(char *)(v256 - 1 + v253); // 0xce50
        v179 = v254;
        if ((int32_t)v255 == (int32_t)&g45) {
            // 0xce64
            v250 = (int32_t)v254 - (int32_t)&g1;
            goto lab_0xce46;
        } else {
            goto lab_0xce56;
        }
    }
  lab_0xcbf8:
    // 0xcbf8
    v114 = v257;
    char v258 = v259; // 0xcbf8
    goto lab_0xcbfa;
  lab_0xca80:;
    uint32_t v267 = v116;
    int32_t v268 = (int32_t)v117;
    int32_t v269 = 0; // 0xca82
    char * v270; // 0xc8ec
    if (v106 << (int32_t)&g21 < 0) {
        // 0xca8c
        v270 = NULL;
        if (v24 > 0) {
            uint32_t v271 = 0;
            if (v271 >= v267) {
                // 0xca96
                if (*(char *)(v271 + v268) == 0) {
                    // break -> 0xcab8
                    break;
                }
            }
            int32_t v272 = v271 + (int32_t)&g1; // 0xca8a
            char * v273 = (char *)v272; // 0xca8c
            v270 = v273;
            while (v272 < v24) {
                // 0xca92
                v271 = v272;
                if (v271 >= v267) {
                    // 0xca96
                    v270 = v273;
                    if (*(char *)(v271 + v268) == 0) {
                        // break -> 0xcab8
                        break;
                    }
                }
                // 0xca88
                v272 = v271 + (int32_t)&g1;
                v273 = (char *)v272;
                v270 = v273;
            }
        }
    } else {
        uint32_t v274; // 0xc8ec
        while (true) {
            // 0xcaa8
            v274 = v269;
            if (v274 >= v267) {
                // 0xcaae
                if (*(char *)(v274 + v268) == 0) {
                    // break -> 0xcab8
                    break;
                }
            }
            // 0xcaa4
            v269 = v274 + (int32_t)&g1;
        }
        // 0xcab8
        v270 = (char *)v274;
    }
    int16_t * v275 = (int16_t *)((int32_t)v30 + (int32_t)&g62);
    int32_t v276 = (int32_t)v270;
    int32_t v277 = v25 - v276; // 0xcabe
    int32_t v278 = function_cff8(v277, v106, v2, a4) + v19 + v276; // 0xcace
    char * v279 = (char *)(v276 - 1); // 0xcaee
    char * v280 = v279; // 0xcaf2
    v171 = v275;
    v172 = v279;
    v173 = v27;
    v174 = v33;
    v175 = v277;
    v176 = v106;
    v177 = v278;
    if (v270 != NULL) {
        char * v281 = v280;
        char * v282 = (char *)((int32_t)v281 - 1); // 0xcaee
        v171 = v275;
        v172 = v282;
        v173 = v27;
        v174 = v33;
        v175 = v277;
        v176 = v106;
        v177 = v278;
        while (v281 != NULL) {
            // 0xcada
            v281 = v282;
            v282 = (char *)((int32_t)v281 - 1);
            v171 = v275;
            v172 = v282;
            v173 = v27;
            v174 = v33;
            v175 = v277;
            v176 = v106;
            v177 = v278;
        }
    }
    goto lab_0xcd20;
  lab_0xcbfa:;
    char v260 = v258;
    v200 = v109;
    v198 = v261;
    v196 = v262;
    v194 = v260;
    v192 = v263;
    v190 = v264;
    v211 = v265;
    v188 = v266;
    if (v262 == (char *)&g90) {
        // 0xcc06
        v200 = v109;
        v198 = v261;
        v196 = (char *)&g90;
        v194 = v260;
        v192 = v263;
        v190 = v264;
        v211 = v265;
        v188 = v266;
        if (v264 << (int32_t)&g21 < 0 || (v266 || v263) != 0) {
            // 0xcc10
            v114 = 1;
            v200 = v109;
            v198 = v261;
            v196 = (char *)&g90;
            v194 = &g45;
            v192 = v263;
            v190 = v264;
            v211 = v265 - 1;
            v188 = v266;
        }
    }
    goto lab_0xcc1c;
  lab_0xce82:
    // 0xce82
    v182 = v183;
    v181 = (char *)v180;
    goto lab_0xce84;
  lab_0xce84:
    // 0xce84
    v138 = (char)(v33 - (int32_t)v182) + 1;
    v139 = v181;
    v140 = 1 << (int32_t)&g24;
    goto lab_0xce90;
}

// Address range: 0xcfd8 - 0xcff8
int32_t function_cfd8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 0; // 0xcfe4
    if (a2 << (int32_t)&g7 < 0) {
        // 0xcff0
        result = -a1 > 0 ? 0 : a1;
    }
    // 0xcff4
    return result;
}

// Address range: 0xcff8 - 0xd024
int32_t function_cff8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = 0; // 0xd00e
    if (a2 << (int32_t)&g7 >= 0) {
        // 0xd01a
        result = -a1 > 0 ? 0 : a1;
    }
    // 0xd01e
    return result;
}

// Address range: 0xd024 - 0xd02e
int32_t function_d024(int32_t result, int32_t * a2) {
    // 0xd024
    *a2 = (int32_t)a2 + 1;
    *(char *)a2 = (char)result;
    return result;
}

// Address range: 0xd02e - 0xd0ec
int32_t function_d02e(int32_t a1) {
    // 0xd02e
    uint32_t v1; // 0xd02e
    if (a1 == 256) {
        // 0xd0e6
        v1 = (int32_t)&g90;
        __asm_nop((int32_t *)0, a1, v1, 256);
        return v1 % 256;
    }
    int32_t v2 = a1 - 256; // 0xd038
    if (a1 <= 256) {
        // 0xd040
        if (a1 == (int32_t)&g2) {
            // 0xd0e6
            v1 = (int32_t)&g62;
            __asm_nop((int32_t *)v2, a1, v1, 256);
            return v1 % 256;
        }
        if (a1 > (int32_t)&g2) {
            // 0xd058
            if (a1 == (int32_t)&g26) {
                // 0xd0e6
                v1 = 5;
                __asm_nop((int32_t *)v2, a1, v1, 256);
                return v1 % 256;
            }
            int32_t v3 = 6; // 0xd05e
            if (a1 != (int32_t)&g63) {
                // 0xd060
                v3 = a1 == (int32_t)&g91 ? (int32_t)&g82 : 0;
            }
            // 0xd0e6
            __asm_nop((int32_t *)v2, a1, v3, 256);
            return v3 % 256;
        }
        // 0xd046
        switch (a1) {
            case 1: {
                // 0xd0e6
                v1 = 0;
                __asm_nop((int32_t *)-255, a1, v1, 256);
                return v1 % 256;
            }
            case 2: {
                // 0xd0e6
                v1 = 1;
                __asm_nop((int32_t *)-254, a1, v1, 256);
                return v1 % 256;
            }
        }
        int32_t v4 = 2; // 0xd050
        if (a1 != (int32_t)&g62) {
            // 0xd052
            v4 = a1 == (int32_t)&g90 ? (int32_t)&g44 : 0;
        }
        // 0xd0e6
        __asm_nop((int32_t *)v2, a1, v4, 256);
        return v4 % 256;
    }
    int32_t v5 = v2 - ((int32_t)&g126 << (int32_t)&g90); // 0xd06a
    if (v2 == (int32_t)&g126 << (int32_t)&g90) {
        // 0xd0e6
        v1 = (int32_t)&g106;
        int32_t v6 = (int32_t)&g126 << (int32_t)&g90;
        __asm_nop((int32_t *)v6, a1, v1, v5);
        return v1 % 256;
    }
    if (v2 <= (int32_t)&g126 << (int32_t)&g90) {
        // 0xd072
        if (a1 == 512) {
            // 0xd0e6
            v1 = (int32_t)&g95;
            __asm_nop((int32_t *)0, a1, v1, v5);
            return v1 % 256;
        }
        int32_t v7 = a1 - 1024; // 0xd07e
        int32_t v8 = 0; // 0xd082
        int32_t v9 = (int32_t)&g97; // 0xd082
        int32_t v10 = v5; // 0xd082
        if (v7 != 0) {
            // 0xd084
            v9 = v7 == 1 << (int32_t)&g97 ? (int32_t)&g102 : 0;
            v8 = v7 - (1 << (int32_t)&g97);
            v10 = 1 << (int32_t)&g97;
        }
        // 0xd0e6
        __asm_nop((int32_t *)v8, a1, v9, v10);
        return v9 % 256;
    }
    int32_t v11 = v5 - (1 << (int32_t)&g106); // 0xd092
    if (v5 == 1 << (int32_t)&g106) {
        // 0xd0e6
        v1 = (int32_t)&g111;
        __asm_nop((int32_t *)v11, a1, v1, 1 << (int32_t)&g106);
        return v1 % 256;
    }
    int32_t v12 = v11 - (1 << (int32_t)&g111); // 0xd09a
    if (v11 == 1 << (int32_t)&g111) {
        // 0xd0e6
        v1 = (int32_t)&g121;
        __asm_nop((int32_t *)v12, a1, v1, 1 << (int32_t)&g111);
        return v1 % 256;
    }
    int32_t v13 = v12 - 2 * (1 << (int32_t)&g111); // 0xd0a0
    int32_t v14 = v13; // 0xd0a2
    int32_t v15 = 0; // 0xd0a2
    if (v12 == 2 * (1 << (int32_t)&g111)) {
        // 0xd0e2
        v14 = __asm_nop((int32_t *)v13, a1, (int32_t)&g126, 2 * (1 << (int32_t)&g111));
        v15 = (int32_t)&g126;
    }
    // 0xd0e6
    __asm_nop((int32_t *)v14, a1, v15, 2 * (1 << (int32_t)&g111));
    return v15 % 256;
}

// Address range: 0xd0ec - 0xd0fe
int32_t function_d0ec(int32_t a1) {
    // 0xd0ec
    return function_d100(1000 * a1);
}

// Address range: 0xd100 - 0xd13e
int32_t function_d100(int32_t a1) {
    while (true) {
        // continue -> 0xd138
    }
}

// Address range: 0xd148 - 0xd29c
int32_t function_d148(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd148
    function_c6b8();
    *(int32_t *)((1 << (uint32_t)(int32_t)&g23) + (int32_t)&g90) = 0x1a000487;
    function_bacc();
    int32_t v1 = function_af80(); // 0xd15a
    function_bb0c(v1, 1 << (int32_t)&g23, a3, a4);
    function_c08c();
    function_16e8();
    function_1aa((int32_t *)0x20000a94, &g8, a3, a4);
    function_19c(3371, (int32_t)&g126, (int32_t)&g37);
    *(char *)&g113 = 0;
    function_a7cc();
    function_9d7c((int32_t *)0x20000402, (int32_t *)0x20000404);
    int32_t v2 = function_62b4(); // 0xd194
    function_5de8(v2, 0x20000404, (int32_t)&g37, a4);
    function_5f5c(0, 2);
    function_5f5c(1, 2);
    function_1d7c();
    function_1ab8(1);
    function_7408();
    uint32_t v3 = 0; // 0xd1bc
    function_9d7c((int32_t *)(2 * v3 + 0x20000408), (int32_t *)0x20000404);
    v3 = (v3 + 1) % 256;
    while (v3 < 4) {
        // 0xd1be
        function_9d7c((int32_t *)(2 * v3 + 0x20000408), (int32_t *)0x20000404);
        v3 = (v3 + 1) % 256;
    }
    // 0xd1d0
    function_117c(0);
    function_9b3c();
    function_5960();
    function_d0ec(1000);
    *"L\x04" = (char)&g48;
    int32_t v4 = function_167c((int32_t *)&g48, (int32_t)"L\x04", (int32_t)&g37, a4); // 0xd1fc
    uint32_t v5 = *(int32_t *)0x20000aa0; // 0xd206
    if (v5 >= 0xf423f != v5 != 0xf423f) {
        // 0xd20c
        *"n\x03" = 1;
        function_5578(v5, 0xf423f, (int32_t)&g37, a4);
        *"n\x03" = 0;
    }
    // 0xd216
    function_54c8(v4);
    function_bf98(0x40060000, (int32_t)&g106);
    *"o\x03" = 1;
    function_5b28(0, (int32_t *)&g106);
    unsigned char v6 = *(char *)((int32_t)*(char *)0x20000a9d + 0x20000a94) + 1;
    int32_t v7 = v6; // 0xd236
    int32_t v8; // 0xd148
    if (v6 >= 200 == (v6 != -56)) {
        uint32_t v9 = v7 - 201; // 0xd262
        v8 = (int32_t)&g106;
        if (v9 >= 6 != v9 != 6) {
            // 0xd268
            function_5b28(1, (int32_t *)&g32);
            v8 = (int32_t)&g32;
        }
    } else {
        // 0xd23c
        function_5b28(1, &g31);
        function_5c44(2, v7, (int32_t)&g37, a4);
        v8 = v7;
    }
    // 0xd270
    function_5cc0(0);
    int32_t v10 = function_7690(); // 0xd27c
    while (true) {
        // 0xd27e
        function_4d48(v10, v8, (int32_t)&g37, a4);
        v10 = 45;
    }
}

// Address range: 0xd2ba - 0xd2bb
int32_t function_d2ba(void) {
    // 0xd2ba
    int32_t result; // 0xd2ba
    return result;
}

// Address range: 0xd2e4 - 0xd314
int32_t function_d2e4(int32_t a1, int32_t a2) {
    // 0xd2e4
    bool v1; // 0xd2e4
    int32_t v2; // 0xd2e4
    if (v1) {
        *(char *)(v2 - 420) = (char)v2;
    } else {
        *(char *)v2 = -20;
    }
    int32_t v3 = 0x10000000 * v2; // 0xd2f0
    int32_t v4; // 0xd2e4
    if (v1) {
        int32_t v5 = v2 - (v2 << (int32_t)&g21); // 0xd2ec
        v4 = v5 << (int32_t)&g12 & v2;
        v3 = 0x100000 * v5;
    }
    bool v6; // 0xd2e4
    bool v7; // 0xd2e4
    bool v8; // 0xd2e4
    bool v9; // 0xd2e4
    int32_t result; // 0xd2e4
    if (v1) {
        int32_t v10 = v3;
        v8 = false;
        v9 = (v10 & 1 << (int32_t)&g24) != 0;
        if ((v10 & 1 << (int32_t)&g24) == 0) {
            int32_t v11 = (v10 & 1 << (int32_t)&g24) != 0 ? v4 ^ 0xd304 << v2 : (int32_t)((v10 & 1 << (int32_t)&g24) == 0);
            result = v11;
            v7 = false;
            v6 = (v11 & 0xd304) == 0;
            goto lab_dec_label_pc_unknown_12;
        } else {
            goto lab_0xd304;
        }
    } else {
        goto lab_0xd304;
    }
  lab_0xd304:
    // 0xd304
    result = function_44df04();
    v7 = v8;
    v6 = v9;
    goto lab_dec_label_pc_unknown_12;
  lab_dec_label_pc_unknown_12:
    if (!v7 && !v6) {
        __asm_cdpgt(0, 0, 0, 0, 0, 0);
    }
    return result;
}

// Address range: 0xd316 - 0xd32e
int32_t function_d316(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1; // 0xd316
    int32_t v2; // 0xd316
    int32_t v3; // 0xd316
    int32_t v4; // 0xd316
    int32_t v5; // 0xd316
    bool v6; // 0xd316
    if (v6 || !v6) {
        v4 = *(int32_t *)(a3 - (int32_t)&g11);
        v5 = *(int32_t *)(a3 - (int32_t)&g26);
        v2 = *(int32_t *)(a3 - (int32_t)&g34);
        v3 = *(int32_t *)(a3 - (int32_t)&g2);
        v1 = a3;
    }
    uint32_t v7 = v3;
    int32_t v8 = v4; // 0xd322
    int32_t result = v1 & (v6 ? v5 : -1); // 0xd322
    result = *(int32_t *)v2;
    v8 = *(int32_t *)(v2 + (int32_t)&g62);
    if (v6) {
        uint32_t v9 = v8 >> (int32_t)&g106; // 0xd326
        int32_t v10 = (v8 & 2048) == 0 ? -2 : 0;
        bool v11 = (v8 & 2048) == 0 ? v7 != -1 | v9 < v9 - v7 + v10 : v9 < v7; // 0xd326
        if (!v11) {
            // 0xd32e
            return result;
        }
    } else {
        if (v6) {
            // 0xd32e
            return result;
        }
    }
    // 0xd32e
    return function_1414692();
}

// Address range: 0xd330 - 0xd340
int32_t function_d330(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = a1; // 0xd338
    bool v1; // 0xd330
    if (v1) {
        result = function_fe9804c0();
    }
    // 0xd33c
    return result;
}

// Address range: 0xd340 - 0xd342
int32_t function_d340(void) {
    // 0xd340
    int32_t result; // 0xd340
    result = function_d2ba();
    // 0xd342
    return result;
}

// Address range: 0xd344 - 0xd370
int32_t function_d344(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd344
    int32_t v1; // 0xd344
    int32_t v2 = v1;
    int32_t result; // 0xd344
    int32_t v3; // 0xd344
    int32_t v4; // 0xd344
    int32_t v5; // 0xd344
    bool v6; // 0xd344
    if (v6) {
        // .thread
        result = function_feead194();
    } else {
        result = a1;
        v3 = *(int32_t *)(v1 - (int32_t)&g62);
        v4 = *(int32_t *)(v1 - (int32_t)&g90);
        v5 = v1 - (int32_t)&g106;
    }
    if (!v6) {
        if (v6) {
            // .critedge34
            __asm_ldcne(14, 3, 0x6060, -112);
            return result;
        }
        // .thread32
        __asm_svcvc(0x7e7e);
        __asm_ldcne(14, 3, 0x6060, -112);
        __asm_svcvc(0x7f007f);
        return result;
    }
    int32_t v7 = result << (int32_t)&g16; // 0xd350
    if (((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        if (v7 != v2) {
            // .critedge
            __asm_ldcne(14, 3, 0x6060, -112);
            return result;
        }
    } else {
        __asm_svcvc(0x7e7e);
        if (v7 != v2) {
            // .critedge33
            __asm_ldcne(14, 3, 0x6060, -112);
            __asm_svcvc(0x7f007f);
            return result;
        }
    }
    // .thread24
    *(int32_t *)(a4 - 127) = result;
    *(int32_t *)a4 = result;
    *(int32_t *)(a4 - (int32_t)&g62) = a2;
    *(int32_t *)(a4 - (int32_t)&g90) = a3;
    *(int32_t *)(a4 - (int32_t)&g106) = a4;
    int32_t v8; // 0xd344
    *(int32_t *)(a4 - (int32_t)&g2) = v8;
    *(int32_t *)(a4 - (int32_t)&g11) = v3;
    *(int32_t *)(a4 - (int32_t)&g16) = v4;
    *(int32_t *)(a4 - (int32_t)&g20) = v5;
    __asm_svcvc(0x7f007f);
    return -0xd364;
}

// Address range: 0xd50e - 0xd53a
int32_t function_d50e(int32_t a1) {
    // 0xd50e
    bool v1; // 0xd50e
    bool v2 = v1;
    if (!v2) {
        __asm_svcne(0x700e0);
    }
    bool v3; // 0xd50e
    if (v1) {
        int32_t v4; // 0xd50e
        if ((1 << v4 - 1 & (int32_t)&g115) != 0) {
            // .thread
            return v2 ? 0 : a1;
        }
        __asm_svclo(0x706060);
        v3 = false;
        goto lab_dec_label_pc_unknown_14;
    } else {
        v3 = true;
        if (v1) {
            goto lab_dec_label_pc_unknown_14;
        } else {
            __asm_svclo(0x706060);
            v3 = false;
            goto lab_dec_label_pc_unknown_14;
        }
    }
  lab_dec_label_pc_unknown_14:
    if (!v1 && !v2 && v3 == !v2) {
        __asm_svcvc(0x7f7f00);
    }
    return v3 == !v2 ? v2 ? 0 : a1 : 0;
}

// Address range: 0xd54e - 0xd562
int32_t function_d54e(uint32_t a1) {
    int32_t result = a1; // 0xd54e
    bool v1; // 0xd54e
    bool v2; // 0xd54e
    if (!v2) {
        v1 = false;
        result = ((int32_t)((int64_t)a1 << (int64_t)&g27) | a1 | (int32_t)v2 << (int32_t)&g26) & a1;
    }
    int32_t v3; // 0xd54e
    if (v1 == !v2) {
        __asm_ldchi(8, 1, v3, 24);
    }
    if (!v2 && true) {
        __asm_stcgt(12, 8, v3, 140);
    }
    return result;
}

// Address range: 0xd578 - 0xd5b0
int32_t function_d578(int32_t a1, int32_t a2, int32_t a3) {
    // 0xd578
    bool v1; // 0xd578
    if (!v1) {
        // .critedge
        __asm_svcne(0x1f1e1c);
        return -0x33333334;
    }
    int32_t v2; // 0xd578
    int32_t * v3 = (int32_t *)v2; // 0xd584
    __asm_ldc2l(0, 0, *v3, 0);
    if (!v1) {
        __asm_stclhi(12, 12, *v3, 204);
    }
    bool v4; // 0xd578
    if (v1) {
        // .thread
        v4 = (1 << a1 - 1 & a1) != 0;
    } else {
        function_1c65720();
    }
    __asm_ldcls(8, 15, v2, -960);
    if (!v4) {
        __asm_stchi(12, 8, *v3, 140);
    }
    return v2 + v2 * v2;
}

// Address range: 0xd5d6 - 0xd5e2
int32_t function_d5d6(void) {
    // 0xd5d6
    bool v1; // 0xd5d6
    int32_t result; // 0xd5d6
    if (v1 == !v1) {
        __asm_stchi(12, 8, result, 220);
    }
    if (!v1 && v1) {
        __asm_svclo(0x1e0000);
    }
    return result;
}

// Address range: 0xd5e2 - 0xd5f0
int32_t function_d5e2(int32_t a1, int32_t a2) {
    // 0xd5e2
    int32_t v1; // 0xd5e2
    int32_t v2 = v1;
    *(char *)(v2 + (int32_t)&g106) = (char)v2;
    *(int32_t *)(v1 + (int32_t)&g11) = a2;
    return function_d7e0(a1, a2, v1, v1);
}

// Address range: 0xd654 - 0xd69c
int32_t function_d654(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0xd654
    bool v2; // 0xd654
    bool v3; // 0xd654
    int32_t v4; // 0xd654
    if (v3) {
        v2 = (512 * v4 & 1 << (int32_t)&g24) != 0;
        v1 = v4 << (int32_t)&g97 & a4;
    }
    int32_t result = v1;
    if (v3) {
        int32_t v5; // 0xd654
        *(int32_t *)(v4 - (int32_t)&g62) = (int32_t)&v5;
    }
    bool v6; // 0xd654
    bool v7; // 0xd654
    bool v8; // 0xd654
    if (v3) {
        int32_t v9 = v4 ^ v4 >> (int32_t)&g7; // 0xd65c
        v7 = (v4 & 0x20000) != 0;
        v8 = v9 == 0;
        if (v9 < 0) {
            goto lab_dec_label_pc_unknown_15;
        } else {
            v6 = (v4 & 0x20000) != 0;
            if (v9 == 0) {
                goto lab__critedge;
            } else {
                goto lab_0xd684;
            }
        }
    } else {
        v7 = v2;
        v8 = false;
        if (!v3) {
            if (v2) {
                __asm_cdpne(0, 3, 0, 14, 0, 0);
                return result;
            }
            __asm_cdplo(0, 1, 0, 14, 0, 0);
            __asm_cdpne(0, 3, 0, 14, 0, 0);
            return result;
        }
        goto lab_dec_label_pc_unknown_15;
    }
  lab_dec_label_pc_unknown_15:
    *(int32_t *)(v4 - (int32_t)&g16) = a2;
    *(int32_t *)(v4 - (int32_t)&g11) = a3;
    v6 = v7;
    if (v8) {
        goto lab__critedge;
    } else {
        goto lab_0xd684;
    }
  lab__critedge:
    // .critedge
    *(int32_t *)result = result;
    *(int32_t *)(result - (int32_t)&g62) = a4;
    *(int32_t *)v4 = a4;
    return result;
  lab_0xd684:
    // 0xd684
    if (v6) {
        __asm_cdpne(0, 3, 0, 14, 0, 0);
        return result;
    }
    __asm_cdplo(0, 1, 0, 14, 0, 0);
    __asm_cdpne(0, 3, 0, 14, 0, 0);
    return result;
}

// Address range: 0xd69c - 0xd6f0
int32_t function_d69c(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4) {
    // 0xd69c
    int32_t v1; // 0xd69c
    uint32_t v2 = v1;
    int32_t v3 = unknown_4fd722(a1) >> v2 << (int32_t)&g2; // 0xd6a4
    *(char *)v3 = (char)v3;
    uint16_t v4 = *(int16_t *)((a4 << (int32_t)&g2) + (int32_t)&g76); // 0xd6ae
    int32_t v5 = a2 >> (int32_t)&g26; // 0xd6b6
    int32_t v6 = ((int32_t)v4 + (int32_t)&g96 << (int32_t)&g16) - (int32_t)&g55; // 0xd6b8
    *(int32_t *)v6 = v6;
    int32_t v7 = v5 << (int32_t)&g1; // 0xd6be
    *(int16_t *)v7 = (int16_t)v7;
    *(int32_t *)(v7 + (int32_t)&g106) = v7;
    uint32_t v8 = v5 * ((2 * (1 << (int32_t)&g1) << (int32_t)&g62) + 2 * (1 << (int32_t)&g1)); // 0xd6ca
    *(int16_t *)(v2 + (int32_t)&g62) = (int16_t)v8;
    int32_t result = function_d6f2(v8 >> (int32_t)&g20, a3 >> (int32_t)&g20, a3, v5 * (2 * (1 << (int32_t)&g1) << (int32_t)&g62)); // 0xd6ee
    return result;
}

// Address range: 0xd6f0 - 0xd6f2
int32_t function_d6f0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd6f0
    int32_t v1; // 0xd6f0
    return v1 + a4;
}

// Address range: 0xd6f2 - 0xd772
int32_t function_d6f2(int32_t a1, int32_t a2, int32_t a3, uint32_t a4) {
    int32_t v1 = a4 >> (uint32_t)(int32_t)&g20; // 0xd708
    *(int16_t *)(v1 + 2 * (int32_t)&g62) = (int16_t)v1 + (int16_t)&g62;
    abort();
    // UNREACHABLE
}

// Address range: 0xd784 - 0xd7e0
int32_t function_d784(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd784
    int32_t v1; // 0xd784
    bool v2; // 0xd784
    int32_t v3; // 0xd784
    if (v2 == (result == 0 || v2)) {
        if (v2) {
            // .thread10.thread
            __asm_svceq(0x1f1010);
            return result;
        }
        // ._crit_edge
        v1 = v3 * ((1 << (int32_t)&g3) - 1);
    } else {
        int32_t v4 = v3 << (int32_t)&g3; // 0xd790
        int32_t v5 = v3 * ((1 << (int32_t)&g3) - 1);
        v1 = v5;
        if (((v4 ^ v3) & (v4 ^ v5)) < 0) {
            // .thread10.thread
            __asm_svceq(0x1f1010);
            return result;
        }
    }
    int32_t v6 = v1 - (int32_t)((0x10000 * v3 & 1 << (int32_t)&g24) == 0); // 0xd7a0
    if (v6 == 0) {
        // .thread10
        __asm_svceq(0x1f1010);
        return result;
    }
    int32_t result2 = v6 & result << (int32_t)&g2; // 0xd7a4
    if (result2 != 0) {
        return result2;
    }
    // .thread10
    __asm_svceq(0x1f1010);
    return 0;
}

// Address range: 0xd7e0 - 0xd802
int32_t function_d7e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd7e0
    int32_t v1; // 0xd7e0
    unsigned char v2 = *(char *)(v1 + (int32_t)&g44); // 0xd7e2
    *(char *)(int32_t)v2 = v2;
    int16_t * v3 = (int16_t *)(a2 + (int32_t)&g62); // 0xd7f0
    int16_t v4 = *v3; // 0xd7f0
    *(char *)((a4 << (int32_t)&g62) + (int32_t)&g44) = (char)v4;
    int32_t v5 = a3 >> (int32_t)&g26; // 0xd7f8
    *(char *)v5 = (char)v5;
    return (int32_t)*v3;
}

// Address range: 0xd804 - 0xd854
int32_t function_d804(int32_t result) {
    // 0xd804
    bool v1; // 0xd804
    if (result == 0 || v1) {
        return result;
    }
    int32_t v2 = result >> 1 ^ result; // 0xd830
    int32_t result3 = 0x1000; // 0xd838
    int32_t v3; // 0xd804
    if (v2 != 0) {
        int32_t result2 = v3 & v2 << (int32_t)&g16; // 0xd838
        result3 = 0;
        if (result2 != 0) {
            return result2;
        }
    }
    // .thread
    *(int32_t *)v3 = result3;
    *(int32_t *)(v3 - (int32_t)&g64) = result3;
    return result3;
}

// Address range: 0xd854 - 0xd86e
int32_t function_d854(int32_t a1, int32_t a2, int32_t a3) {
    // 0xd854
    int32_t v1; // 0xd854
    int32_t result = function_d870(((uint32_t)v1 >> (int32_t)&g26) + (int32_t)&g90 + (int32_t)&g87); // 0xd86c
    return result;
}

// Address range: 0xd86e - 0xd870
int32_t function_d86e(void) {
    // 0xd86e
    int32_t v1; // 0xd86e
    return v1 >> (int32_t)&g44;
}

// Address range: 0xd870 - 0xd874
int32_t function_d870(int32_t a1) {
    // 0xd870
    int32_t v1; // 0xd870
    return function_da56(a1, v1, v1, v1);
}

// Address range: 0xd890 - 0xd8a8
int32_t function_d890(int32_t result) {
    // 0xd890
    int32_t v1; // 0xd890
    uint32_t v2 = v1;
    bool v3; // 0xd890
    bool v4; // 0xd890
    bool v5; // 0xd890
    bool v6; // 0xd890
    bool v7; // 0xd890
    bool v8; // 0xd890
    int32_t v9; // 0xd890
    bool v10; // 0xd890
    if (!v10) {
        uint32_t v11 = v2 << (int32_t)&g3; // 0xd890
        uint32_t v12 = v2 * ((1 << (int32_t)&g3) - 1); // 0xd890
        int32_t v13 = (0x10000 * v2 & 1 << (int32_t)&g24) == 0; // 0xd890
        int32_t v14 = v12 - v13; // 0xd890
        bool v15 = (0x10000 * v2 & 1 << (int32_t)&g24) == 0 ? v2 != -1 | v11 < v14 - v13 : v11 < v2; // 0xd890
        v5 = (0x10000 * v2 & 1 << (int32_t)&g24) == 0;
        v9 = v14;
        v4 = v12 % 2 != 0;
        v3 = (0x10000 * v2 & 1 << (int32_t)&g24) == 0;
        v8 = v14 == 0;
        v7 = !v15;
        v6 = v12 % 2 != 0;
    }
    int32_t v16 = v9;
    if (v6 != v3) {
        __asm_svcne(0x1f1000);
    }
    if (v8) {
        __asm_svceq(0x1f1010);
    }
    if (v4 != v5) {
        return result + (int32_t)&g106;
    }
    int32_t result2; // 0xd890
    if (v7) {
        result2 = result;
        if (v8) {
            return result;
        }
    } else {
        int32_t v17 = v16 << (int32_t)&g2 & v16; // 0xd8a0
        result2 = v17;
        if (v17 == 0) {
            return 0;
        }
    }
    g118 = v16;
    return result2;
}

// Address range: 0xd8b0 - 0xd8bc
int32_t function_d8b0(int32_t result) {
    // 0xd8b0
    int32_t v1; // 0xd8b0
    int32_t v2 = v1;
    if (((v2 << (int32_t)&g2) - result) % 2 != 0 != ((0x8000 * v2 & 1 << (int32_t)&g24) == 0)) {
        __asm_svcne(result);
    }
    return result;
}

// Address range: 0xd8c0 - 0xd8c8
int32_t function_d8c0(void) {
    // 0xd8c0
    bool v1; // 0xd8c0
    if (!v1 && v1) {
        __asm_svcne(0x1f1000);
    }
    int32_t result; // 0xd8c0
    return result;
}

// Address range: 0xd8d0 - 0xd8f0
int32_t function_d8d0(int32_t result, uint32_t a2) {
    // 0xd8d0
    bool v1; // 0xd8d0
    if (!v1) {
        // .critedge1
        return result;
    }
    if (!v1) {
        __asm_svcne(0x1f1000);
        return result + (int32_t)&g106;
    }
    // 0xd8e0
    if ((result << a2 - 1 & 1 << (int32_t)&g24) != 0) {
        // .critedge1
        return result << a2 & result;
    }
    int32_t result2 = 0; // 0xd8e4
    if (result2 != 0) {
        __asm_svcne(0xf1111);
    }
    // .critedge1
    return result2;
}

// Address range: 0xd904 - 0xd91c
int32_t function_d904(int32_t a1) {
    // 0xd904
    bool v1; // 0xd904
    int32_t v2; // 0xd904
    return v1 ? a1 : v2 & a1 << (int32_t)&g20;
}

// Address range: 0xd920 - 0xd928
int32_t function_d920(void) {
    // 0xd920
    int32_t result; // 0xd920
    return result;
}

// Address range: 0xd93c - 0xd940
int32_t function_d93c(int32_t result) {
    // 0xd93c
    return result;
}

// Address range: 0xd944 - 0xd950
int32_t function_d944(int32_t result) {
    // 0xd944
    bool v1; // 0xd944
    if (!v1) {
        __asm_svcne(result);
    }
    return result;
}

// Address range: 0xd954 - 0xd96c
int32_t function_d954(int32_t result) {
    // 0xd954
    bool v1; // 0xd954
    if (v1) {
        return result;
    }
    __asm_svcne(0x1f0100);
    return result + (int32_t)&g106;
}

// Address range: 0xd970 - 0xd980
int32_t function_d970(uint32_t a1) {
    // 0xd970
    bool v1; // 0xd970
    bool v2; // 0xd970
    bool v3; // 0xd970
    bool v4; // 0xd970
    if (!v4) {
        int32_t v5; // 0xd970
        uint32_t v6 = v5 * ((1 << (int32_t)&g3) - 1); // 0xd970
        v1 = (0x10000 * v5 & 1 << (int32_t)&g24) == 0;
        v3 = v6 == (int32_t)((0x10000 * v5 & 1 << (int32_t)&g24) == 0);
        v2 = v6 % 2 != 0;
    }
    if (v2 != v1) {
        __asm_svcne(a1);
    }
    return (v3 ? a1 << a1 : -1) & a1;
}

// Address range: 0xd9b0 - 0xd9c0
int32_t function_d9b0(int32_t result) {
    // 0xd9b0
    return result;
}

// Address range: 0xd9c4 - 0xd9d0
int32_t function_d9c4(int32_t a1) {
    // 0xd9c4
    __asm_svceq(a1);
    bool v1; // 0xd9c4
    return v1 ? a1 : 0;
}

// Address range: 0xd9d2 - 0xd9d6
int32_t function_d9d2(void) {
    // 0xd9d2
    int32_t result; // 0xd9d2
    return result;
}

// Address range: 0xd9d8 - 0xd9e0
int32_t function_d9d8(void) {
    // 0xd9d8
    bool v1; // 0xd9d8
    int32_t v2; // 0xd9d8
    return v1 ? 0x7c18 : v2;
}

// Address range: 0xd9e4 - 0xd9f0
int32_t function_d9e4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd9e4
    return function_dae2(a1 * 2 * (1 << (uint32_t)(int32_t)&g20));
}

// Address range: 0xd9f0 - 0xd9fc
int32_t function_d9f0(int32_t result) {
    // 0xd9f0
    return result;
}

// Address range: 0xd9fe - 0xda12
int32_t function_d9fe(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0xd9fe
    bool v1; // 0xd9fe
    if (v1 == !v1) {
        return result;
    }
    int32_t result2; // 0xd9fe
    int32_t v2; // 0xd9fe
    if (v1) {
        // .thread
        result2 = result - v2;
    } else {
        __asm_svcne(0x1f1000);
        result2 = result;
    }
    if (!v1) {
        // branch -> 
    }
    if (!v1 && true) {
        *(int32_t *)v2 = a4;
    }
    return result2;
}

// Address range: 0xda16 - 0xda3e
int32_t function_da16(int32_t result, int32_t a2, int32_t a3, uint32_t a4) {
    // 0xda16
    bool v1; // 0xda16
    int32_t v2; // 0xda16
    if (v1 || (v2 << a4 & a2) == 0) {
        // .thread
        return result;
    }
    int32_t result2 = (v1 ? -1 : result << result) & result;
    if ((result << (int32_t)&g23 & (int32_t)&g119) == 0) {
        *(int32_t *)((result2 << (int32_t)&g25) + a4) = result2;
    }
    // .thread
    return result2;
}

// Address range: 0xda40 - 0xda54
int32_t function_da40(int32_t a1) {
    // 0xda40
    bool v1; // 0xda40
    int32_t v2; // 0xda40
    return v1 ? a1 : v2 << (int32_t)&g20 & v2;
}

// Address range: 0xda56 - 0xda8e
int32_t function_da56(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xda56
    abort();
    // UNREACHABLE
}

// Address range: 0xda90 - 0xdacc
int32_t function_da90(int32_t result) {
    // 0xda90
    bool v1; // 0xda90
    if (v1) {
        __asm_svceq(0x1f1000);
        __asm_svceq(0x1f1010);
    }
    bool v2 = v1 ? result < 0 : v1;
    bool v3 = v2; // 0xda9c
    bool v4; // 0xda90
    if (v1) {
        v4 = v2;
        v3 = !v2 != (result != -1 | 0 > result);
    }
    if (v3 == !v4) {
        if (result - (result >> (int32_t)&g26) == (int32_t)(result >= 0)) {
            return result;
        }
    } else {
        if (v4) {
            return result;
        }
    }
    return 0;
}

// Address range: 0xdae2 - 0xdae8
int32_t function_dae2(int32_t a1) {
    // 0xdae2
    return 0;
}

// Address range: 0xdaf0 - 0xdb18
int32_t function_daf0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 << a1; // 0xdaf0
    *(int16_t *)(v1 + (int32_t)&g76) = (int16_t)v1;
    return function_dbda(a3, a2);
}

// Address range: 0xdb32 - 0xdb86
int32_t function_db32(uint32_t a1) {
    // 0xdb32
    bool v1; // 0xdb32
    int32_t v2; // 0xdb32
    bool v3; // 0xdb32
    int32_t v4; // 0xdb32
    bool v5; // 0xdb32
    if (v5) {
        int32_t v6 = 0xdb4c << a1 & 0xdb4c; // 0xdb46
        v4 = v6;
        if (v6 == 0) {
            // .thread48
            __asm_svceq(0x80c0);
            v3 = false;
            v1 = false;
            v2 = 0;
            goto lab_0xdb7a;
        } else {
            goto lab__thread32;
        }
    } else {
        __asm_svcne(0x1f1000);
        __asm_svcne(0x80c0);
        v4 = a1 << a1 & a1;
        goto lab__thread32;
    }
  lab__thread32:;
    int32_t v7 = v4;
    int32_t v8 = 0xdb6c << v7 & v7; // 0xdb66
    if (v8 < 0) {
        return 0xdb7c;
    }
    bool v9 = 0xdb6c << v7 - 1 < 0 == (v8 != 0) ? v7 % 2 != 0 : 0xdb6c << v7 - 1 < 0;
    v3 = v9;
    v1 = v8 != 0;
    v2 = v7;
    if (v8 != 0) {
        return v7 + 0xdb7c;
    }
    goto lab_0xdb7a;
  lab_0xdb7a:
    // 0xdb7a
    __asm_svceq(0x40c0);
    return v3 == v1 ? 0 : v2;
}

// Address range: 0xdb88 - 0xdb98
int32_t function_db88(int32_t result) {
    // 0xdb88
    bool v1; // 0xdb88
    bool v2 = v1;
    if (!v2 && v1 != !v2) {
        __asm_svcne(result);
    }
    return result;
}

// Address range: 0xdb9a - 0xdbda
int32_t function_db9a(int32_t a1, int32_t a2, int32_t a3) {
    // 0xdb9a
    bool v1; // 0xdb9a
    int32_t v2 = (v1 == !v1 ? a1 << (int32_t)&g25 : -1) & a1;
    int32_t v3; // 0xdb9a
    if (v1) {
        *(int32_t *)(v2 - (int32_t)&g90) = 0xdba8;
    } else {
        // .critedge
        __asm_sadd16ne(a3, v3);
    }
    int32_t v4 = v3 << v3 & v2;
    int32_t result = v4; // 0xdbae
    if (!v1) {
        int32_t v5 = v1 ? v4 : v2;
        result = v1 ? v5 >> (int32_t)&g26 & v5 : 0;
        __asm_svceq(192);
        __asm_svceq(0x10101f);
    }
    return result;
}

// Address range: 0xdbda - 0xdbdc
int32_t function_dbda(int32_t result, int32_t a2) {
    // 0xdbda
    return result;
}

// Address range: 0xdbde - 0xdc2e
int32_t function_dbde(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xdbde
    bool v1; // 0xdbde
    int32_t v2; // 0xdbde
    bool v3; // 0xdbde
    int32_t v4; // 0xdbde
    if (v3) {
        __asm_svceq(0xc0c0);
        v2 = a1 >> 1 & a1;
        v1 = a1 % 2 != 0;
    } else {
        // .critedge
        *(int32_t *)v4 = a1;
        *(int32_t *)(v4 - (int32_t)&g62) = a2;
        *(int32_t *)(v4 - (int32_t)&g90) = a3;
        *(int32_t *)(v4 - (int32_t)&g106) = a4;
        v2 = a1;
    }
    int32_t v5 = v3 ? 0 : v2;
    int32_t v6 = v5 >> 1 & v5;
    int32_t v7 = v1 == !v3 == !v3 ? v6 : v4;
    bool v8; // 0xdbde
    bool v9; // 0xdbde
    int32_t v10; // 0xdbde
    if (v3) {
        __asm_svceq(0x70f18);
        v8 = true;
        v9 = v5 % 2 != 0;
        v10 = v6;
    } else {
        v8 = true;
        v9 = v5 % 2 != 0;
        v10 = v5;
        v8 = false;
        v9 = (v7 << v5 - 1 & 1 << (int32_t)&g24) != 0;
        v10 = v5;
    }
    // .thread9
    if (v9 == !v3) {
        __asm_svchi(0xc0c0);
    }
    bool v11; // 0xdbde
    int32_t v12; // 0xdbde
    int32_t v13; // 0xdbde
    int32_t v14; // 0xdbde
    if (v8) {
        int32_t v15 = v10 / 0x129d4; // 0xdc06
        v14 = v3 | v10 == 0 ? a4 : 0;
        v12 = v15;
        v13 = v15;
        v11 = true;
        if (v10 == 0) {
            goto lab__critedge3;
        } else {
            goto lab_dec_label_pc_unknown_17;
        }
    } else {
        v14 = v3 | false ? a4 : 0;
        v12 = v10;
        v13 = v10;
        v11 = true;
        if (v3) {
            goto lab__critedge3;
        } else {
            goto lab_dec_label_pc_unknown_17;
        }
    }
  lab__critedge3:
    // .critedge3
    if (!v3) {
        return v13 + (int32_t)&g90;
    }
    // 0xdc22
    if (!v11) {
        __asm_svcne(0xf0000);
    }
    return (v11 ? v7 << (int32_t)&g2 : -1) & v13;
  lab_dec_label_pc_unknown_17:
    v13 = v12;
    v11 = (v14 & v4 << v4) == 0;
    goto lab__critedge3;
}

// Address range: 0xdc2e - 0xdc72
int32_t function_dc2e(int32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    if (a2 >> (uint32_t)(int32_t)&g26 != 0) {
        function_45d44();
    }
    // 0xdc44
    return (int32_t)&g24;
}

// Address range: 0xdc8c - 0xdc90
int32_t function_dc8c(void) {
    // 0xdc8c
    int32_t result; // 0xdc8c
    return result;
}

// Address range: 0xdc94 - 0xdcfc
int32_t function_dc94(int32_t result, int32_t a2, int32_t a3, uint32_t a4) {
    // 0xdc94
    bool v1; // 0xdc94
    if (!v1) {
        return result;
    }
    if (!v1) {
        // .thread
        return function_d8c0();
    }
    int32_t v2 = v1 ? 0 : result;
    int32_t v3; // 0xdc94
    int32_t v4 = v3 >> v3; // 0xdca4
    int32_t v5 = v2 - v4; // 0xdca4
    if (v5 < 0) {
        // .thread
        return function_d8c0();
    }
    int32_t v6 = v5 < 0 ? v2 : 0;
    __asm_svcpl(0x520000);
    *(char *)a4 = (char)(v2 == v4 ? v6 & a4 / 64 : v5);
    *(char *)835 = 67;
    int32_t v7 = a3 < 0 == v2 == v4 ? 0 : v6;
    if (a3 < 0 == v2 == v4) {
        int32_t v8 = a4 - (int32_t)&g127; // 0xdcc0
        int32_t v9 = 0x1000000 * v7 >> 24; // 0xdce8
        *(int32_t *)v8 = v7;
        *(int32_t *)(v8 - (int32_t)&g62) = a3;
        *(int32_t *)(v8 - (int32_t)&g90) = v8;
        *(int32_t *)(v8 - (int32_t)&g20) = (int32_t)&v9;
    } else {
        // .critedge8
        *(char *)a2 = -3;
    }
    int32_t result2 = a3 == 0 == v2 == v4 ? v7 & -3 >> (int32_t)&g26 : v7;
    return result2;
}

// Address range: 0xdcfc - 0xddd0
int32_t function_dcfc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xdcfc
    *(int16_t *)a2 = (int16_t)a3;
    int32_t v1 = a4 << (int32_t)&g1; // 0xdd0e
    *(char *)(a4 * 2 * (1 << (int32_t)&g1)) = (char)v1;
    int32_t v2; // 0xdcfc
    *(char *)(2 * a2) = (char)v2;
    int32_t v3 = a2 * a2; // 0xdd24
    *(int16_t *)(v2 + v1 + v2) = (int16_t)v1;
    *(char *)((a3 << (int32_t)&g1) + v3) = (char)(v2 + a4 * (2 << (int32_t)&g1));
    *(int16_t *)0x4948 = 0;
    *(char *)(v3 + (int32_t)&g67 + (v1 << (int32_t)&g1) + v2) = 2 * (char)v3;
    abort();
    // UNREACHABLE
}

// Address range: 0xddd0 - 0xde28
int32_t function_ddd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xddd0
    *(int16_t *)(2 * a1) = (int16_t)a1;
    int32_t v1; // 0xddd0
    __asm_bxns(v1);
    *(int16_t *)(a2 + a1) = (int16_t)v1;
    *(int16_t *)((a2 << (int32_t)&g1) + a4) = 0x4443;
    int32_t v2 = 2 * ((int32_t)((a2 & 1 << (int32_t)&g24) != 0) + a2) + (int32_t)&g52 + (int32_t)&g45 + (int32_t)&g52; // 0xde10
    *(char *)(v1 + v2) = (char)v2;
    return 0x66680095;
}

// Address range: 0xde2c - 0xde3c
int32_t function_de2c(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0xde2c
    return result;
}

// Address range: 0xde40 - 0xde46
int32_t function_de40(int32_t a1) {
    // 0xde40
    return 0x484749;
}

// Address range: 0xdea8 - 0xdeb8
int32_t function_dea8(int32_t a1) {
    // 0xdea8
    bool v1; // 0xdea8
    if (v1) {
        __asm_svcmi(a1);
    }
    int32_t v2 = a1; // 0xdeac
    if (v1) {
        v2 = function_1f7cc();
        __asm_stchs(0, 0, v2);
    }
    // 0xdeb0
    return v1 ? v2 : 0;
}

// Address range: 0xe060 - 0xe0cc
int32_t function_e060(int32_t result, int32_t a2, int32_t a3, uint32_t a4) {
    // 0xe060
    bool v1; // 0xe060
    if (v1) {
        return -1 - (a4 / 8 | a4 << (int32_t)&g21);
    }
    return result;
}

// Address range: 0xe0da - 0xe0e2
int32_t function_e0da(int32_t a1) {
    // 0xe0da
    bool v1; // 0xe0da
    if (!v1 && true) {
        __asm_stcgt_1(0, 0, *(int32_t *)(a1 + (int32_t)&g60));
    }
    return function_ff30e4c2();
}

// Address range: 0xe0e4 - 0xe100
int32_t function_e0e4(int32_t result) {
    // 0xe0e4
    return result;
}

// Address range: 0xe100 - 0xe1b6
int32_t function_e100(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0xe100
    int32_t v1; // 0xe100
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g11); // 0xe110
    int32_t v3 = *(int32_t *)(v2 + (int32_t)&g11); // 0xe112
    int16_t v4 = *(int16_t *)(v1 + a4); // 0xe114
    *(int32_t *)(a4 + (int32_t)&g67) = v1 + 2 * (int32_t)&g47;
    int32_t v5 = *(int32_t *)(v3 + (int32_t)&g11); // 0xe118
    *(int32_t *)(v5 + (int32_t)&g67) = v5;
    int32_t * v6 = (int32_t *)(v1 + (int32_t)&g11); // 0xe11c
    *(int32_t *)(v1 + (int32_t)&g67) = *v6;
    int32_t v7 = *(int32_t *)(v5 + (int32_t)&g78); // 0xe120
    *(int32_t *)(v7 + (int32_t)&g67) = v7;
    int32_t v8 = *(int32_t *)(v7 + (int32_t)&g11); // 0xe126
    int32_t v9 = *v6; // 0xe128
    int32_t v10 = *(int32_t *)(v8 + (int32_t)&g11); // 0xe12a
    *(int32_t *)(v10 + (int32_t)&g67) = v10;
    int32_t v11 = *(int32_t *)(v10 + (int32_t)&g78); // 0xe136
    *(int32_t *)(v1 + (int32_t)&g67) = (int32_t)v4;
    *(int16_t *)(v9 + (int32_t)&g7) = (int16_t)v1;
    int32_t v12 = *(int32_t *)(a1 + (int32_t)&g79); // 0xe14a
    int32_t v13 = *(int32_t *)(a1 + (int32_t)&g78); // 0xe150
    int32_t v14 = *(int32_t *)(v1 + 2 * (int32_t)&g47 + (int32_t)&g37 + (int32_t)&g54 + (int32_t)&g58 + (int32_t)&g78); // 0xe152
    *(int32_t *)(v14 + (int32_t)&g69) = v1 + 2 * (int32_t)&g47 + (int32_t)&g37 + (int32_t)&g54 + (int32_t)&g58;
    *(int16_t *)(v12 + (int32_t)&g11) = (int16_t)v9;
    *(char *)(v14 + (int32_t)&g121) = (char)v12;
    *(int32_t *)(v1 + 2 * (int32_t)&g47 + (int32_t)&g37 + (int32_t)&g54 + (int32_t)&g58 + (int32_t)&g67) = v14;
    int32_t * v15 = (int32_t *)(v14 + (int32_t)&g79); // 0xe160
    int32_t v16 = *v15; // 0xe160
    *(int16_t *)(v1 + 2 * (int32_t)&g47 + (int32_t)&g37 + (int32_t)&g54 + (int32_t)&g58 + (int32_t)&g7) = (int16_t)v14;
    int32_t v17 = *(int32_t *)(v11 + (int32_t)&g11); // 0xe168
    int32_t v18 = v17 - (int32_t)&g72; // 0xe16c
    *(char *)(v18 + v13) = (char)v16;
    *(int32_t *)(v18 + (int32_t)&g67) = v18;
    *(int32_t *)(v16 + v9) = a1;
    int32_t result = (int32_t)*(char *)(v18 + (int32_t)&g20); // 0xe18a
    if (*v15 + (int32_t)&g47 + (int32_t)&g58 != -v9) {
        // 0xe1ac
        return result + (int32_t)&g40;
    }
    // 0xe18e
    __asm_cdp(13, 4, 4, 1, 3, 5);
    return result;
}

// Address range: 0xe1b6 - 0xe1c6
int32_t function_e1b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xe1b6
    int32_t v1; // 0xe1b6
    *(int32_t *)v1 = a4;
    *(int32_t *)(v1 + (int32_t)&g62) = a4 << (int32_t)&g106;
    return 0;
}

// Address range: 0xe1c6 - 0xe1d6
int32_t function_e1c6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xe1c6
    int32_t v1; // 0xe1c6
    return 32 * v1;
}

// Address range: 0xe1d6 - 0xe20c
int32_t function_e1d6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xe1d6
    int32_t v1; // 0xe1d6
    *(int32_t *)v1 = a4;
    function_e294();
    function_e278(0);
    function_e264();
    function_e3dc();
    int32_t v2 = *(int32_t *)((int32_t)&g11 + 0x4006f000); // 0xe1fa
    return (v2 & 2) != 0;
}

// Address range: 0xe210 - 0xe228
int32_t function_e210(int32_t a1, int32_t a2, int32_t a3) {
    // 0xe210
    bool v1; // 0xe210
    if (v1) {
        *(int32_t *)(a1 - (int32_t)&g106) = a3;
    }
    if (v1) {
        __asm_svceq(0xc007c0);
    }
    return a1 << (int32_t)v1;
}

// Address range: 0xe22a - 0xe23c
int32_t function_e22a(void) {
    // 0xe22a
    function_e2b4();
    *(int32_t *)0x4006f010 = *(int32_t *)0x4006f010 | 1;
    return function_20001388();
}

// Address range: 0xe240 - 0xe262
int32_t function_e240(int32_t a1) {
    // 0xe240
    function_e378();
    function_e398(0);
    function_e32c(a1);
    function_e354();
    function_e3b8();
    return function_e2a8();
}

// Address range: 0xe264 - 0xe272
int32_t function_e264(void) {
    int32_t result = *(int32_t *)0x4006f020 | (int32_t)&g62; // 0xe26a
    *(int32_t *)0x4006f020 = result;
    return result;
}

// Address range: 0xe278 - 0xe290
int32_t function_e278(int32_t a1) {
    int32_t result = *(int32_t *)((int32_t)&g26 + 0x4006f000) & -4 | a1; // 0xe286
    *(int32_t *)0x4006f020 = result;
    return result;
}

// Address range: 0xe294 - 0xe29c
int32_t function_e294(void) {
    // 0xe294
    return *(int32_t *)0x4006f020 & ((int32_t)&g62 ^ -1);
}

// Address range: 0xe2a0 - 0xe2a2
int32_t function_e2a0(void) {
    // 0xe2a0
    int32_t result; // 0xe2a0
    return result;
}

// Address range: 0xe2a8 - 0xe2b0
int32_t function_e2a8(void) {
    // 0xe2a8
    *(int32_t *)0x4006f018 = 85;
    return 85;
}

// Address range: 0xe2b4 - 0xe2bc
int32_t function_e2b4(void) {
    // 0xe2b4
    *(int32_t *)0x4006f01c = 170;
    return 170;
}

// Address range: 0xe2c0 - 0xe2ca
int32_t function_e2c0(uint32_t a1) {
    // 0xe2c0
    return *(int32_t *)(4 * (a1 >> (uint32_t)(int32_t)&g25));
}

// Address range: 0xe2cc - 0xe2cd
int32_t function_e2cc(void) {
    // 0xe2cc
    int32_t result; // 0xe2cc
    return result;
}

// Address range: 0xe2d4 - 0xe308
int32_t function_e2d4(int32_t a1, int32_t a2, int32_t a3) {
    // 0xe2d4
    if (a1 != 0) {
        function_e2d4(a1, (int32_t)&g130, (int32_t)&g130);
    }
    // 0xe2dc
    function_e398(5);
    int32_t v1; // 0xe2d4
    uint32_t v2 = (uint32_t)v1 / 4; // 0xe2e2
    *(int32_t *)0x4006f004 = v2;
    int32_t v3 = __asm_nop((int32_t *)v2, 0x4006f000, v1, v1); // 0xe2ec
    while (v3 != 0) {
        // continue -> 0xe2ee
    }
    // 0xe2f6
    function_e398(0);
    function_e2a8();
    return *(int32_t *)0x4006f00c;
}

// Address range: 0xe30c - 0xe32c
int32_t function_e30c(int32_t result, int32_t a2) {
    // 0xe30c
    int32_t v1; // 0xe30c
    bool v2; // 0xe30c
    if (v2) {
        v1 = *(int32_t *)(result - (int32_t)&g62);
    }
    if (v2) {
        int32_t v3 = v1;
        *(int32_t *)v3 = v3;
        int32_t v4; // 0xe30c
        __asm_sadd8mi(result, v4);
    }
    // .critedge1
    return result;
}

// Address range: 0xe32c - 0xe350
int32_t function_e32c(int32_t result) {
    switch (result) {
        case 0: {
            // 0xe330
            *(int32_t *)0x4006f000 = *(int32_t *)0x4006f000 & -2;
            // break -> 0xe34e
            break;
        }
        case 1: {
            // 0xe342
            *(int32_t *)0x4006f000 = *(int32_t *)0x4006f000 | 1;
            // break -> 0xe34e
            break;
        }
    }
    // 0xe34e
    return result;
}

// Address range: 0xe354 - 0xe370
int32_t function_e354(void) {
    uint16_t v1 = *(int16_t *)0x20000320; // 0xe356
    int32_t v2 = *(int32_t *)0x20000320; // 0xe360
    int32_t result = (int32_t)v1 * 0x80000 * (int32_t)&g51 + 3600 * v2; // 0xe368
    *(int32_t *)0x4006f024 = result;
    return result;
}

// Address range: 0xe378 - 0xe392
int32_t function_e378(void) {
    float32_t v1 = fabsf((float32_t)*(int32_t *)0x4006f000);
    *(int32_t *)0x4006f000 = (int32_t)v1;
    int32_t v2; // 0xe378
    int32_t v3 = __asm_nop((int32_t *)(int32_t)v1, 0x4006f000, v2, v2); // 0xe386
    int32_t result = function_e210(v3, 0x4006f000, v2); // 0xe388
    v3 = 0;
    while (result == 0) {
        // 0xe388
        result = function_e210(v3, 0x4006f000, v2);
        v3 = 0;
    }
    // 0xe390
    return result;
}

// Address range: 0xe398 - 0xe3b2
int32_t function_e398(int32_t a1) {
    int32_t result = *(int32_t *)0x4006f000 & ((int32_t)&g20 ^ -1) | 4 * a1; // 0xe3aa
    *(int32_t *)0x4006f000 = result;
    return result;
}

// Address range: 0xe3b8 - 0xe3d2
int32_t function_e3b8(void) {
    int32_t v1 = *(int32_t *)0x20000320;
    int32_t result = v1 * (2048 * (int32_t)&g13 + (int32_t)&g7); // 0xe3ca
    *(int32_t *)0x4006f028 = result;
    return result;
}

// Address range: 0xe3dc - 0xe3ee
int32_t function_e3dc(void) {
    // 0xe3dc
    __asm_dsb();
    *(int32_t *)-0x1fff12f4 = 0x5fa0004;
    int32_t v1; // 0xe3dc
    __asm_nop((int32_t *)__asm_dsb(), -0x1fff1300, v1, v1);
    while (true) {
        // continue -> 0xe3ec
    }
}

// Address range: 0xe3f8 - 0xe414
int32_t function_e3f8(int32_t a1) {
    // 0xe3f8
    int32_t v1; // 0xe3f8
    function_e30c(1, v1);
    int32_t result = function_e2c0(a1); // 0xe404
    function_e30c(0, v1);
    return result;
}

// Address range: 0xe414 - 0xe4e8
int32_t function_e414(void) {
    // 0xe414
    int32_t v1; // 0xe414
    function_e30c(1, v1);
    *(int32_t *)0x40000080 = function_e2cc();
    *(int32_t *)0x40000084 = function_e2cc();
    *(int32_t *)0x40000088 = function_e2cc();
    *(int32_t *)0x4000008c = function_e2cc();
    *(int32_t *)0x40000078 = function_e2c0(1992);
    *(int32_t *)0x4000007c = function_e2c0(1988);
    *(int32_t *)0x40000820 = function_e2c0(2020);
    *(int32_t *)0x40000824 = function_e2c0(32 * (int32_t)&g61);
    *(int32_t *)0x40000830 = function_e2c0(2008);
    *(int32_t *)0x40000834 = function_e2c0(2004);
    *(int32_t *)0x40000838 = function_e2c0(2000);
    *(int32_t *)0x4000083c = function_e2c0(1996);
    *(int32_t *)0x20000478 = function_e2c0(1976);
    uint32_t v2 = function_e2c0(1980); // 0xe4be
    int32_t v3 = *(int32_t *)((1 << (int32_t)&g23) + (int32_t)&g90); // 0xe4c8
    *(int32_t *)(32 * (1 << (int32_t)&g17) + (int32_t)&g90) = v3 | 1 << (int32_t)&g17;
    *(int32_t *)0x400ba0f0 = v2 % 256;
    *(int32_t *)0x400ba0f4 = 64 * v2 >> (int32_t)&g13;
    return function_e30c(0, 0x400ba0c0);
}

// Address range: 0xe500 - 0xe516
int32_t function_e500(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xe500
    int32_t v1; // 0xe500
    int32_t v2 = v1 << (int32_t)&g44; // 0xe500
    bool v3; // 0xe500
    if (v2 != 0 && v2 < 0 == v3) {
        function_e5de();
    }
    // 0xe504
    return 2 * a4 << (int32_t)&g62;
}

// Address range: 0xe518 - 0xe51c
int32_t function_e518(void) {
    // 0xe518
    int32_t result; // 0xe518
    return result;
}

// Address range: 0xe5de - 0xe5df
int32_t function_e5de(void) {
    // 0xe5de
    int32_t result; // 0xe5de
    return result;
}

// Address range: 0x143be - 0x143bf
int32_t function_143be(void) {
    // 0x143be
    int32_t result; // 0x143be
    return result;
}

// Address range: 0x1f7cc - 0x1f7cd
int32_t function_1f7cc(void) {
    // 0x1f7cc
    int32_t result; // 0x1f7cc
    return result;
}

// Address range: 0x2361a - 0x2361b
int32_t function_2361a(void) {
    // 0x2361a
    int32_t result; // 0x2361a
    return result;
}

// Address range: 0x23648 - 0x23649
int32_t function_23648(void) {
    // 0x23648
    int32_t result; // 0x23648
    return result;
}

// Address range: 0x255c2 - 0x255c3
int32_t function_255c2(void) {
    // 0x255c2
    int32_t result; // 0x255c2
    return result;
}

// Address range: 0x255e2 - 0x255e3
int32_t function_255e2(void) {
    // 0x255e2
    int32_t result; // 0x255e2
    return result;
}

// Address range: 0x2660c - 0x2660d
int32_t function_2660c(void) {
    // 0x2660c
    int32_t result; // 0x2660c
    return result;
}

// Address range: 0x32478 - 0x32479
int32_t function_32478(void) {
    // 0x32478
    int32_t result; // 0x32478
    return result;
}

// Address range: 0x328c4 - 0x328c5
int32_t function_328c4(void) {
    // 0x328c4
    int32_t result; // 0x328c4
    return result;
}

// Address range: 0x3bf4a - 0x3bf4b
int32_t function_3bf4a(void) {
    // 0x3bf4a
    int32_t result; // 0x3bf4a
    return result;
}

// Address range: 0x45d44 - 0x45d45
int32_t function_45d44(void) {
    // 0x45d44
    int32_t result; // 0x45d44
    return result;
}

// Address range: 0x1d5c38 - 0x1d5c39
int32_t function_1d5c38(void) {
    // 0x1d5c38
    int32_t result; // 0x1d5c38
    return result;
}

// Address range: 0x2098ac - 0x2098ad
int32_t function_2098ac(void) {
    // 0x2098ac
    int32_t result; // 0x2098ac
    return result;
}

// Address range: 0x23a37a - 0x23a37b
int32_t function_23a37a(void) {
    // 0x23a37a
    int32_t result; // 0x23a37a
    return result;
}

// Address range: 0x23c1d6 - 0x23c1d7
int32_t function_23c1d6(void) {
    // 0x23c1d6
    int32_t result; // 0x23c1d6
    return result;
}

// Address range: 0x35f8a6 - 0x35f8a7
int32_t function_35f8a6(void) {
    // 0x35f8a6
    int32_t result; // 0x35f8a6
    return result;
}

// Address range: 0x360100 - 0x360101
int32_t function_360100(void) {
    // 0x360100
    int32_t result; // 0x360100
    return result;
}

// Address range: 0x362652 - 0x362653
int32_t function_362652(void) {
    // 0x362652
    int32_t result; // 0x362652
    return result;
}

// Address range: 0x364d5a - 0x364d5b
int32_t function_364d5a(void) {
    // 0x364d5a
    int32_t result; // 0x364d5a
    return result;
}

// Address range: 0x3d09a6 - 0x3d09a7
int32_t function_3d09a6(void) {
    // 0x3d09a6
    int32_t result; // 0x3d09a6
    return result;
}

// Address range: 0x44df04 - 0x44df05
int32_t function_44df04(void) {
    // 0x44df04
    int32_t result; // 0x44df04
    return result;
}

// Address range: 0x4759dc - 0x4759dd
int32_t function_4759dc(void) {
    // 0x4759dc
    int32_t result; // 0x4759dc
    return result;
}

// Address range: 0x9c7b94 - 0x9c7b95
int32_t function_9c7b94(void) {
    // 0x9c7b94
    int32_t result; // 0x9c7b94
    return result;
}

// Address range: 0xa37d3c - 0xa37d3d
int32_t function_a37d3c(void) {
    // 0xa37d3c
    int32_t result; // 0xa37d3c
    return result;
}

// Address range: 0xa93540 - 0xa93541
int32_t function_a93540(void) {
    // 0xa93540
    int32_t result; // 0xa93540
    return result;
}

// Address range: 0xa9452e - 0xa9452f
int32_t function_a9452e(void) {
    // 0xa9452e
    int32_t result; // 0xa9452e
    return result;
}

// Address range: 0xb9b844 - 0xb9b845
int32_t function_b9b844(void) {
    // 0xb9b844
    int32_t result; // 0xb9b844
    return result;
}

// Address range: 0xbf60d4 - 0xbf60d5
int32_t function_bf60d4(void) {
    // 0xbf60d4
    int32_t result; // 0xbf60d4
    return result;
}

// Address range: 0xe9d196 - 0xe9d197
int32_t function_e9d196(void) {
    // 0xe9d196
    int32_t result; // 0xe9d196
    return result;
}

// Address range: 0x10dd868 - 0x10dd869
int32_t function_10dd868(void) {
    // 0x10dd868
    int32_t result; // 0x10dd868
    return result;
}

// Address range: 0x10ddda0 - 0x10ddda1
int32_t function_10ddda0(void) {
    // 0x10ddda0
    int32_t result; // 0x10ddda0
    return result;
}

// Address range: 0x10ddde0 - 0x10ddde1
int32_t function_10ddde0(void) {
    // 0x10ddde0
    int32_t result; // 0x10ddde0
    return result;
}

// Address range: 0x111c280 - 0x111c281
int32_t function_111c280(void) {
    // 0x111c280
    int32_t result; // 0x111c280
    return result;
}

// Address range: 0x1223186 - 0x1223187
int32_t function_1223186(void) {
    // 0x1223186
    int32_t result; // 0x1223186
    return result;
}

// Address range: 0x12dc27c - 0x12dc27d
int32_t function_12dc27c(void) {
    // 0x12dc27c
    int32_t result; // 0x12dc27c
    return result;
}

// Address range: 0x1305104 - 0x1305105
int32_t function_1305104(void) {
    // 0x1305104
    int32_t result; // 0x1305104
    return result;
}

// Address range: 0x1414692 - 0x1414693
int32_t function_1414692(void) {
    // 0x1414692
    int32_t result; // 0x1414692
    return result;
}

// Address range: 0x14d99cc - 0x14d99cd
int32_t function_14d99cc(void) {
    // 0x14d99cc
    int32_t result; // 0x14d99cc
    return result;
}

// Address range: 0x1599670 - 0x1599671
int32_t function_1599670(void) {
    // 0x1599670
    int32_t result; // 0x1599670
    return result;
}

// Address range: 0x18d672e - 0x18d672f
int32_t function_18d672e(void) {
    // 0x18d672e
    int32_t result; // 0x18d672e
    return result;
}

// Address range: 0x1a3b336 - 0x1a3b337
int32_t function_1a3b336(void) {
    // 0x1a3b336
    int32_t result; // 0x1a3b336
    return result;
}

// Address range: 0x1c65720 - 0x1c65721
int32_t function_1c65720(void) {
    // 0x1c65720
    int32_t result; // 0x1c65720
    return result;
}

// Address range: 0x1cdf99a - 0x1cdf99b
int32_t function_1cdf99a(void) {
    // 0x1cdf99a
    int32_t result; // 0x1cdf99a
    return result;
}

// Address range: 0x1dc156e - 0x1dc156f
int32_t function_1dc156e(void) {
    // 0x1dc156e
    int32_t result; // 0x1dc156e
    return result;
}

// Address range: 0x20001388 - 0x20001389
int32_t function_20001388(void) {
    // 0x20001388
    int32_t result; // 0x20001388
    return result;
}

// Address range: 0x202ed3f6 - 0x202ed3f7
int32_t function_202ed3f6(void) {
    // 0x202ed3f6
    int32_t result; // 0x202ed3f6
    return result;
}

// Address range: 0xfe00e3ce - 0xfe00e3cf
int32_t function_fe00e3ce(void) {
    // 0xfe00e3ce
    int32_t result; // 0xfe00e3ce
    return result;
}

// Address range: 0xfe43c266 - 0xfe43c267
int32_t function_fe43c266(void) {
    // 0xfe43c266
    int32_t result; // 0xfe43c266
    return result;
}

// Address range: 0xfe8b13b2 - 0xfe8b13b3
int32_t function_fe8b13b2(void) {
    // 0xfe8b13b2
    int32_t result; // 0xfe8b13b2
    return result;
}

// Address range: 0xfe9804c0 - 0xfe9804c1
int32_t function_fe9804c0(void) {
    // 0xfe9804c0
    int32_t result; // 0xfe9804c0
    return result;
}

// Address range: 0xfeead194 - 0xfeead195
int32_t function_feead194(void) {
    // 0xfeead194
    int32_t result; // 0xfeead194
    return result;
}

// Address range: 0xff30e4c2 - 0xff30e4c3
int32_t function_ff30e4c2(void) {
    // 0xff30e4c2
    int32_t result; // 0xff30e4c2
    return result;
}

// Address range: 0xff3e529a - 0xff3e529b
int32_t function_ff3e529a(void) {
    // 0xff3e529a
    int32_t result; // 0xff3e529a
    return result;
}

// Address range: 0xff43a262 - 0xff43a263
int32_t function_ff43a262(void) {
    // 0xff43a262
    int32_t result; // 0xff43a262
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: upx (3.93)
// Detected functions: 680

